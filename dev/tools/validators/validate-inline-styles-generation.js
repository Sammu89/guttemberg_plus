/**
 * Inline Styles Generation Validator
 *
 * Validates that auto-generated inline styles in edit.js properly handle ALL attribute types,
 * control types, and special cases defined in the schema.
 *
 * CRITICAL CHECKS:
 * 1. All attributes with cssProperty have inline style generation
 * 2. Control-specific handlers exist (ColorControl, AppearanceControl, etc.)
 * 3. Object properties are properly extracted (.color, .weight, .style, etc.)
 * 4. Arrays are properly processed (formatting ‚Üí fontStyle)
 * 5. Responsive attributes have device-specific value extraction
 * 6. Type-specific conversions are correct (string‚Üínumber for RangeControl)
 *
 * This validator catches bugs like:
 * - Decoration color showing "[object Object]" (missing .color extraction)
 * - Formatting array not converting to fontStyle: 'italic'
 * - Responsive values not being accessed correctly
 * - AppearanceControl not splitting into fontWeight/fontStyle
 *
 * @package GuttemberPlus
 * @since 1.0.0
 */

const fs = require('fs');
const path = require('path');

const BLOCKS_DIR = path.join(__dirname, '../../blocks');
const SCHEMAS_DIR = path.join(__dirname, '../../schemas');

/**
 * Define control types that require special handling
 */
const SPECIAL_CONTROL_HANDLERS = {
	'ColorControl': {
		requiresObjectExtraction: true,
		extractProperty: 'color',
		description: 'ColorControl returns {color: value}, must extract .color property'
	},
	'AppearanceControl': {
		requiresObjectExtraction: true,
		extractProperties: ['weight', 'style'],
		generatesCSSProperties: ['fontWeight', 'fontStyle'],
		description: 'AppearanceControl returns {weight, style}, must split into fontWeight and fontStyle'
	},
	'ShadowPanel': {
		requiresArrayProcessing: true,
		requiresFunction: 'buildTextShadow or buildBoxShadow',
		description: 'ShadowPanel returns array, must use shadow builder function'
	}
};

/**
 * Define attribute patterns that require special handling
 */
const SPECIAL_ATTRIBUTE_PATTERNS = {
	'formatting': {
		type: 'array',
		requiresExtraction: true,
		extractTo: 'fontStyle',
		extractLogic: 'check if array includes "italic"',
		description: 'Formatting array must be converted to fontStyle: "italic" or "normal"'
	},
	'decorationColor': {
		type: 'string',
		controlType: 'ColorControl',
		requiresObjectExtraction: true,
		extractProperty: 'color',
		description: 'Decoration color uses ColorControl, must extract .color property'
	}
};

/**
 * Extract inline styles code from edit.js
 */
function extractInlineStylesCode(fileContent) {
	const startMarker = '/* ========== AUTO-GENERATED-STYLES-START ========== */';
	const endMarker = '/* ========== AUTO-GENERATED-STYLES-END ========== */';

	const startIdx = fileContent.indexOf(startMarker);
	const endIdx = fileContent.indexOf(endMarker);

	if (startIdx === -1 || endIdx === -1) {
		return null;
	}

	return fileContent.substring(startIdx, endIdx + endMarker.length);
}

/**
 * Load comprehensive schema with all expanded attributes
 */
function loadComprehensiveSchema(blockType) {
	const schemaPath = path.join(SCHEMAS_DIR, `${blockType}-comprehensive-autogenerated.json`);
	if (!fs.existsSync(schemaPath)) {
		return null;
	}
	return JSON.parse(fs.readFileSync(schemaPath, 'utf8'));
}

/**
 * Check if attribute uses responsive device selection
 */
function checkResponsiveHandling(inlineStylesCode, attrName, attr) {
	const errors = [];

	if (!attr.responsive) {
		return errors;
	}

	// Check if code accesses device-specific values
	const deviceAccessPatterns = [
		`effectiveValues.${attrName}[responsiveDevice]`,
		`val[responsiveDevice]`,
		`rawVal[responsiveDevice]`
	];

	const hasDeviceAccess = deviceAccessPatterns.some(pattern =>
		inlineStylesCode.includes(pattern)
	);

	if (!hasDeviceAccess) {
		errors.push({
			type: 'missing-responsive-handling',
			attribute: attrName,
			message: `Responsive attribute "${attrName}" doesn't access device-specific values (tablet/mobile)`
		});
	}

	return errors;
}

/**
 * Check if control type has required special handling
 */
function checkControlTypeHandling(inlineStylesCode, attrName, attr) {
	const errors = [];
	const warnings = [];

	const controlType = attr.control;
	if (!controlType) {
		return { errors, warnings };
	}

	const specialHandler = SPECIAL_CONTROL_HANDLERS[controlType];
	if (!specialHandler) {
		return { errors, warnings };
	}

	// Check ColorControl - must extract .color property
	if (controlType === 'ColorControl' && !attrName.toLowerCase().includes('color')) {
		warnings.push({
			type: 'control-naming-mismatch',
			attribute: attrName,
			message: `Attribute "${attrName}" uses ColorControl but name doesn't include 'color' - may not be handled correctly`
		});
	}

	// Check for object property extraction
	if (specialHandler.requiresObjectExtraction) {
		const hasObjectExtraction = inlineStylesCode.includes(`val.${specialHandler.extractProperty}`) ||
			(specialHandler.extractProperties &&
			 specialHandler.extractProperties.some(prop => inlineStylesCode.includes(`val.${prop}`) || inlineStylesCode.includes(`val?.${prop}`)));

		if (!hasObjectExtraction) {
			// Check if attribute name pattern gets special handling
			const attrLower = attrName.toLowerCase();
			const isDecorationColor = attrLower.includes('decorationcolor');
			const isAppearance = controlType === 'AppearanceControl';

			if ((controlType === 'ColorControl' && !isDecorationColor) ||
			    (isAppearance && !inlineStylesCode.includes('?.weight'))) {
				errors.push({
					type: 'missing-object-extraction',
					attribute: attrName,
					control: controlType,
					message: `${controlType} for "${attrName}" doesn't extract object properties. ${specialHandler.description}`
				});
			}
		}
	}

	// Check for array processing
	if (specialHandler.requiresArrayProcessing) {
		const hasArrayProcessing = inlineStylesCode.includes(specialHandler.requiresFunction.split(' ')[0]);
		if (!hasArrayProcessing) {
			errors.push({
				type: 'missing-array-processing',
				attribute: attrName,
				control: controlType,
				message: `${controlType} for "${attrName}" doesn't use required function. ${specialHandler.description}`
			});
		}
	}

	return { errors, warnings };
}

/**
 * Check if attribute pattern requires special handling
 */
function checkAttributePatternHandling(inlineStylesCode, attrName, attr) {
	const errors = [];
	const warnings = [];

	for (const [pattern, requirements] of Object.entries(SPECIAL_ATTRIBUTE_PATTERNS)) {
		const attrLower = attrName.toLowerCase();

		if (!attrLower.includes(pattern.toLowerCase())) {
			continue;
		}

		// Check type matches
		if (requirements.type && attr.type !== requirements.type) {
			warnings.push({
				type: 'pattern-type-mismatch',
				attribute: attrName,
				pattern,
				message: `Attribute "${attrName}" matches pattern "${pattern}" but has type "${attr.type}" instead of expected "${requirements.type}"`
			});
			continue;
		}

		// Check for special extraction logic
		if (requirements.requiresExtraction) {
			const hasExtraction = inlineStylesCode.includes(requirements.extractTo);
			if (!hasExtraction) {
				errors.push({
					type: 'missing-pattern-extraction',
					attribute: attrName,
					pattern,
					message: `Attribute "${attrName}" matches pattern "${pattern}" but doesn't extract to "${requirements.extractTo}". ${requirements.description}`
				});
			}
		}

		// Check for object extraction
		if (requirements.requiresObjectExtraction && requirements.extractProperty) {
			const hasObjectExtraction = inlineStylesCode.includes(`.${requirements.extractProperty}`);
			if (!hasObjectExtraction) {
				errors.push({
					type: 'missing-pattern-object-extraction',
					attribute: attrName,
					pattern,
					message: `Attribute "${attrName}" matches pattern "${pattern}" but doesn't extract ".${requirements.extractProperty}". ${requirements.description}`
				});
			}
		}
	}

	return { errors, warnings };
}

/**
 * Check if all attributes with cssProperty have inline style generation
 */
function checkAllAttributesHaveStyles(inlineStylesCode, schema) {
	const errors = [];
	const warnings = [];

	for (const [attrName, attr] of Object.entries(schema.attributes || {})) {
		// Skip attributes without cssProperty (not rendered as inline styles)
		if (!attr.cssProperty || !attr.appliesTo) {
			continue;
		}

		// Skip excluded elements
		const appliesTo = attr.appliesTo;
		const knownSkipElements = [
			'wrapper', 'item', 'panel', 'tabPanel', 'list', 'listItem',
			'link', 'h1Link', 'h2Link', 'h3Link', 'h4Link', 'h5Link', 'h6Link',
			'numberingStyle'
		];
		if (knownSkipElements.includes(appliesTo)) {
			continue;
		}

		// Check if attribute is accessed in inline styles code
		const isAccessed = inlineStylesCode.includes(`effectiveValues.${attrName}`);
		if (!isAccessed) {
			warnings.push({
				type: 'attribute-not-in-inline-styles',
				attribute: attrName,
				message: `Attribute "${attrName}" has cssProperty "${attr.cssProperty}" but is NOT accessed in inline styles code`
			});
		}
	}

	return { errors, warnings };
}

/**
 * Validate inline styles generation for a single block
 */
function validateInlineStyles(blockType) {
	const errors = [];
	const warnings = [];

	// Load edit.js
	const editPath = path.join(BLOCKS_DIR, blockType, 'src', 'edit.js');
	if (!fs.existsSync(editPath)) {
		errors.push({
			type: 'file-not-found',
			message: `edit.js not found: ${editPath}`
		});
		return { errors, warnings };
	}

	const editContent = fs.readFileSync(editPath, 'utf8');

	// Extract inline styles section
	const inlineStylesCode = extractInlineStylesCode(editContent);
	if (!inlineStylesCode) {
		errors.push({
			type: 'no-inline-styles-section',
			message: `No AUTO-GENERATED-STYLES section found in edit.js`
		});
		return { errors, warnings };
	}

	// Load comprehensive schema
	const schema = loadComprehensiveSchema(blockType);
	if (!schema) {
		warnings.push({
			type: 'no-comprehensive-schema',
			message: `No comprehensive schema found for ${blockType}`
		});
		return { errors, warnings };
	}

	// Validate all attributes with cssProperty have inline styles
	const allAttrsResult = checkAllAttributesHaveStyles(inlineStylesCode, schema);
	errors.push(...allAttrsResult.errors);
	warnings.push(...allAttrsResult.warnings);

	// Validate each attribute
	for (const [attrName, attr] of Object.entries(schema.attributes || {})) {
		// Skip non-inline-style attributes
		if (!attr.cssProperty || !attr.appliesTo) {
			continue;
		}

		// Check responsive handling
		const responsiveErrors = checkResponsiveHandling(inlineStylesCode, attrName, attr);
		errors.push(...responsiveErrors);

		// Check control-specific handling
		const controlResult = checkControlTypeHandling(inlineStylesCode, attrName, attr);
		errors.push(...controlResult.errors);
		warnings.push(...controlResult.warnings);

		// Check attribute pattern handling
		const patternResult = checkAttributePatternHandling(inlineStylesCode, attrName, attr);
		errors.push(...patternResult.errors);
		warnings.push(...patternResult.warnings);
	}

	return { errors, warnings };
}

/**
 * Validate all blocks
 */
function validateAll(options = {}) {
	const { warnOnly = false } = options;
	const blocks = ['accordion', 'tabs', 'toc'];

	console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
	console.log('‚ïë  Inline Styles Generation Validation                      ‚ïë');
	console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');

	let totalErrors = 0;
	let totalWarnings = 0;
	let allPassed = true;

	blocks.forEach(blockType => {
		console.log(`\nüì¶ ${blockType.toUpperCase()}`);
		console.log('‚îÄ'.repeat(60));

		const { errors, warnings } = validateInlineStyles(blockType);

		if (errors.length > 0) {
			allPassed = false;
			console.log(`\n‚ùå ${errors.length} ERRORS:`);
			errors.forEach((err, i) => {
				console.log(`   ${i + 1}. [${err.type}] ${err.message}`);
				if (err.attribute) console.log(`      Attribute: ${err.attribute}`);
				if (err.control) console.log(`      Control: ${err.control}`);
			});
			totalErrors += errors.length;
		}

		if (warnings.length > 0) {
			console.log(`\n‚ö†Ô∏è  ${warnings.length} WARNINGS:`);
			warnings.forEach((warn, i) => {
				console.log(`   ${i + 1}. [${warn.type}] ${warn.message}`);
				if (warn.attribute) console.log(`      Attribute: ${warn.attribute}`);
			});
			totalWarnings += warnings.length;
		}

		if (errors.length === 0 && warnings.length === 0) {
			console.log(`‚úÖ All inline styles properly generated`);
		}
	});

	console.log('\n' + '‚ïê'.repeat(60));
	console.log(`üìä SUMMARY: ${totalErrors} errors, ${totalWarnings} warnings`);
	console.log('‚ïê'.repeat(60) + '\n');

	if (warnOnly) {
		console.log('‚ö†Ô∏è  WARN-ONLY MODE: Validation issues will not block build\n');
		return { totalErrors, totalWarnings };
	}

	if (!allPassed) {
		console.log('‚ùå INLINE STYLES VALIDATION FAILED\n');
		console.log('üí° HINT: Check schema-compiler.js inline styles generator (lines 3100-3233)');
		console.log('   - Add special handling for missing control types');
		console.log('   - Add object property extraction for ColorControl');
		console.log('   - Add array processing for formatting attributes\n');
		process.exit(1);
	} else if (totalWarnings > 0) {
		console.log('‚ö†Ô∏è  VALIDATION PASSED WITH WARNINGS\n');
	} else {
		console.log('‚úÖ ALL INLINE STYLES VALIDATIONS PASSED\n');
	}

	return { totalErrors, totalWarnings };
}

// Run if called directly
if (require.main === module) {
	const warnOnly = process.argv.includes('--warn-only');
	validateAll({ warnOnly });
}

module.exports = { validateInlineStyles, validateAll };
