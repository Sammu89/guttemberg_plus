# Structure JSX Generator - Block-Agnostic Architecture

## Overview

The `structure-jsx-generator.js` has been refactored to be completely block-agnostic, supporting different structural patterns for accordion, tabs, and TOC blocks through a pattern detection and strategy-based generation system.

## Architecture

### 1. Pattern Detection System

The generator automatically detects which block pattern to use based on the elements present in the structure mapping:

```javascript
detectBlockPattern(structureMapping)
```

**Detection Rules:**
- **Accordion**: Detects `titleWrapper` + `content` + `contentInner` elements
- **Tabs**: Detects `tabsList` + `tabsPanels` elements
- **TOC**: Detects `list` + (`titleStatic` OR `titleButton`) elements

**Fallback**: If no pattern matches, falls back to `structureMapping.blockType`

### 2. Generation Strategy Pattern

The generator uses a strategy pattern to delegate to block-specific generators:

```
generateStructureJsx()
  ├── generateRenderTitle()
  │   ├── generateAccordionRenderTitle()
  │   ├── generateTabsRenderTitle()
  │   └── generateTocRenderTitle()
  │
  └── generateBlockContent()
      ├── generateAccordionBlockContent()
      ├── generateTabsBlockContent()
      └── generateTocBlockContent()
```

### 3. Block-Specific Generators

Each block type has two dedicated generator functions:

#### Accordion
- `generateAccordionRenderTitle()` - Generates single button with RichText title
- `generateAccordionBlockContent()` - Generates titleWrapper + content + InnerBlocks

#### Tabs
- `generateTabsRenderTitle()` - Generates multiple buttons from tabsData array
- `generateTabsBlockContent()` - Generates tabsList + tabsPanels with scroll wrapper

#### TOC
- `generateTocRenderTitle()` - Generates conditional button or static title
- `generateTocBlockContent()` - Generates wrapper + list (no InnerBlocks)

## Key Features

### ✅ Block Agnostic
- No hardcoded block names in core logic
- Pattern detection based on structure elements
- Easy to add new block types

### ✅ Mode Support
- **Save Mode**: Generates `RichText.Content`, `InnerBlocks.Content`, ARIA attributes
- **Edit Mode**: Generates `RichText`, `InnerBlocks`, event handlers

### ✅ Graceful Handling
- Validates structure mappings
- Provides clear error messages
- Handles missing elements gracefully

### ✅ Extensible
- Clear separation of concerns
- Pattern-specific generators isolated
- Easy to add new patterns

## Structure Mapping Requirements

Each block pattern requires specific elements in the structure mapping:

### Accordion Pattern
```json
{
  "structure": {
    "elements": {
      "titleWrapper": { ... },
      "content": { ... },
      "contentInner": { ... }
    }
  }
}
```

### Tabs Pattern
```json
{
  "structure": {
    "elements": {
      "wrapper": { ... },
      "tabsList": { ... },
      "tabsPanels": { ... }
    }
  }
}
```

### TOC Pattern
```json
{
  "structure": {
    "elements": {
      "wrapper": { ... },
      "titleStatic": { ... },  // OR titleButton
      "content": { ... },
      "list": { ... }
    }
  }
}
```

## Adding a New Block Pattern

To add support for a new block type (e.g., "carousel"):

### Step 1: Create Structure Mapping
Create `schemas/carousel-structure-mapping-autogenerated.json` with unique element IDs:
```json
{
  "blockType": "carousel",
  "structure": {
    "elements": {
      "carouselWrapper": { ... },
      "carouselTrack": { ... },
      "carouselSlides": { ... }
    }
  }
}
```

### Step 2: Add Detection Logic
Update `detectBlockPattern()`:
```javascript
function detectBlockPattern(structureMapping) {
  const elements = structureMapping.structure.elements;
  const elementIds = Object.keys(elements);

  // Check for carousel pattern
  if (elementIds.includes('carouselTrack') && elementIds.includes('carouselSlides')) {
    return 'carousel';
  }

  // ... existing patterns
}
```

### Step 3: Implement Render Title Generator
Create `generateCarouselRenderTitle()`:
```javascript
function generateCarouselRenderTitle(structureMapping, mode) {
  let code = `/**
 * Render carousel navigation
 */
const renderNavigation = () => {
  // Your carousel-specific logic here
};`;

  return code;
}
```

### Step 4: Implement Block Content Generator
Create `generateCarouselBlockContent()`:
```javascript
function generateCarouselBlockContent(structureMapping, mode) {
  const trackEl = structureMapping.structure.elements.carouselTrack;
  const slidesEl = structureMapping.structure.elements.carouselSlides;

  let code = '';
  if (mode === 'save') {
    code += `
    return (
      <div { ...blockProps }>
        <div className="${trackEl.classes[0]}">
          <div className="${slidesEl.classes[0]}">
            <InnerBlocks.Content />
          </div>
        </div>
      </div>
    );`;
  } else {
    // Edit mode implementation
  }

  return code;
}
```

### Step 5: Update Dispatcher Functions
Add cases to both `generateRenderTitle()` and `generateBlockContent()`:
```javascript
function generateRenderTitle(structureMapping, mode) {
  const blockPattern = detectBlockPattern(structureMapping);

  switch (blockPattern) {
    case 'carousel':
      return generateCarouselRenderTitle(structureMapping, mode);
    // ... existing cases
  }
}

function generateBlockContent(structureMapping, mode) {
  const blockPattern = detectBlockPattern(structureMapping);

  switch (blockPattern) {
    case 'carousel':
      return generateCarouselBlockContent(structureMapping, mode);
    // ... existing cases
  }
}
```

### Step 6: Update Validation
Add carousel validation to `validateStructureMapping()`:
```javascript
case 'carousel':
  if (!elements.carouselWrapper) errors.push('Carousel pattern requires carouselWrapper element');
  if (!elements.carouselTrack) errors.push('Carousel pattern requires carouselTrack element');
  if (!elements.carouselSlides) errors.push('Carousel pattern requires carouselSlides element');
  break;
```

### Step 7: Update Supported Patterns
Add to `getSupportedPatterns()`:
```javascript
function getSupportedPatterns() {
  return ['accordion', 'tabs', 'toc', 'carousel'];
}
```

## API Reference

### Main Functions

#### `generateStructureJsx(structureMapping, mode)`
Main entry point. Generates complete JSX code with headers.

**Parameters:**
- `structureMapping` (Object) - Structure mapping JSON
- `mode` (string) - 'save' or 'edit'

**Returns:** String - Complete generated code with headers and footers

#### `generateRenderTitle(structureMapping, mode)`
Generates render title/header function code.

**Returns:** String - Render function code

#### `generateBlockContent(structureMapping, mode)`
Generates block content JSX code.

**Returns:** String - Block content code

### Utility Functions

#### `detectBlockPattern(structureMapping)`
Detects block pattern from structure elements.

**Returns:** String - Pattern name ('accordion', 'tabs', 'toc')

#### `validateStructureMapping(structureMapping)`
Validates structure mapping has required elements.

**Returns:** Object - `{ valid: boolean, errors: string[], blockPattern: string }`

#### `getSupportedPatterns()`
Gets list of supported block patterns.

**Returns:** Array - Pattern names

## Testing

Run pattern detection and validation tests:

```bash
node -e "
const generator = require('./build-tools/generators/structure-jsx-generator.js');

// Test pattern detection
const mapping = require('./schemas/accordion-structure-mapping-autogenerated.json');
const pattern = generator.detectBlockPattern(mapping);
console.log('Detected pattern:', pattern);

// Validate structure
const validation = generator.validateStructureMapping(mapping);
console.log('Valid:', validation.valid);
if (!validation.valid) {
  console.log('Errors:', validation.errors);
}
"
```

## Benefits

1. **Maintainability**: Clear separation between patterns makes code easier to understand and modify
2. **Extensibility**: Adding new block types follows a clear, documented process
3. **Reliability**: Pattern detection and validation catch errors early
4. **Flexibility**: Each block pattern can have its own unique structure
5. **Type Safety**: Validation ensures required elements are present

## Future Enhancements

Potential improvements for future versions:

1. **Configuration-Based Patterns**: Move pattern definitions to JSON config files
2. **Custom Pattern Registration**: Allow plugins to register new patterns
3. **Pattern Composition**: Support mixing patterns (e.g., accordion + tabs)
4. **Schema Validation**: JSON schema validation for structure mappings
5. **Auto-Documentation**: Generate documentation from pattern definitions
