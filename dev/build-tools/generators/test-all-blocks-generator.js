/**
 * Comprehensive test script for block-agnostic generator
 *
 * Tests generateStructureJsx() and generateBlockContent() for:
 * - Accordion (save & edit modes)
 * - Tabs (save & edit modes)
 * - TOC (save & edit modes)
 *
 * Validation checks:
 * - JSX syntax validity (using @babel/parser)
 * - Correct RichText component usage per mode
 * - Mode-specific differences (onChange handlers)
 * - Proper indentation
 * - No undefined references
 * - Correct InnerBlocks usage
 *
 * @package GuttemberPlus
 * @since 1.0.0
 */

const fs = require('fs');
const path = require('path');

// Try to load the generator functions - handle missing exports gracefully
let generateStructureJsx, generateBlockContent;
try {
  const generator = require('./structure-jsx-generator');
  generateStructureJsx = generator.generateStructureJsx;
  generateBlockContent = generator.generateBlockContent;
} catch (error) {
  console.error('Error loading generator:', error.message);
  process.exit(1);
}

// Color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  gray: '\x1b[90m',
};

// Test configuration
const BLOCKS = ['accordion', 'tabs', 'toc'];
const MODES = ['save', 'edit'];

// Test results storage
const results = {
  passed: 0,
  failed: 0,
  warnings: 0,
  tests: [],
};

/**
 * Print section header
 */
function printHeader(title) {
  console.log();
  console.log(colors.bright + colors.cyan + '='.repeat(80) + colors.reset);
  console.log(colors.bright + colors.cyan + title + colors.reset);
  console.log(colors.bright + colors.cyan + '='.repeat(80) + colors.reset);
  console.log();
}

/**
 * Print subsection header
 */
function printSubHeader(title) {
  console.log();
  console.log(colors.bright + colors.blue + '-'.repeat(80) + colors.reset);
  console.log(colors.bright + colors.blue + title + colors.reset);
  console.log(colors.bright + colors.blue + '-'.repeat(80) + colors.reset);
  console.log();
}

/**
 * Print test result
 */
function printResult(status, message) {
  const symbol = status === 'pass' ? 'âœ“' : status === 'fail' ? 'âœ—' : 'âš ';
  const color = status === 'pass' ? colors.green : status === 'fail' ? colors.red : colors.yellow;
  console.log(color + symbol + ' ' + message + colors.reset);
}

/**
 * Load structure mapping for a block
 */
function loadStructureMapping(blockType) {
  const filePath = path.join(
    __dirname,
    `../../schemas/${blockType}-structure-mapping-autogenerated.json`
  );

  try {
    return JSON.parse(fs.readFileSync(filePath, 'utf8'));
  } catch (error) {
    printResult('fail', `Failed to load structure mapping for ${blockType}: ${error.message}`);
    return null;
  }
}

/**
 * Validate JSX syntax using a simple parser check
 * (Note: Full babel parsing requires async setup, so we do basic validation)
 */
function validateJSXSyntax(code) {
  const errors = [];

  // Check for basic syntax issues
  const lines = code.split('\n');
  let openBraces = 0;
  let openParens = 0;
  let openBrackets = 0;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Count braces, parens, brackets
    for (const char of line) {
      if (char === '{') openBraces++;
      if (char === '}') openBraces--;
      if (char === '(') openParens++;
      if (char === ')') openParens--;
      if (char === '[') openBrackets++;
      if (char === ']') openBrackets--;
    }

    // Check for common JSX errors
    if (line.includes('undefined.')) {
      errors.push(`Line ${i + 1}: Potential undefined reference`);
    }

    // Check for unterminated strings
    const singleQuotes = (line.match(/'/g) || []).length;
    const doubleQuotes = (line.match(/"/g) || []).length;
    const backticks = (line.match(/`/g) || []).length;

    // Skip lines with comments or template literals
    if (!line.includes('//') && !line.includes('/*')) {
      if (singleQuotes % 2 !== 0 && !line.includes("'s ") && !line.includes("\\'")) {
        errors.push(`Line ${i + 1}: Possible unterminated string (single quotes)`);
      }
    }
  }

  // Check final balance
  if (openBraces !== 0) {
    errors.push(`Unbalanced braces: ${openBraces > 0 ? 'missing' : 'extra'} ${Math.abs(openBraces)} closing brace(s)`);
  }
  if (openParens !== 0) {
    errors.push(`Unbalanced parentheses: ${openParens > 0 ? 'missing' : 'extra'} ${Math.abs(openParens)} closing paren(s)`);
  }
  if (openBrackets !== 0) {
    errors.push(`Unbalanced brackets: ${openBrackets > 0 ? 'missing' : 'extra'} ${Math.abs(openBrackets)} closing bracket(s)`);
  }

  return errors;
}

/**
 * Validate RichText component usage
 */
function validateRichTextUsage(code, mode) {
  const errors = [];
  const warnings = [];

  if (mode === 'save') {
    // In save mode, should use RichText.Content
    if (code.includes('<RichText ') || code.includes('<RichText\n')) {
      errors.push('Found RichText component in save mode (should be RichText.Content)');
    }

    // Should have RichText.Content
    if (!code.includes('RichText.Content')) {
      warnings.push('No RichText.Content found in save mode');
    }

    // Should NOT have onChange
    if (code.includes('onChange')) {
      errors.push('Found onChange handler in save mode (not allowed)');
    }
  } else {
    // In edit mode, should use RichText (not .Content)
    if (code.includes('RichText.Content')) {
      errors.push('Found RichText.Content in edit mode (should be RichText)');
    }

    // Should have onChange handlers
    if (code.includes('RichText') && !code.includes('onChange')) {
      warnings.push('RichText component without onChange handler in edit mode');
    }
  }

  return { errors, warnings };
}

/**
 * Validate InnerBlocks usage
 */
function validateInnerBlocksUsage(code, mode) {
  const errors = [];
  const warnings = [];

  if (mode === 'save') {
    // In save mode, should use InnerBlocks.Content
    if (code.includes('<InnerBlocks ') || code.includes('<InnerBlocks\n') || code.includes('<InnerBlocks/>')) {
      errors.push('Found InnerBlocks component in save mode (should be InnerBlocks.Content)');
    }

    // Should have InnerBlocks.Content
    if (!code.includes('InnerBlocks.Content')) {
      warnings.push('No InnerBlocks.Content found in save mode');
    }
  } else {
    // In edit mode, should use InnerBlocks (not .Content)
    if (code.includes('InnerBlocks.Content')) {
      errors.push('Found InnerBlocks.Content in edit mode (should be InnerBlocks)');
    }

    // Should have InnerBlocks
    if (!code.includes('<InnerBlocks')) {
      warnings.push('No InnerBlocks component found in edit mode');
    }
  }

  return { errors, warnings };
}

/**
 * Check indentation consistency (2 spaces)
 */
function validateIndentation(code) {
  const errors = [];
  const lines = code.split('\n');

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.length === 0) continue;

    const leadingSpaces = line.match(/^(\s*)/)[1];
    const tabCount = (leadingSpaces.match(/\t/g) || []).length;

    if (tabCount > 0) {
      errors.push(`Line ${i + 1}: Uses tabs instead of spaces`);
    }

    // Check if indentation is multiple of 2
    const spaceCount = leadingSpaces.length - tabCount;
    if (spaceCount % 2 !== 0 && leadingSpaces.length > 0) {
      errors.push(`Line ${i + 1}: Indentation not multiple of 2 spaces (found ${spaceCount} spaces)`);
    }
  }

  return errors;
}

/**
 * Count various code metrics
 */
function getCodeMetrics(code) {
  const lines = code.split('\n');
  const metrics = {
    totalLines: lines.length,
    codeLines: lines.filter(l => l.trim().length > 0 && !l.trim().startsWith('//')).length,
    commentLines: lines.filter(l => l.trim().startsWith('//') || l.trim().startsWith('/*')).length,
    richTextCount: (code.match(/<RichText/g) || []).length,
    innerBlocksCount: (code.match(/<InnerBlocks/g) || []).length,
    conditionalCount: (code.match(/if\s*\(/g) || []).length,
    functionCount: (code.match(/const\s+\w+\s*=/g) || []).length,
  };

  return metrics;
}

/**
 * Display code sample (first N lines)
 */
function displayCodeSample(code, maxLines = 20) {
  const lines = code.split('\n');
  const sample = lines.slice(0, maxLines).join('\n');

  console.log(colors.dim + 'â”Œâ”€ Code Sample (first ' + maxLines + ' lines) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€' + colors.reset);
  sample.split('\n').forEach((line, i) => {
    const lineNum = String(i + 1).padStart(3, ' ');
    console.log(colors.dim + 'â”‚ ' + colors.gray + lineNum + ' â”‚ ' + colors.reset + line);
  });

  if (lines.length > maxLines) {
    console.log(colors.dim + 'â”‚ ' + colors.gray + '... ' + colors.reset + `(${lines.length - maxLines} more lines)` + colors.reset);
  }

  console.log(colors.dim + 'â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€' + colors.reset);
  console.log();
}

/**
 * Display metrics table
 */
function displayMetrics(metrics) {
  console.log(colors.dim + 'â”Œâ”€ Code Metrics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€' + colors.reset);
  console.log(colors.dim + 'â”‚ ' + colors.reset + 'Total Lines:       ' + colors.bright + metrics.totalLines + colors.reset);
  console.log(colors.dim + 'â”‚ ' + colors.reset + 'Code Lines:        ' + colors.bright + metrics.codeLines + colors.reset);
  console.log(colors.dim + 'â”‚ ' + colors.reset + 'Comment Lines:     ' + colors.bright + metrics.commentLines + colors.reset);
  console.log(colors.dim + 'â”‚ ' + colors.reset + 'RichText Count:    ' + colors.bright + metrics.richTextCount + colors.reset);
  console.log(colors.dim + 'â”‚ ' + colors.reset + 'InnerBlocks Count: ' + colors.bright + metrics.innerBlocksCount + colors.reset);
  console.log(colors.dim + 'â”‚ ' + colors.reset + 'Conditionals:      ' + colors.bright + metrics.conditionalCount + colors.reset);
  console.log(colors.dim + 'â”‚ ' + colors.reset + 'Functions:         ' + colors.bright + metrics.functionCount + colors.reset);
  console.log(colors.dim + 'â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€' + colors.reset);
  console.log();
}

/**
 * Run validation tests on generated code
 */
function runValidationTests(code, blockType, mode, functionName) {
  const testResult = {
    blockType,
    mode,
    functionName,
    passed: true,
    errors: [],
    warnings: [],
    metrics: null,
  };

  // 1. Validate JSX syntax
  const syntaxErrors = validateJSXSyntax(code);
  if (syntaxErrors.length > 0) {
    testResult.errors.push(...syntaxErrors.map(e => `Syntax: ${e}`));
    testResult.passed = false;
  }

  // 2. Validate RichText usage
  const richTextValidation = validateRichTextUsage(code, mode);
  if (richTextValidation.errors.length > 0) {
    testResult.errors.push(...richTextValidation.errors.map(e => `RichText: ${e}`));
    testResult.passed = false;
  }
  testResult.warnings.push(...richTextValidation.warnings.map(w => `RichText: ${w}`));

  // 3. Validate InnerBlocks usage
  const innerBlocksValidation = validateInnerBlocksUsage(code, mode);
  if (innerBlocksValidation.errors.length > 0) {
    testResult.errors.push(...innerBlocksValidation.errors.map(e => `InnerBlocks: ${e}`));
    testResult.passed = false;
  }
  testResult.warnings.push(...innerBlocksValidation.warnings.map(w => `InnerBlocks: ${w}`));

  // 4. Validate indentation
  const indentErrors = validateIndentation(code);
  if (indentErrors.length > 0) {
    testResult.warnings.push(...indentErrors.map(e => `Indentation: ${e}`));
  }

  // 5. Get metrics
  testResult.metrics = getCodeMetrics(code);

  return testResult;
}

/**
 * Test a single block in a specific mode
 */
function testBlock(blockType, mode) {
  printSubHeader(`Testing ${blockType.toUpperCase()} - ${mode} mode`);

  // Load structure mapping
  const structureMapping = loadStructureMapping(blockType);
  if (!structureMapping) {
    results.failed++;
    results.tests.push({
      blockType,
      mode,
      passed: false,
      errors: ['Failed to load structure mapping'],
      warnings: [],
    });
    return;
  }

  printResult('pass', `Loaded structure mapping for ${blockType}`);

  let structureTest = null;

  try {
    // Test generateStructureJsx (renderTitle function)
    // Note: This may be broken if generateRenderTitle is not implemented yet
    console.log();
    console.log(colors.bright + 'Testing generateStructureJsx()...' + colors.reset);

    try {
      const structureCode = generateStructureJsx(structureMapping, mode);
      structureTest = runValidationTests(structureCode, blockType, mode, 'generateStructureJsx');

      // Display results
      if (structureTest.passed) {
        printResult('pass', 'generateStructureJsx() - All validations passed');
      } else {
        printResult('fail', 'generateStructureJsx() - Validation failed');
        structureTest.errors.forEach(err => {
          console.log(colors.red + '  âœ— ' + err + colors.reset);
        });
      }

      if (structureTest.warnings.length > 0) {
        results.warnings += structureTest.warnings.length;
        structureTest.warnings.forEach(warn => {
          console.log(colors.yellow + '  âš  ' + warn + colors.reset);
        });
      }

      console.log();
      displayMetrics(structureTest.metrics);
      displayCodeSample(structureCode, 25);
    } catch (structError) {
      printResult('fail', `generateStructureJsx() - Error: ${structError.message}`);
      console.log(colors.yellow + '  âš  This function may not be fully implemented yet' + colors.reset);
      structureTest = {
        blockType,
        mode,
        functionName: 'generateStructureJsx',
        passed: false,
        errors: [structError.message],
        warnings: ['Function not yet fully implemented'],
        metrics: null,
      };
    }

    // Test generateBlockContent
    console.log(colors.bright + 'Testing generateBlockContent()...' + colors.reset);
    const blockCode = generateBlockContent(structureMapping, mode);
    const blockTest = runValidationTests(blockCode, blockType, mode, 'generateBlockContent');

    // Display results
    if (blockTest.passed) {
      printResult('pass', 'generateBlockContent() - All validations passed');
    } else {
      printResult('fail', 'generateBlockContent() - Validation failed');
      blockTest.errors.forEach(err => {
        console.log(colors.red + '  âœ— ' + err + colors.reset);
      });
    }

    if (blockTest.warnings.length > 0) {
      results.warnings += blockTest.warnings.length;
      blockTest.warnings.forEach(warn => {
        console.log(colors.yellow + '  âš  ' + warn + colors.reset);
      });
    }

    console.log();
    displayMetrics(blockTest.metrics);
    displayCodeSample(blockCode, 25);

    // Update global results
    const structurePassed = structureTest ? structureTest.passed : false;
    const overallPassed = structurePassed && blockTest.passed;

    if (overallPassed) {
      results.passed++;
      printResult('pass', `${blockType} ${mode} mode - PASSED`);
    } else {
      results.failed++;
      printResult('fail', `${blockType} ${mode} mode - FAILED`);
    }

    // Store test results
    results.tests.push({
      blockType,
      mode,
      structureTest,
      blockTest,
      passed: overallPassed,
    });

  } catch (error) {
    printResult('fail', `Error testing ${blockType} ${mode}: ${error.message}`);
    console.error(colors.red + error.stack + colors.reset);
    results.failed++;
    results.tests.push({
      blockType,
      mode,
      passed: false,
      errors: [error.message],
      warnings: [],
    });
  }
}

/**
 * Display summary table
 */
function displaySummaryTable() {
  printHeader('TEST RESULTS SUMMARY');

  console.log(colors.bright + 'â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”' + colors.reset);
  console.log(colors.bright + 'â”‚ Block      â”‚ Mode     â”‚ generateStructure  â”‚ generateBlockContentâ”‚ Result  â”‚' + colors.reset);
  console.log(colors.bright + 'â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤' + colors.reset);

  results.tests.forEach(test => {
    const block = test.blockType.padEnd(10);
    const mode = test.mode.padEnd(8);

    let structStatus, blockStatus, overallStatus;

    if (test.structureTest) {
      structStatus = test.structureTest.passed ?
        colors.green + 'âœ“ PASS' + colors.reset :
        colors.red + 'âœ— FAIL' + colors.reset;
    } else {
      structStatus = colors.red + 'âœ— ERROR' + colors.reset;
    }

    if (test.blockTest) {
      blockStatus = test.blockTest.passed ?
        colors.green + 'âœ“ PASS' + colors.reset :
        colors.red + 'âœ— FAIL' + colors.reset;
    } else {
      blockStatus = colors.red + 'âœ— ERROR' + colors.reset;
    }

    overallStatus = test.passed ?
      colors.green + 'âœ“ PASS' + colors.reset :
      colors.red + 'âœ— FAIL' + colors.reset;

    console.log(`â”‚ ${block} â”‚ ${mode} â”‚ ${structStatus}             â”‚ ${blockStatus}              â”‚ ${overallStatus}   â”‚`);
  });

  console.log(colors.bright + 'â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜' + colors.reset);
  console.log();
}

/**
 * Display final statistics
 */
function displayStatistics() {
  printHeader('FINAL STATISTICS');

  const total = results.passed + results.failed;
  const passRate = total > 0 ? ((results.passed / total) * 100).toFixed(1) : 0;

  console.log(colors.bright + 'Total Tests:    ' + colors.reset + total);
  console.log(colors.green + 'Passed:         ' + colors.reset + results.passed);
  console.log(colors.red + 'Failed:         ' + colors.reset + results.failed);
  console.log(colors.yellow + 'Warnings:       ' + colors.reset + results.warnings);
  console.log(colors.bright + 'Pass Rate:      ' + colors.reset + passRate + '%');
  console.log();

  if (results.failed === 0) {
    console.log(colors.green + colors.bright + 'ðŸŽ‰ ALL TESTS PASSED! ðŸŽ‰' + colors.reset);
  } else {
    console.log(colors.red + colors.bright + 'âŒ SOME TESTS FAILED' + colors.reset);
  }

  console.log();
}

/**
 * Main test execution
 */
function runAllTests() {
  printHeader('BLOCK-AGNOSTIC GENERATOR COMPREHENSIVE TEST SUITE');

  console.log(colors.bright + 'Testing Configuration:' + colors.reset);
  console.log('Blocks:  ' + BLOCKS.join(', '));
  console.log('Modes:   ' + MODES.join(', '));
  console.log('Total:   ' + (BLOCKS.length * MODES.length) + ' test combinations');

  // Run tests for each block and mode
  BLOCKS.forEach(blockType => {
    MODES.forEach(mode => {
      testBlock(blockType, mode);
    });
  });

  // Display summary
  displaySummaryTable();
  displayStatistics();

  // Exit with appropriate code
  process.exit(results.failed > 0 ? 1 : 0);
}

// Run the tests
runAllTests();
