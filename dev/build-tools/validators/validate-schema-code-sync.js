/**
 * Schema ‚Üî Code Sync Validator
 *
 * Ensures all schema attributes and structure elements are properly used in save.js and edit.js
 * Catches missing variables, orphaned attributes, and inconsistencies between editor and frontend.
 *
 * CRITICAL VALIDATIONS:
 * 1. Schema ‚Üí Code: All attributes exist and are accessed in both files
 * 2. Code ‚Üí Schema: All accessed attributes are defined in schema
 * 3. Structure ‚Üí Code: All elements are rendered in generated code
 * 4. Consistency: save.js and edit.js use same attributes
 *
 * @package GuttemberPlus
 * @since 1.0.0
 */

const fs = require('fs');
const path = require('path');

const BLOCKS_DIR = path.join(__dirname, '../../blocks');
const SCHEMAS_DIR = path.join(__dirname, '../../schemas');

/**
 * Extract all attribute accesses from a JavaScript file
 * Looks for: attributes.X, effectiveValues.X, customizations.X
 */
function extractAttributeAccesses(fileContent, fileName) {
	const accesses = new Set();

	// Match: attributes.attributeName
	const attributesRegex = /attributes\.([a-zA-Z0-9_]+)/g;
	let match;
	while ((match = attributesRegex.exec(fileContent)) !== null) {
		accesses.add(match[1]);
	}

	// Match: effectiveValues.attributeName
	const effectiveRegex = /effectiveValues\.([a-zA-Z0-9_]+)/g;
	while ((match = effectiveRegex.exec(fileContent)) !== null) {
		accesses.add(match[1]);
	}

	// Match: customizations.attributeName
	const customRegex = /customizations\.([a-zA-Z0-9_]+)/g;
	while ((match = customRegex.exec(fileContent)) !== null) {
		accesses.add(match[1]);
	}

	// Match: setAttributes({ attributeName: ... })
	const setAttrsRegex = /setAttributes\(\s*\{\s*([a-zA-Z0-9_]+)\s*:/g;
	while ((match = setAttrsRegex.exec(fileContent)) !== null) {
		accesses.add(match[1]);
	}

	// Match: destructured from attributes: const { attr1, attr2 } = attributes
	const destructureRegex = /const\s*\{\s*([^}]+)\s*\}\s*=\s*attributes/g;
	while ((match = destructureRegex.exec(fileContent)) !== null) {
		const attrs = match[1].split(',').map(s => s.trim().split(':')[0].trim());
		attrs.forEach(attr => accesses.add(attr));
	}

	return accesses;
}

/**
 * Extract all elements that should be rendered from structure mapping
 */
function extractRequiredElements(structureMapping) {
	const elements = new Set();

	if (!structureMapping.structure || !structureMapping.structure.elements) {
		return elements;
	}

	// Get all element IDs
	Object.keys(structureMapping.structure.elements).forEach(id => {
		elements.add(id);
	});

	return elements;
}

/**
 * Check if element is rendered in generated code
 */
function isElementRendered(fileContent, elementId) {
	// Look for className containing element ID
	// or data-el attribute
	// or element used in structure
	const patterns = [
		new RegExp(`className.*${elementId}`, 'i'),
		new RegExp(`data-el="${elementId}"`, 'i'),
		new RegExp(`${elementId}[A-Z]`, 'i'), // camelCase references
	];

	return patterns.some(pattern => pattern.test(fileContent));
}

/**
 * Validate a single block
 */
function validateBlock(blockType) {
	const errors = [];
	const warnings = [];

	// Load schema
	const schemaPath = path.join(SCHEMAS_DIR, `${blockType}.json`);
	if (!fs.existsSync(schemaPath)) {
		errors.push(`Schema not found: ${schemaPath}`);
		return { blockType, errors, warnings };
	}

	const schema = JSON.parse(fs.readFileSync(schemaPath, 'utf8'));
	const schemaAttrs = new Set(Object.keys(schema.attributes || {}));

	// Load structure mapping
	const structurePath = path.join(SCHEMAS_DIR, `${blockType}-structure-mapping-autogenerated.json`);
	const hasStructure = fs.existsSync(structurePath);
	let structureMapping = null;
	let requiredElements = new Set();

	if (hasStructure) {
		structureMapping = JSON.parse(fs.readFileSync(structurePath, 'utf8'));
		requiredElements = extractRequiredElements(structureMapping);
	}

	// Load save.js and edit.js
	const savePath = path.join(BLOCKS_DIR, blockType, 'src/save.js');
	const editPath = path.join(BLOCKS_DIR, blockType, 'src/edit.js');

	if (!fs.existsSync(savePath)) {
		errors.push(`save.js not found: ${savePath}`);
		return { blockType, errors, warnings };
	}

	if (!fs.existsSync(editPath)) {
		errors.push(`edit.js not found: ${editPath}`);
		return { blockType, errors, warnings };
	}

	const saveContent = fs.readFileSync(savePath, 'utf8');
	const editContent = fs.readFileSync(editPath, 'utf8');

	// Extract attribute accesses
	const saveAccesses = extractAttributeAccesses(saveContent, 'save.js');
	const editAccesses = extractAttributeAccesses(editContent, 'edit.js');

	// ============================================================
	// VALIDATION 1: Code ‚Üí Schema (all accessed attrs exist)
	// ============================================================

	saveAccesses.forEach(attr => {
		if (!schemaAttrs.has(attr)) {
			errors.push(`save.js accesses "attributes.${attr}" but it's not defined in schema!`);
		}
	});

	editAccesses.forEach(attr => {
		if (!schemaAttrs.has(attr)) {
			errors.push(`edit.js accesses "attributes.${attr}" but it's not defined in schema!`);
		}
	});

	// ============================================================
	// VALIDATION 2: Schema ‚Üí Code (all attrs are used somewhere)
	// ============================================================

	const allAccesses = new Set([...saveAccesses, ...editAccesses]);

	schemaAttrs.forEach(attr => {
		// Skip meta attributes
		if (['accordionId', 'tabsId', 'tocId', 'uniqueId', 'tabsData'].includes(attr)) {
			return;
		}

		if (!allAccesses.has(attr)) {
			warnings.push(`Attribute "${attr}" defined in schema but NEVER used in save.js or edit.js (orphaned attribute)`);
		}
	});

	// ============================================================
	// VALIDATION 3: Consistency (save.js and edit.js use same attrs)
	// ============================================================

	// Attributes that should appear in both files
	const themeable = Object.entries(schema.attributes || {})
		.filter(([_, attr]) => attr.themeable)
		.map(([name, _]) => name);

	themeable.forEach(attr => {
		const inSave = saveAccesses.has(attr);
		const inEdit = editAccesses.has(attr);

		if (inSave && !inEdit) {
			warnings.push(`Attribute "${attr}" used in save.js but NOT in edit.js (inconsistency!)`);
		}

		if (!inSave && inEdit) {
			warnings.push(`Attribute "${attr}" used in edit.js but NOT in save.js (inconsistency!)`);
		}
	});

	// ============================================================
	// VALIDATION 4: Structure ‚Üí Code (all elements rendered)
	// ============================================================

	if (hasStructure) {
		requiredElements.forEach(elementId => {
			const inSave = isElementRendered(saveContent, elementId);
			const inEdit = isElementRendered(editContent, elementId);

			if (!inSave) {
				errors.push(`Element "${elementId}" defined in structure mapping but NOT rendered in save.js!`);
			}

			if (!inEdit && !elementId.includes('panel')) { // panels are save-only
				warnings.push(`Element "${elementId}" defined in structure mapping but NOT rendered in edit.js`);
			}
		});
	}

	// ============================================================
	// VALIDATION 5: Critical attributes must exist in BOTH files
	// ============================================================

	const criticalAttrs = ['currentTheme', 'customizations'];

	criticalAttrs.forEach(attr => {
		if (schemaAttrs.has(attr)) {
			if (!saveAccesses.has(attr)) {
				errors.push(`CRITICAL: "${attr}" missing from save.js!`);
			}
			if (!editAccesses.has(attr)) {
				errors.push(`CRITICAL: "${attr}" missing from edit.js!`);
			}
		}
	});

	return { blockType, errors, warnings };
}

/**
 * Validate all blocks
 */
function validateAll(options = {}) {
	const { warnOnly = false } = options;
	const blocks = ['accordion', 'tabs', 'toc'];
	const results = blocks.map(validateBlock);

	// Print results
	console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
	console.log('‚ïë  Schema ‚Üî Code Sync Validation                            ‚ïë');
	console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');

	let totalErrors = 0;
	let totalWarnings = 0;
	let allPassed = true;

	results.forEach(({ blockType, errors, warnings }) => {
		const hasIssues = errors.length > 0 || warnings.length > 0;

		if (hasIssues) {
			console.log(`\nüì¶ ${blockType.toUpperCase()}`);
			console.log('‚îÄ'.repeat(60));

			if (errors.length > 0) {
				allPassed = false;
				console.log(`\n‚ùå ERRORS (${errors.length}):`);
				errors.forEach((err, i) => {
					console.log(`   ${i + 1}. ${err}`);
				});
				totalErrors += errors.length;
			}

			if (warnings.length > 0) {
				console.log(`\n‚ö†Ô∏è  WARNINGS (${warnings.length}):`);
				warnings.forEach((warn, i) => {
					console.log(`   ${i + 1}. ${warn}`);
				});
				totalWarnings += warnings.length;
			}
		} else {
			console.log(`‚úÖ ${blockType}: All attributes synced correctly`);
		}
	});

	console.log('\n' + '‚ïê'.repeat(60));
	console.log(`üìä SUMMARY: ${totalErrors} errors, ${totalWarnings} warnings`);
	console.log('‚ïê'.repeat(60) + '\n');

	if (warnOnly) {
		console.log('‚ö†Ô∏è  WARN-ONLY MODE: Validation issues will not block build\n');
		return { totalErrors, totalWarnings };
	}

	if (!allPassed) {
		console.log('‚ùå VALIDATION FAILED\n');
		process.exit(1);
	} else if (totalWarnings > 0) {
		console.log('‚ö†Ô∏è  VALIDATION PASSED WITH WARNINGS\n');
	} else {
		console.log('‚úÖ ALL VALIDATIONS PASSED\n');
	}

	return { totalErrors, totalWarnings };
}

// Run if called directly
if (require.main === module) {
	const warnOnly = process.argv.includes('--warn-only');
	validateAll({ warnOnly });
}

module.exports = { validateBlock, validateAll };
