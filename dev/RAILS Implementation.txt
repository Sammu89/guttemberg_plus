# Rails block overview

## What this block is

**Rails** is a “side-reveal panel” layout block built on top of your existing Tabs infrastructure.

Instead of classic tabs (where you click a tab and the content simply swaps in the same fixed area), Rails is a **layout-driven interaction**:

* You have one or two **rails** (vertical stacks of buttons) on the left and/or right.
* Clicking a button activates a **content panel**.
* The content panel can:

  * appear **next to the clicked button** (and expand left/right), **or**
  * appear in a **corner position** (relative to the first/last button on a rail).
* When a panel opens, neighboring buttons can **compress/squeeze** to make room, creating that “hidden/peek” editorial look.

So: **Tabs = content switcher. Rails = content reveal + layout reflow.**

## Why it’s separate from a Tabs block (even if it reuses it)

Even though Rails will reuse the Tabs engine (items + active state + InnerBlocks + accessibility patterns), it should be treated as its own block because:

* the **DOM layout** is fundamentally different (rails + stage/panel)
* the interaction includes **compression/expansion** and optional corner anchoring
* the customization surface is larger and different (offsets, vertical writing mode, panel anchoring)

## Reuse strategy (Tabs as the base)

Rails will reuse the Tabs foundation intentionally:

* **Same schema-type approach as Tabs**

  * Parent block stores global layout/styling attributes.
  * Child “item” blocks store per-tab/button attributes + the content via InnerBlocks.
* **Same CSS variable naming convention used by Tabs**

  * Reuse existing variable prefixes and patterns so:

    * global typography/colors/borders behave consistently
    * theme overrides and your existing style system keep working
  * Add only the minimal new variables needed for:

    * rail compression
    * peek offsets
    * panel anchoring rules
    * writing-mode/tilt direction details

In short: **Rails is a new block built with the Tabs engine and the Tabs styling system**, not a random one-off component.

---

# Customizations you’ll need

## A) Global (whole block)

### Layout mode

Two layout families:

1. **Content next to button**

* Clicking a button reveals the content panel **immediately next to that button**.
* Direction is **per tab** (granular): each tab decides whether it opens **to the left** or **to the right**.
* This is the “expands from the rail into the stage” behaviour.

2. **Content on corner**

* The content panel is anchored to a **corner position**, not tied to the clicked button’s position.
* Corner behaviour:

  * **Right or left** of the **first or last buttons** of a rail (top/bottom anchor).
  * Practically: panel aligns with the top edge (first) or bottom edge (last) of the active rail, and opens on the side (left/right).

### Height & sizing rules

* **Match tallest**

  * Block height becomes the tallest among:

    * the active content panel
    * the rails (buttons), including rotated label group, numeral, icon, padding
* **Min-height derived from button UI**

  * Min-height must account for the maximum vertical footprint of:

    * numeral + label + icon
    * plus padding + inter-element spacing

### Compression behaviour (buttons reshaping)

* Inactive buttons compress when one tab is active.
* Global controls:

  * compression ratio (how much inactive buttons shrink)
  * minimum button width
  * animation duration/easing

---

## B) Per-tab (each button)

### Rail side and expansion direction

Per tab:

* **Rail side**: left rail or right rail
* In “Content next to button” mode: **Expansion direction**

  * open left
  * open right

### Tilt / orientation

You specified:

* Use `writing-mode: vertical-rl`
* Support two directions:

  * vertical orientation equivalent to **-90**
  * vertical orientation equivalent to **+90**

(Implementation may use `writing-mode` plus a controlled transform flip to change direction.)

### Spacing between numeral / label / icon

Per-tab controls:

* spacing numeral ↔ label
* spacing label ↔ icon
* overall padding inside the strip
* optional active vs inactive spacing differences (if desired)

### Hidden / peek offsets (per element)

To achieve the “tucked under / peeking” look, offsets should be independently controllable per element:

* numeral offset (X/Y)
* label offset (X/Y)
* icon offset (X/Y)

### Separate offsets for left vs right rails (clarification)

Offsets that look correct on the **left rail** often need the opposite sign or different values on the **right rail**, because overlap/peeking direction reverses.

So you may want:

* offsets for **left rail** (numeral/label/icon X/Y)
* offsets for **right rail** (numeral/label/icon X/Y)

This avoids users fighting symmetry when mixing left and right buttons.

### Icon placement and ordering

Support multiple compositions:

* icon at the top or bottom (in the vertical flow)
* ordering variants:

  * `(icon + numeral + text)`
  * `(numeral + text + icon)`

### Icon state changes

Per-tab active behaviours:

* icon rotates when active (configurable angle)
* or icon swaps (inactive icon vs active icon)

---

## C) Content panel (per tab content area)

### Gutenberg InnerBlocks (required)

Each panel must support **InnerBlocks** so the content can be any Gutenberg composition:

* text, images, buttons
* groups/columns/covers
* whatever the user builds

### Panel positioning behaviour

* **Content next to button**

  * panel is tied to the active tab and expands left/right based on that tab’s setting
* **Content on corner**

  * panel is anchored to a corner position relative to the active rail’s first/last button

Panel controls (global or per-tab depending on your design):

* panel width/max-width
* padding
* background/border/radius/shadow
* transitions (slide/fade)

---

## D) Architecture notes (high-level)

To keep it maintainable while reusing Tabs:

* **Parent block (Rails container)**

  * stores global attributes (layout mode, height rules, compression defaults, base styling)
  * exposes the overall layout preview in the editor
  * provides shared CSS variables (same naming conventions as Tabs)

* **Child block (Rails item)**

  * stores per-tab/button attributes (side, open direction, writing-mode direction, offsets, spacing, icon settings)
  * contains InnerBlocks for the content panel

* **Shared engine from Tabs**

  * active item state management
  * keyboard navigation and ARIA patterns
  * item registry (add/remove/reorder)
  * shared styling variable patterns (extend, don’t reinvent)

This defines Rails as its own block with a Tabs-compatible core, using the same schema approach and the same CSS variable naming system.
