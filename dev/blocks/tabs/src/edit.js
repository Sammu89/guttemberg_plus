/**
 * Tabs Block - Edit Component
 *
 * Editor interface for tabs block with full theme integration.
 * Uses shared UI components and cascade resolution.
 * Supports horizontal/vertical orientation and responsive fallback.
 *
 * IMPORTANT: Sections marked with AUTO-GENERATED comments are automatically
 * regenerated from the schema on every build. Do not edit code between these markers.
 *
 * To modify styles:
 * 1. Edit the schema: schemas/tabs.json
 * 2. Run: npm run schema:build
 * 3. The code between markers will update automatically
 *
 * @package
 * @since 1.0.0
 */

import { __, sprintf } from '@wordpress/i18n';
import { useBlockProps, InspectorControls, InnerBlocks, RichText } from '@wordpress/block-editor';
import {
	PanelBody,
	ToggleControl,
	SelectControl,
	RangeControl,
	Button,
} from '@wordpress/components';
import { useSelect, useDispatch } from '@wordpress/data';
import { useEffect, useState, useMemo, useRef, useCallback } from '@wordpress/element';

import {
	generateUniqueId,
	getAllDefaults,
	ThemeSelector,
	SchemaPanels,
	CustomizationWarning,
	BreakpointSettings,
	useThemeManager,
	useBlockAlignment,
	useResponsiveDevice,
	renderSingleIcon,
	renderIconWrapper,
} from '@shared';
import * as LucideIcons from 'lucide-react';
import {
	getCssVarName,
	formatCssValue,
	resolveCssProperty,
} from '@shared/config/css-var-mappings-generated';
import { buildEditorCssVars } from '@shared/styles/tabs-css-vars-generated';
import tabsSchema from '../../../schemas/tabs-schema-autogenerated.json';
import { tabsAttributes } from './tabs-attributes';
import '../../../css/tabs_editor.scss';

/**
 * MANUAL DEPENDENCY: Icon rendering uses @shared/utils/icon-renderer.js
 * If you add new icon types (beyond char/image/library) or new icon libraries
 * (beyond dashicons/lucide), update the shared utility manually.
 * See: docs/AUTOGENERATIONSAVEANDEDIT.md for details.
 */

/**
 * Map orientation to ARIA-compliant value
 * ARIA only supports 'horizontal' or 'vertical'
 *
 * @param {string} orientation - The orientation value from attributes
 * @return {string} ARIA-compliant orientation value
 */
function getAriaOrientation( orientation ) {
	if ( orientation === 'vertical-left' || orientation === 'vertical-right' ) {
		return 'vertical';
	}
	return orientation || 'horizontal';
}

const toCamelCase = ( prop ) => prop.replace( /-([a-z])/g, ( _, letter ) => letter.toUpperCase() );

/**
 * Tabs Edit Component
 *
 * @param {Object}   props               Block props
 * @param {Object}   props.attributes    Block attributes
 * @param {Function} props.setAttributes Attribute setter
 * @param {string}   props.clientId      Block client ID
 * @return {JSX.Element} Edit component
 */
export default function Edit( { attributes, setAttributes, clientId } ) {
	// Local state for active tab in editor
	const [ activeTab, setActiveTab ] = useState( attributes.currentTab || 0 );

	// State for action popup balloon (track by clientId so it follows moved tabs)
	const [ popupTabId, setPopupTabId ] = useState( null );
	const [ popupCoords, setPopupCoords ] = useState( { top: 0, left: 0 } );
	const popupRef = useRef( null );
	const tabButtonRefs = useRef( {} );
	const closeTimeoutRef = useRef( null );

	// Get tab-panel children
	const { tabPanels } = useSelect(
		( select ) => {
			const { getBlocks } = select( 'core/block-editor' );
			return {
				tabPanels: getBlocks( clientId ),
			};
		},
		[ clientId ]
	);

	// Update currentTab attribute when activeTab state changes
	useEffect( () => {
		if ( attributes.currentTab !== activeTab ) {
			setAttributes( { currentTab: activeTab } );
		}
	}, [ activeTab, attributes.currentTab, setAttributes ] );

	// Sync tabsData attribute with inner blocks for server-side button rendering
	useEffect( () => {
		const newTabsData = tabPanels.map( ( panel ) => ( {
			tabId: panel.attributes.tabId || `tab-${ panel.clientId }`,
			title: panel.attributes.title || '',
			isDisabled: panel.attributes.isDisabled || false,
		} ) );

		// Only update if data actually changed (avoid infinite loops)
		const currentJSON = JSON.stringify( attributes.tabsData || [] );
		const newJSON = JSON.stringify( newTabsData );

		if ( currentJSON !== newJSON ) {
			setAttributes( { tabsData: newTabsData } );
		}
	}, [ tabPanels, attributes.tabsData, setAttributes ] );

	// Click-outside handler to close popup
	useEffect( () => {
		const handleClickOutside = ( event ) => {
			if (
				popupTabId !== null &&
				popupRef.current &&
				! popupRef.current.contains( event.target )
			) {
				// Check if click was on a gear trigger
				const isGearClick = event.target.closest( '.tab-gear-trigger' );
				if ( ! isGearClick ) {
					setPopupTabId( null );
				}
			}
		};

		document.addEventListener( 'mousedown', handleClickOutside );
		return () => {
			document.removeEventListener( 'mousedown', handleClickOutside );
		};
	}, [ popupTabId ] );

	// Update popup position when tab panels change (e.g., after move)
	useEffect( () => {
		if ( popupTabId !== null ) {
			// Find the current index of the tab with this ID
			const currentIndex = tabPanels.findIndex( ( p ) => p.clientId === popupTabId );
			if ( currentIndex !== -1 ) {
				const buttonElement = tabButtonRefs.current[ currentIndex ];
				if ( buttonElement ) {
					const rect = buttonElement.getBoundingClientRect();
					setPopupCoords( {
						top: rect.bottom + 4,
						left: rect.left + rect.width / 2,
					} );
				}
			} else {
				// Tab was deleted, close popup
				setPopupTabId( null );
			}
		}
	}, [ popupTabId, tabPanels ] );

	/**
	 * Toggle popup for a specific tab using clientId for tracking
	 * @param {string} clientId - Panel client ID
	 * @param {number} index    - Tab index (for button ref lookup)
	 * @param {Event}  event    - Click event
	 */
	const togglePopup = useCallback(
		( clientId, index, event ) => {
			event.stopPropagation();

			if ( popupTabId === clientId ) {
				setPopupTabId( null );
				return;
			}

			// Calculate position based on button location
			const buttonElement = tabButtonRefs.current[ index ];
			if ( buttonElement ) {
				const rect = buttonElement.getBoundingClientRect();
				setPopupCoords( {
					top: rect.bottom + 4,
					left: rect.left + rect.width / 2,
				} );
			}

			setPopupTabId( clientId );
		},
		[ popupTabId ]
	);

	/**
	 * Delayed close - allows popup to survive translation
	 */
	const schedulePopupClose = useCallback( () => {
		// Clear any existing timeout
		if ( closeTimeoutRef.current ) {
			clearTimeout( closeTimeoutRef.current );
		}
		// Schedule close after 1 second delay
		closeTimeoutRef.current = setTimeout( () => {
			setPopupTabId( null );
		}, 1000 );
	}, [] );

	/**
	 * Cancel scheduled close (when mouse re-enters)
	 */
	const cancelPopupClose = useCallback( () => {
		if ( closeTimeoutRef.current ) {
			clearTimeout( closeTimeoutRef.current );
			closeTimeoutRef.current = null;
		}
	}, [] );

	// Cleanup timeout on unmount
	useEffect( () => {
		return () => {
			if ( closeTimeoutRef.current ) {
				clearTimeout( closeTimeoutRef.current );
			}
		};
	}, [] );

	// Use centralized alignment hook
	const blockRef = useBlockAlignment( attributes.tabsHorizontalAlign );
	const responsiveDevice = useResponsiveDevice();

	// Extract schema defaults from tabsAttributes (SINGLE SOURCE OF TRUTH!)
	const schemaDefaults = useMemo( () => {
		const defaults = {};
		Object.keys( tabsAttributes ).forEach( ( key ) => {
			if ( tabsAttributes[ key ].default !== undefined ) {
				defaults[ key ] = tabsAttributes[ key ].default;
			}
		} );
		return defaults;
	}, [] );

	// All defaults come from schema - single source of truth!
	const allDefaults = useMemo( () => {
		const merged = getAllDefaults( schemaDefaults );
		return merged;
	}, [ schemaDefaults ] );

	// Use centralized theme management hook (provides ALL theme logic in one place)
	const {
		themes,
		themesLoaded,
		currentTheme,
		expectedValues,
		isCustomized,
		sessionCache,
		handlers: {
			handleSaveNewTheme,
			handleUpdateTheme,
			handleDeleteTheme,
			handleRenameTheme,
			handleResetCustomizations,
			handleThemeChange,
		},
	} = useThemeManager( {
		blockType: 'tabs',
		schema: tabsSchema,
		attributes,
		setAttributes,
		allDefaults,
	} );

	// SOURCE OF TRUTH: attributes = merged state (what you see in sidebar)
	const effectiveValues = attributes;

	/**
	 * Apply inline styles from effective values
	 */
	/* ========== AUTO-GENERATED-STYLES-START ========== */
// DO NOT EDIT - This code is auto-generated from schema
// AUTO-GENERATED from schemas/tabs.json
// To modify styles, update the schema and run: npm run schema:build

const getInlineStyles = (responsiveDevice = 'global') => {
  // Extract object-type attributes with fallbacks
	const borderColor = effectiveValues.borderColor || {
		    "top": "#dddddd",
		    "right": "#dddddd",
		    "bottom": "#dddddd",
		    "left": "#dddddd"
		};
	const borderStyle = effectiveValues.borderStyle || {
		    "top": "solid",
		    "right": "solid",
		    "bottom": "solid",
		    "left": "solid"
		};
	const borderRadius = effectiveValues.borderRadius || {
		    "topLeft": 0,
		    "topRight": 0,
		    "bottomRight": 0,
		    "bottomLeft": 0
		};
	const tabButtonBorderColor = effectiveValues.tabButtonBorderColor || {
		    "top": "#dddddd",
		    "right": "#dddddd",
		    "bottom": "#dddddd",
		    "left": "#dddddd"
		};
	const tabButtonActiveBorderColor = effectiveValues.tabButtonActiveBorderColor || {
		    "top": "#dddddd",
		    "right": "#dddddd",
		    "bottom": "#dddddd",
		    "left": "#dddddd"
		};
	const tabButtonBorderStyle = effectiveValues.tabButtonBorderStyle || {
		    "top": "solid",
		    "right": "solid",
		    "bottom": "solid",
		    "left": "solid"
		};
	const tabButtonBorderRadius = effectiveValues.tabButtonBorderRadius || {
		    "topLeft": 4,
		    "topRight": 4,
		    "bottomRight": 0,
		    "bottomLeft": 0
		};
	const tabsRowBorderColor = effectiveValues.tabsRowBorderColor || {
		    "top": "#dddddd",
		    "right": "#dddddd",
		    "bottom": "#dddddd",
		    "left": "#dddddd"
		};
	const tabsRowBorderStyle = effectiveValues.tabsRowBorderStyle || {
		    "top": "solid",
		    "right": "solid",
		    "bottom": "solid",
		    "left": "solid"
		};
	const panelBorderColor = effectiveValues.panelBorderColor || {
		    "top": "#dddddd",
		    "right": "#dddddd",
		    "bottom": "#dddddd",
		    "left": "#dddddd"
		};
	const panelBorderStyle = effectiveValues.panelBorderStyle || {
		    "top": "solid",
		    "right": "solid",
		    "bottom": "solid",
		    "left": "solid"
		};
	const panelBorderRadius = effectiveValues.panelBorderRadius || {
		    "topLeft": 4,
		    "topRight": 4,
		    "bottomRight": 4,
		    "bottomLeft": 4
		};
	const iconInactiveSource = effectiveValues.iconInactiveSource || {
		    "kind": "char",
		    "value": "▾"
		};
	const iconActiveSource = effectiveValues.iconActiveSource || {
		    "kind": "char",
		    "value": "▾"
		};

	return {
		container: {
			borderWidth: effectiveValues.borderWidth ?? 0,
			borderRadius: `${borderRadius.topLeft}px ${borderRadius.topRight}px ${borderRadius.bottomRight}px ${borderRadius.bottomLeft}px`,
			boxShadow: (() => { const val = effectiveValues.shadow; if (val === null || val === undefined) return 'none'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return 'none'; })(),
		},
		icon: {
			display: effectiveValues.showIcon ? 'flex' : 'none',
			transform: `rotate(${effectiveValues.iconRotation ?? '180deg'})`,
			color: (() => { const val = effectiveValues.iconInactiveColor; if (val === null || val === undefined) return '#333333'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return '#333333'; })(),
			fontSize: (() => { const val = effectiveValues.iconInactiveSize; if (val === null || val === undefined) return '16px'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object') { const deviceVal = val[responsiveDevice]; if (deviceVal !== undefined) { if (typeof deviceVal === 'string') return deviceVal; if (typeof deviceVal === 'number') return deviceVal; if (typeof deviceVal === 'object' && deviceVal.value !== undefined) { return `${deviceVal.value}${deviceVal.unit || ''}`; } return deviceVal; } if (val.value !== undefined) { return `${val.value}${val.unit || ''}`; } } return '16px'; })(),
			maxWidth: (() => { const val = effectiveValues.iconInactiveMaxSize; if (val === null || val === undefined) return '24px'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object') { const deviceVal = val[responsiveDevice]; if (deviceVal !== undefined) { if (typeof deviceVal === 'string') return deviceVal; if (typeof deviceVal === 'number') return deviceVal; if (typeof deviceVal === 'object' && deviceVal.value !== undefined) { return `${deviceVal.value}${deviceVal.unit || ''}`; } return deviceVal; } if (val.value !== undefined) { return `${val.value}${val.unit || ''}`; } } return '24px'; })(),
			left: (() => { const val = effectiveValues.iconInactiveOffsetX; if (val === null || val === undefined) return '0px'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object') { const deviceVal = val[responsiveDevice]; if (deviceVal !== undefined) { if (typeof deviceVal === 'string') return deviceVal; if (typeof deviceVal === 'number') return deviceVal; if (typeof deviceVal === 'object' && deviceVal.value !== undefined) { return `${deviceVal.value}${deviceVal.unit || ''}`; } return deviceVal; } if (val.value !== undefined) { return `${val.value}${val.unit || ''}`; } } return '0px'; })(),
			top: (() => { const val = effectiveValues.iconInactiveOffsetY; if (val === null || val === undefined) return '0px'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object') { const deviceVal = val[responsiveDevice]; if (deviceVal !== undefined) { if (typeof deviceVal === 'string') return deviceVal; if (typeof deviceVal === 'number') return deviceVal; if (typeof deviceVal === 'object' && deviceVal.value !== undefined) { return `${deviceVal.value}${deviceVal.unit || ''}`; } return deviceVal; } if (val.value !== undefined) { return `${val.value}${val.unit || ''}`; } } return '0px'; })(),
		},
		tabButtonText: {
			fontSize: effectiveValues.tabButtonFontSize ?? '1rem',
			fontWeight: (() => { const val = effectiveValues.tabButtonFontWeight; if (val === null || val === undefined) return '500'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return '500'; })(),
			fontStyle: (() => { const val = effectiveValues.tabButtonFontStyle; if (val === null || val === undefined) return 'normal'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return 'normal'; })(),
			textTransform: (() => { const val = effectiveValues.tabButtonTextTransform; if (val === null || val === undefined) return 'none'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return 'none'; })(),
			textDecoration: (() => { const val = effectiveValues.tabButtonTextDecoration; if (val === null || val === undefined) return 'none'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return 'none'; })(),
		},
		tabList: {
			backgroundColor: (() => { const val = effectiveValues.tabListBackgroundColor; if (val === null || val === undefined) return 'transparent'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return 'transparent'; })(),
			borderWidth: effectiveValues.tabsRowBorderWidth ?? 0,
			gap: effectiveValues.tabsButtonGap ?? '0.5rem',
			justifyContent: (() => { const val = effectiveValues.tabListAlignment; if (val === null || val === undefined) return 'flex-start'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return 'flex-start'; })(),
		},
		panel: {
			backgroundColor: (() => { const val = effectiveValues.panelBackgroundColor; if (val === null || val === undefined) return '#ffffff'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return '#ffffff'; })(),
			borderWidth: effectiveValues.panelBorderWidth ?? 1,
			borderRadius: `${panelBorderRadius.topLeft}px ${panelBorderRadius.topRight}px ${panelBorderRadius.bottomRight}px ${panelBorderRadius.bottomLeft}px`,
		},
	};
};
/* ========== AUTO-GENERATED-STYLES-END ========== */

	const styles = getInlineStyles( responsiveDevice );
	const orientation = attributes.orientation || 'horizontal';
	const navContext = { orientation };
	const isDividerEnabled = attributes.enableTabsListContentBorder !== false;

	// Apply nav bar content border inline styles using schema variants (orientation-aware)
	if ( isDividerEnabled ) {
		const navColorProp = resolveCssProperty( 'tabsListContentBorderColor', 'tabs', navContext );
		if (
			navColorProp &&
			effectiveValues.tabsListContentBorderColor !== undefined &&
			effectiveValues.tabsListContentBorderColor !== null
		) {
			styles.tabList[ toCamelCase( navColorProp ) ] =
				effectiveValues.tabsListContentBorderColor;
		}

		const navWidthProp = resolveCssProperty( 'tabsListContentBorderWidth', 'tabs', navContext );
		if (
			navWidthProp &&
			effectiveValues.tabsListContentBorderWidth !== undefined &&
			effectiveValues.tabsListContentBorderWidth !== null
		) {
			styles.tabList[
				toCamelCase( navWidthProp )
			] = `${ effectiveValues.tabsListContentBorderWidth }px`;
		}

		const navStyleProp = resolveCssProperty( 'tabsListContentBorderStyle', 'tabs', navContext );
		if (
			navStyleProp &&
			effectiveValues.tabsListContentBorderStyle !== undefined &&
			effectiveValues.tabsListContentBorderStyle !== null
		) {
			styles.tabList[ toCamelCase( navStyleProp ) ] =
				effectiveValues.tabsListContentBorderStyle;
		}
	}

	// Add tabButton function to styles object to handle active/disabled states
	styles.tabButton = ( isActive, isDisabled ) => {
		const isActiveContentBorderEnabled = attributes.enableFocusBorder !== false;

		const baseStyles = {
			color: getCssVarValue( 'tabButtonColor' ),
			backgroundColor: getCssVarValue( 'tabButtonBackgroundColor' ),
			borderWidth: getCssVarValue( 'tabButtonBorderWidth' ),
			borderStyle: getCssVarValue( 'tabButtonBorderStyle' ),
			borderColor: getCssVarValue( 'tabButtonBorderColor' ),
			borderRadius: getCssVarValue( 'tabButtonBorderRadius' ),
			boxShadow: getCssVarValue( 'tabButtonShadow' ),
			fontWeight: getCssVarValue( 'tabButtonFontWeight' ),
			fontStyle: getCssVarValue( 'tabButtonFontStyle' ),
		};

		const tabButtonFontSize = getCssVarValue( 'tabButtonFontSize' );
		if ( tabButtonFontSize ) {
			baseStyles.fontSize = tabButtonFontSize;
		}

		if ( isActive ) {
			const activeStyles = {
				...baseStyles,
				color: getCssVarValue( 'tabButtonActiveColor' ),
				backgroundColor: getCssVarValue( 'tabButtonActiveBackgroundColor' ),
				borderColor: getCssVarValue( 'tabButtonActiveBorderColor' ),
				fontWeight: getCssVarValue( 'tabButtonActiveFontWeight' ),
			};

			if ( ! isActiveContentBorderEnabled ) {
				return activeStyles;
			}

			const contentBorderColor = effectiveValues.tabButtonActiveContentBorderColor;
			const contentBorderWidth = effectiveValues.tabButtonActiveContentBorderWidth;
			const contentBorderStyle = effectiveValues.tabButtonActiveContentBorderStyle;

			const propertyContext = { orientation };

			const colorProp = resolveCssProperty(
				'tabButtonActiveContentBorderColor',
				'tabs',
				propertyContext
			);

			const widthProp = resolveCssProperty(
				'tabButtonActiveContentBorderWidth',
				'tabs',
				propertyContext
			);

			const styleProp = resolveCssProperty(
				'tabButtonActiveContentBorderStyle',
				'tabs',
				propertyContext
			);

			const contentEdgeStyles = {};

			if ( colorProp && contentBorderColor !== undefined && contentBorderColor !== null ) {
				contentEdgeStyles[ toCamelCase( colorProp ) ] = contentBorderColor;
			}
			if ( widthProp && contentBorderWidth !== undefined && contentBorderWidth !== null ) {
				contentEdgeStyles[ toCamelCase( widthProp ) ] = `${ contentBorderWidth }px`;
			}
			if ( styleProp && contentBorderStyle !== undefined && contentBorderStyle !== null ) {
				contentEdgeStyles[ toCamelCase( styleProp ) ] = contentBorderStyle;
			}

			return {
				...activeStyles,
				...contentEdgeStyles,
			};
		}

		if ( isDisabled ) {
			return {
				...baseStyles,
				opacity: 0.5,
				cursor: 'not-allowed',
			};
		}

		return baseStyles;
	};

	// Get dispatch for block manipulation
	const { insertBlock, removeBlock, updateBlockAttributes, moveBlockToPosition } =
		useDispatch( 'core/block-editor' );

	/**
	 * Add new tab next to active tab (or at end if no active tab)
	 * @param {number} afterIndex - Index after which to insert the new tab (optional)
	 */
	const addTab = ( afterIndex = null ) => {
		// Max 20 tabs validation
		if ( tabPanels.length >= 20 ) {
			alert( __( 'Maximum of 20 tabs allowed', 'guttemberg-plus' ) );
			return;
		}

		const insertIndex = afterIndex !== null ? afterIndex + 1 : tabPanels.length;
		const newBlock = wp.blocks.createBlock( 'custom/tab-panel', {
			tabId: `tab-${ generateUniqueId() }`,
			title: `Tab ${ tabPanels.length + 1 }`,
			isDisabled: false,
		} );
		insertBlock( newBlock, insertIndex, clientId );
		// Switch to newly created tab
		setActiveTab( insertIndex );
	};

	/**
	 * Remove tab by index with confirmation
	 * @param index
	 */
	const removeTab = ( index ) => {
		// Min 1 tab validation
		if ( tabPanels.length <= 1 ) {
			alert( __( 'You must keep at least 1 tab', 'guttemberg-plus' ) );
			return;
		}

		// Show confirmation warning
		const tabTitle = tabPanels[ index ]?.attributes?.title || `Tab ${ index + 1 }`;
		const confirmed = window.confirm(
			sprintf(
				__(
					'Are you sure you want to delete "%s"? This action cannot be undone.',
					'guttemberg-plus'
				),
				tabTitle
			)
		);

		if ( ! confirmed ) {
			return;
		}

		const blockToRemove = tabPanels[ index ];
		removeBlock( blockToRemove.clientId );

		// Adjust active tab if needed
		if ( activeTab >= tabPanels.length - 1 ) {
			setActiveTab( Math.max( 0, tabPanels.length - 2 ) );
		}
	};

	/**
	 * Update tab property
	 * @param index
	 * @param property
	 * @param value
	 */
	const updateTab = ( index, property, value ) => {
		const block = tabPanels[ index ];
		if ( block ) {
			updateBlockAttributes( block.clientId, { [ property ]: value } );
		}
	};

	/**
	 * Move tab up (to lower index)
	 * @param {number} index - Current index of the tab
	 */
	const moveTabUp = ( index ) => {
		if ( index <= 0 ) {
			return; // Already at the top
		}
		const block = tabPanels[ index ];
		moveBlockToPosition( block.clientId, clientId, clientId, index - 1 );
		// Update active tab to follow the moved block
		if ( activeTab === index ) {
			setActiveTab( index - 1 );
		} else if ( activeTab === index - 1 ) {
			setActiveTab( index );
		}
	};

	/**
	 * Move tab down (to higher index)
	 * @param {number} index - Current index of the tab
	 */
	const moveTabDown = ( index ) => {
		if ( index >= tabPanels.length - 1 ) {
			return; // Already at the bottom
		}
		const block = tabPanels[ index ];
		moveBlockToPosition( block.clientId, clientId, clientId, index + 1 );
		// Update active tab to follow the moved block
		if ( activeTab === index ) {
			setActiveTab( index + 1 );
		} else if ( activeTab === index + 1 ) {
			setActiveTab( index );
		}
	};

	/**
	 * Switch active tab
	 * @param index
	 */
	const switchTab = ( index ) => {
		const panel = tabPanels[ index ];
		if ( panel && ! panel.attributes.isDisabled ) {
			setActiveTab( index );
		}
	};

	/**
	 * Helper: Get responsive value based on current device
	 * @param {*}      value  - Value that might be responsive (object with global/tablet/mobile keys)
	 * @param {string} device - Current device ('global', 'tablet', 'mobile')
	 * @return {*} Resolved value for current device
	 */
	const getResponsiveValue = ( value, device ) => {
		if ( typeof value === 'object' && value !== null && ! Array.isArray( value ) ) {
			// Check if it's a responsive object (has global/tablet/mobile keys)
			if (
				value.global !== undefined ||
				value.tablet !== undefined ||
				value.mobile !== undefined
			) {
				return value[ device ] !== undefined ? value[ device ] : value.global;
			}
		}
		return value;
	};

	/**
	 * Render icon wrapper with both inactive and active states
	 * Uses shared utility function adapted for tabs editor
	 * In edit mode, always shows inactive icon
	 */
	const renderIcon = () => {
		// Use shared renderIconWrapper utility
		// Note: renderIconWrapper handles showIcon check internally
		return renderIconWrapper(
			effectiveValues.iconInactiveSource,
			effectiveValues.iconActiveSource,
			effectiveValues.useDifferentIcons,
			effectiveValues.showIcon,
			LucideIcons
		);
	};

	/**
	 * Build inline CSS variables for explicit customizations (Tier 3)
	 * These override both default CSS variables (Tier 1) and theme values (Tier 2)
	 * Respects feature toggles for optional border settings
	 */
	const getCustomizationStyles = () => {
		const styles = {};

		// Define which attributes are controlled by feature toggles
		const toggledAttributes = {
			// Active content edge border is controlled by enableFocusBorder
			tabButtonActiveContentBorderColor: 'enableFocusBorder',
			tabButtonActiveContentBorderWidth: 'enableFocusBorder',
			tabButtonActiveContentBorderStyle: 'enableFocusBorder',
			// Nav bar border settings are controlled by enableTabsListContentBorder
			tabsListContentBorderColor: 'enableTabsListContentBorder',
			tabsListContentBorderWidth: 'enableTabsListContentBorder',
			tabsListContentBorderStyle: 'enableTabsListContentBorder',
		};

		// Reset CSS variables for disabled toggles to prevent unwanted inheritance
		if ( attributes.enableFocusBorder === false ) {
			styles[ '--tabs-button-active-content-border-color' ] =
				'var(--tabs-button-active-border-color)';
			styles[ '--tabs-button-active-content-border-width' ] =
				'var(--tabs-button-border-width)';
			styles[ '--tabs-button-active-content-border-style' ] =
				'var(--tabs-button-border-style)';
		}

		if ( attributes.enableTabsListContentBorder === false ) {
			// Fall back to the main tab row border settings when the divider is disabled
			styles[ '--tabs-list-divider-border-color' ] =
				attributes.tabsRowBorderColor ?? allDefaults.tabsRowBorderColor ?? '#dddddd';
			styles[ '--tabs-list-divider-border-width' ] = formatCssValue(
				'tabsRowBorderWidth',
				attributes.tabsRowBorderWidth ?? allDefaults.tabsRowBorderWidth ?? 0,
				'tabs'
			);
			styles[ '--tabs-list-divider-border-style' ] =
				attributes.tabsRowBorderStyle ?? allDefaults.tabsRowBorderStyle ?? 'solid';
		}

		// Process each attribute using schema-generated mappings
		Object.entries( attributes ).forEach( ( [ attrName, value ] ) => {
			if ( value === null || value === undefined ) {
				return;
			}

			// Skip toggle attributes themselves
			if ( attrName === 'enableFocusBorder' || attrName === 'enableTabsListContentBorder' ) {
				return;
			}

			// Check if this attribute is controlled by a toggle and if that toggle is disabled
			const controllingToggle = toggledAttributes[ attrName ];
			if ( controllingToggle && ! attributes[ controllingToggle ] ) {
				// Toggle is disabled, skip this attribute's CSS variable
				return;
			}

			// Get CSS variable name from generated mappings
			const cssVar = getCssVarName( attrName, 'tabs' );
			if ( ! cssVar ) {
				return; // Attribute not mapped to a CSS variable
			}

			// Format value with proper unit from generated mappings
			const formattedValue = formatCssValue( attrName, value, 'tabs' );
			if ( formattedValue !== null ) {
				styles[ cssVar ] = formattedValue;
			}
		} );

		return styles;
	};

	const getCssVarValue = ( attrName ) => {
		const cssVar = getCssVarName( attrName, 'tabs' );
		return cssVar ? `var(${ cssVar })` : undefined;
	};

	const customizationStyles = getCustomizationStyles();
	const editorCSSVars = buildEditorCssVars( effectiveValues );

	/**
	 * Format dimension value (width/height) with proper unit
	 * Uses responsiveDevice to extract device-specific values
	 *
	 * Data structure:
	 * - Base (desktop): stored at root level as value.value or string
	 * - Tablet/Mobile: stored under value.tablet / value.mobile keys
	 * @param value
	 * @param defaultUnit
	 */
	const formatDimensionValue = ( value, defaultUnit = '%' ) => {
		if ( value === null || value === undefined ) {
			return `100${ defaultUnit }`;
		}
		// Handle responsive structure - extract value for current device
		if (
			typeof value === 'object' &&
			( value.tablet !== undefined || value.mobile !== undefined )
		) {
			// Global uses base value (value.value), tablet/mobile check their key first
			const deviceValue =
				responsiveDevice === 'global'
					? value.value
					: value[ responsiveDevice ] ?? value.value;
			return formatDimensionValue( deviceValue, defaultUnit );
		}
		// Handle { value, unit } object format
		if ( typeof value === 'object' && value.value !== undefined ) {
			return `${ value.value }${ value.unit || defaultUnit }`;
		}
		// Handle plain number
		if ( typeof value === 'number' ) {
			return `${ value }${ defaultUnit }`;
		}
		// Handle string (already formatted)
		return String( value );
	};

	// Build root styles including width
	const rootStyles = {
		width: formatDimensionValue( effectiveValues.tabsWidth, '%' ),
		...editorCSSVars, // All CSS variables including decomposed
		...customizationStyles, // Tier 3 customizations
	};

	const blockProps = useBlockProps( {
		className: 'gutplus-tabs',
		style: rootStyles,
		ref: blockRef,
		'data-orientation': attributes.orientation || 'horizontal',
		'data-stretch-buttons': attributes.stretchButtonsToRow || false,
		'data-button-text-align': effectiveValues.tabButtonTextAlign || 'center',
		'data-hide-inactive-edge': 'true',
		'data-gutplus-device': responsiveDevice,
	} );

	/* ========== AUTO-GENERATED-BLOCK-CONTENT-START ========== */
// DO NOT EDIT - This code is auto-generated from schema

	const blockContentJSX = (
		<div { ...blockProps }>
			<div className="tabs-list" role="tablist">
				{ renderTabButtons() }
			</div>

			<div className="tabs-panels">
				<InnerBlocks
					allowedBlocks={ [ 'gutplus/tab-panel' ] }
					templateLock={ false }
					placeholder={ __(
						'Add tab panels…',
						'guttemberg-plus'
					) }
				/>
			</div>
		</div>
	);
/* ========== AUTO-GENERATED-BLOCK-CONTENT-END ========== */

	return (
		<>
			{ ' ' }
			<InspectorControls>
				<div className="tabs-settings-panel">
					<ThemeSelector
						blockType="tabs"
						currentTheme={ attributes.currentTheme }
						isCustomized={ isCustomized }
						attributes={ attributes }
						effectiveValues={ effectiveValues }
						themes={ themes }
						themesLoaded={ themesLoaded }
						sessionCache={ sessionCache }
						onThemeChange={ handleThemeChange }
						onSaveNew={ handleSaveNewTheme }
						onUpdate={ handleUpdateTheme }
						onDelete={ handleDeleteTheme }
						onRename={ handleRenameTheme }
						onReset={ handleResetCustomizations }
					/>
				</div>

				<PanelBody
					title={ __( 'Tabs Management', 'guttemberg-plus' ) }
					initialOpen={ false }
				>
					<div className="tabs-management">
						{ tabPanels.map( ( panel, index ) => (
							<div key={ panel.clientId } className="tab-panel-item">
								<div className="tab-panel-header">
									<strong>
										{ __( 'Tab', 'guttemberg-plus' ) } { index + 1 }
										{ panel.attributes.title &&
											`: ${ panel.attributes.title }` }
									</strong>
									<div>
										<ToggleControl
											label={ __( 'Disabled', 'guttemberg-plus' ) }
											checked={ panel.attributes.isDisabled || false }
											onChange={ ( value ) =>
												updateTab( index, 'isDisabled', value )
											}
										/>
										{ tabPanels.length > 1 && (
											<Button
												isDestructive
												isSmall
												onClick={ () => removeTab( index ) }
											>
												{ __( 'Remove', 'guttemberg-plus' ) }
											</Button>
										) }
									</div>
								</div>
							</div>
						) ) }
						<Button isPrimary onClick={ addTab }>
							{ __( '+ Add Tab', 'guttemberg-plus' ) }
						</Button>
					</div>
				</PanelBody>

				{ /* Auto-generated panels from schema */ }
				<SchemaPanels
					schema={ tabsSchema }
					attributes={ attributes }
					setAttributes={ setAttributes }
					effectiveValues={ effectiveValues }
					theme={ themes[ attributes.currentTheme ]?.values }
					cssDefaults={ allDefaults }
				/>

				{ /* Global breakpoint settings */ }
				<BreakpointSettings />

				{ isCustomized && (
					<div className="customization-warning-wrapper">
						<CustomizationWarning
							currentTheme={ attributes.currentTheme }
							themes={ themes }
						/>
					</div>
				) }
			</InspectorControls>
			<div { ...blockProps }>
				{ ! themesLoaded && (
					<div className="tabs-loading">
						<p>{ __( 'Loading themes…', 'guttemberg-plus' ) }</p>
					</div>
				) }

				{ themesLoaded && blockContentJSX }
			</div>
		</>
	);
}
