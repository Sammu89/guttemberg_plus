/**
 * TOC Block - Edit Component
 *
 * Handles block rendering in the WordPress editor with:
 * - Automatic heading detection from post content
 * - Theme management integration
 * - Filter settings UI
 * - Live preview of TOC structure
 *
 * IMPORTANT: Sections marked with AUTO-GENERATED comments are automatically
 * regenerated from the schema on every build. Do not edit code between these markers.
 *
 * To modify styles:
 * 1. Edit the schema: schemas/toc.json
 * 2. Run: npm run schema:build
 * 3. The code between markers will update automatically
 *
 * @package
 * @since 1.0.0
 */

import { useEffect, useState, useMemo, useCallback } from '@wordpress/element';
import {
	InspectorControls,
	useBlockProps,
	store as blockEditorStore,
	RichText,
} from '@wordpress/block-editor';
import { SelectControl, Button } from '@wordpress/components';
import { __ } from '@wordpress/i18n';
import { useSelect } from '@wordpress/data';
import {
	generateUniqueId,
	getAllDefaults,
	ThemeSelector,
	SchemaPanels,
	CustomizationWarning,
	BreakpointSettings,
	useThemeManager,
	useBlockAlignment,
	useResponsiveDevice,
} from '@shared';
import * as LucideIcons from 'lucide-react';
import tocSchema from '../../../schemas/toc-schema-autogenerated.json';
import { tocAttributes } from './toc-attributes';
import { formatCssValue, getCssVarName } from '@shared/config/css-var-mappings-generated';
import { buildEditorCssVars } from '@shared/styles/toc-css-vars-generated';
import '../../../css/toc_editor.scss';

/**
 * Edit Component
 * @param root0
 * @param root0.attributes
 * @param root0.setAttributes
 * @param root0.clientId
 */
export default function Edit( { attributes, setAttributes, clientId } ) {
	const {
		tocId,
		showTitle,
		titleText,
		tocItems = [],
		deletedHeadingIds = [],
		enableHierarchicalIndent,
		levelIndent,
	} = attributes;
	const [ headings, setHeadings ] = useState( [] );
	const [ isScanning, setIsScanning ] = useState( false );
	const [ hasScanned, setHasScanned ] = useState( false );
	const safeTocId = tocId || clientId || 'toc';

	// Use centralized alignment hook
	const blockRef = useBlockAlignment( attributes.tocHorizontalAlign );
	const responsiveDevice = useResponsiveDevice();

	// Get all blocks from the editor using Gutenberg's data API
	const allBlocks = useSelect( ( select ) => select( blockEditorStore ).getBlocks(), [] );

	// Generate unique ID on mount
	useEffect( () => {
		if ( ! tocId ) {
			setAttributes( { tocId: generateUniqueId() } );
		}
	}, [ tocId, setAttributes ] );

	// Mark as scanned if tocItems exist
	useEffect( () => {
		if ( tocItems.length > 0 && ! hasScanned ) {
			setHasScanned( true );
		}
	}, [ tocItems, hasScanned ] );

	/**
	 * Strip HTML tags from text
	 * Icons are stored separately in accordion/tabs blocks (iconTypeClosed, iconTypeOpen attributes)
	 * and rendered in separate elements with class "accordion-icon" or similar.
	 * The title text itself doesn't contain icons, just potential HTML formatting.
	 * @param text
	 */
	const stripHtml = ( text ) => {
		if ( ! text ) {
			return '';
		}
		return (
			text
				// Remove HTML tags (formatting like <strong>, <em>, etc.)
				.replace( /<[^>]*>/g, '' )
				// Normalize whitespace
				.replace( /\s+/g, ' ' )
				.trim()
		);
	};

	/**
	 * Recursively extract headings from blocks
	 * Handles core/heading blocks, accordions, tabs, and nested blocks
	 * Respects includeH1-H6, includeAccordions and includeTabs filter settings
	 */
	const extractHeadingsFromBlocks = useCallback( ( blocks, currentClientId, options = {} ) => {
		const {
			includeAccordions = true,
			includeTabs = true,
			includeH1 = false,
			includeH2 = true,
			includeH3 = true,
			includeH4 = true,
			includeH5 = true,
			includeH6 = true,
		} = options;
		const detectedHeadings = [];

		// Helper to check if a heading level should be included
		const shouldIncludeLevel = ( level ) => {
			const levelMap = {
				1: includeH1,
				2: includeH2,
				3: includeH3,
				4: includeH4,
				5: includeH5,
				6: includeH6,
			};
			return levelMap[ level ] !== false;
		};

		const processBlock = ( block ) => {
			// Skip this TOC block
			if ( block.clientId === currentClientId ) {
				return;
			}

			// Skip other TOC blocks
			if ( block.name === 'custom/toc' ) {
				return;
			}

			// Handle core/heading blocks
			if ( block.name === 'core/heading' ) {
				const level = block.attributes.level || 2;
				const content = block.attributes.content || '';
				const text = stripHtml( content );

				// Check if this heading level should be included
				if ( text && shouldIncludeLevel( level ) ) {
					detectedHeadings.push( {
						level,
						text,
						id: block.attributes.anchor || '',
						classes: [],
						blockType: 'heading',
						sourceClientId: block.clientId,
					} );
				}
			}

			// Handle accordion blocks with headingLevel set (if enabled)
			// Note: Icons are stored in iconTypeClosed/iconTypeOpen attributes, not in title
			if ( includeAccordions && block.name === 'custom/accordion' ) {
				const headingLevel = block.attributes.headingLevel;
				if ( headingLevel && headingLevel !== 'none' ) {
					const level = parseInt( headingLevel.charAt( 1 ), 10 );
					const title = block.attributes.title || '';
					const text = stripHtml( title );

					// Check if this heading level should be included
					if ( text && shouldIncludeLevel( level ) ) {
						detectedHeadings.push( {
							level,
							text,
							id: block.attributes.accordionId || '',
							classes: [ 'accordion-heading' ],
							blockType: 'accordion',
							sourceClientId: block.clientId,
						} );
					}
				}
			}

			// Handle tabs blocks with headingLevel set (if enabled)
			// Note: Icons are stored in iconTypeClosed/iconTypeOpen attributes, not in tab.title
			if ( includeTabs && block.name === 'custom/tabs' ) {
				const headingLevel = block.attributes.headingLevel;
				if ( headingLevel && headingLevel !== 'none' ) {
					const level = parseInt( headingLevel.charAt( 1 ), 10 );
					const tabsData = block.attributes.tabsData || [];

					tabsData.forEach( ( tab ) => {
						// Skip disabled tabs
						if ( tab.isDisabled ) {
							return;
						}

						const text = stripHtml( tab.title );
						// Check if this heading level should be included
						if ( text && shouldIncludeLevel( level ) ) {
							detectedHeadings.push( {
								level,
								text,
								id: tab.tabId || '',
								classes: [ 'tab-heading' ],
								blockType: 'tabs',
								sourceClientId: block.clientId,
							} );
						}
					} );
				}
			}

			// Recursively process inner blocks
			if ( block.innerBlocks && block.innerBlocks.length > 0 ) {
				block.innerBlocks.forEach( processBlock );
			}
		};

		blocks.forEach( processBlock );
		return detectedHeadings;
	}, [] );

	/**
	 * Scan for headings in post content
	 * Called manually when user clicks the "Scan for headings" button
	 * Respects includeH1-H6, includeAccordions and includeTabs attributes
	 */
	const scanForHeadings = () => {
		setIsScanning( true );

		// Small delay to show scanning state
		setTimeout( () => {
			const detectedHeadings = extractHeadingsFromBlocks( allBlocks, clientId, {
				includeAccordions: attributes.includeAccordions !== false,
				includeTabs: attributes.includeTabs !== false,
				includeH1: attributes.includeH1 !== false,
				includeH2: attributes.includeH2 !== false,
				includeH3: attributes.includeH3 !== false,
				includeH4: attributes.includeH4 !== false,
				includeH5: attributes.includeH5 !== false,
				includeH6: attributes.includeH6 !== false,
			} );
			const filtered = filterHeadings( detectedHeadings, attributes );
			setHeadings( filtered );

			// Merge with existing curated items
			const mergedItems = mergeHeadingsWithExisting(
				filtered,
				tocItems,
				deletedHeadingIds,
				safeTocId
			);
			setAttributes( { tocItems: mergedItems } );
			setIsScanning( false );
			setHasScanned( true );
		}, 200 );
	};

	const handleDeleteItem = useCallback(
		( anchor ) => {
			if ( ! anchor ) {
				return;
			}

			const updatedItems = tocItems.filter( ( item ) => getItemAnchor( item ) !== anchor );
			const updatedDeleted = Array.from( new Set( [ ...deletedHeadingIds, anchor ] ) );

			setAttributes( {
				tocItems: updatedItems,
				deletedHeadingIds: updatedDeleted,
			} );
		},
		[ tocItems, deletedHeadingIds, setAttributes ]
	);

	const handleResetDeleted = useCallback( () => {
		setAttributes( { deletedHeadingIds: [] } );
	}, [ setAttributes ] );

	/**
	 * Move TOC item up (to lower index)
	 * @param {number} index - Current index of the item
	 */
	const handleMoveItemUp = useCallback(
		( index ) => {
			if ( index <= 0 || tocItems.length === 0 ) {
				return;
			}

			const newItems = [ ...tocItems ];
			const temp = newItems[ index - 1 ];
			newItems[ index - 1 ] = newItems[ index ];
			newItems[ index ] = temp;

			setAttributes( { tocItems: newItems } );
		},
		[ tocItems, setAttributes ]
	);

	/**
	 * Move TOC item down (to higher index)
	 * @param {number} index - Current index of the item
	 */
	const handleMoveItemDown = useCallback(
		( index ) => {
			if ( index >= tocItems.length - 1 || tocItems.length === 0 ) {
				return;
			}

			const newItems = [ ...tocItems ];
			const temp = newItems[ index + 1 ];
			newItems[ index + 1 ] = newItems[ index ];
			newItems[ index ] = temp;

			setAttributes( { tocItems: newItems } );
		},
		[ tocItems, setAttributes ]
	);

	/**
	 * Toggle item visibility (hidden/visible)
	 * @param {string} anchor - Anchor of the item to toggle
	 */
	const handleToggleHidden = useCallback(
		( anchor ) => {
			if ( ! anchor ) {
				return;
			}

			const updatedItems = tocItems.map( ( item ) => {
				if ( getItemAnchor( item ) === anchor ) {
					return { ...item, hidden: ! item.hidden };
				}
				return item;
			} );

			setAttributes( { tocItems: updatedItems } );
		},
		[ tocItems, setAttributes ]
	);

	/**
	 * Update item text
	 * @param {string} anchor  - Anchor of the item to update
	 * @param {string} newText - New text value
	 */
	const handleUpdateItemText = useCallback(
		( anchor, newText ) => {
			if ( ! anchor ) {
				return;
			}

			const updatedItems = tocItems.map( ( item ) => {
				if ( getItemAnchor( item ) === anchor ) {
					return { ...item, text: newText };
				}
				return item;
			} );

			setAttributes( { tocItems: updatedItems } );
		},
		[ tocItems, setAttributes ]
	);

	/**
	 * Calculate indent level for editor preview
	 * @param {number} index - Index of the item in tocItems array
	 */
	const calculateEditorIndent = useCallback(
		( index ) => {
			if ( ! enableHierarchicalIndent ) {
				// Traditional: based on absolute level
				const item = tocItems[ index ];
				return item.level ? item.level - 1 : 0;
			}

			// Hierarchical: based on position in list
			const hierarchyStack = [];
			let previousLevel = null;

			for ( let i = 0; i <= index; i++ ) {
				const currentItem = tocItems[ i ];
				const currentLevel = currentItem.level;

				if ( previousLevel === null ) {
					hierarchyStack.push( currentLevel );
				} else if ( currentLevel > previousLevel ) {
					hierarchyStack.push( currentLevel );
				} else if ( currentLevel === previousLevel ) {
					// Same level - no change
				} else {
					while (
						hierarchyStack.length > 0 &&
						hierarchyStack[ hierarchyStack.length - 1 ] >= currentLevel
					) {
						hierarchyStack.pop();
					}
					hierarchyStack.push( currentLevel );
				}

				previousLevel = currentLevel;

				if ( i === index ) {
					return Math.max( 0, hierarchyStack.length - 1 );
				}
			}

			return 0;
		},
		[ tocItems, enableHierarchicalIndent ]
	);

	// Extract schema defaults from tocAttributes (SINGLE SOURCE OF TRUTH!)
	const schemaDefaults = useMemo( () => {
		const defaults = {};
		Object.keys( tocAttributes ).forEach( ( key ) => {
			if ( tocAttributes[ key ].default !== undefined ) {
				defaults[ key ] = tocAttributes[ key ].default;
			}
		} );
		return defaults;
	}, [] );

	// All defaults come from schema - single source of truth!
	const allDefaults = useMemo( () => {
		const merged = getAllDefaults( schemaDefaults );
		return merged;
	}, [ schemaDefaults ] );

	// Use centralized theme management hook (provides ALL theme logic in one place)
	const {
		themes,
		themesLoaded,
		currentTheme,
		expectedValues,
		isCustomized,
		sessionCache,
		handlers: {
			handleSaveNewTheme,
			handleUpdateTheme,
			handleDeleteTheme,
			handleRenameTheme,
			handleResetCustomizations,
			handleThemeChange,
		},
	} = useThemeManager( {
		blockType: 'toc',
		schema: tocSchema,
		attributes,
		setAttributes,
		allDefaults,
	} );

	// SOURCE OF TRUTH: attributes = merged state (what you see in sidebar)
	const effectiveValues = attributes;

	/**
	 * Apply inline styles from effective values
	 */
	/* ========== AUTO-GENERATED-STYLES-START ========== */
// DO NOT EDIT - This code is auto-generated from schema
// AUTO-GENERATED from schemas/toc.json
// To modify styles, update the schema and run: npm run schema:build

const getInlineStyles = (responsiveDevice = 'global') => {
  // Extract object-type attributes with fallbacks
	const blockBorderColor = effectiveValues.blockBorderColor || {
		    "top": "#dddddd",
		    "right": "#dddddd",
		    "bottom": "#dddddd",
		    "left": "#dddddd"
		};
	const iconInactiveSource = effectiveValues.iconInactiveSource || {
		    "kind": "char",
		    "value": "▾"
		};
	const iconActiveSource = effectiveValues.iconActiveSource || {
		    "kind": "char",
		    "value": "▾"
		};
	const blockBorderStyle = effectiveValues.blockBorderStyle || {
		    "top": "solid",
		    "right": "solid",
		    "bottom": "solid",
		    "left": "solid"
		};
	const blockBorderRadius = effectiveValues.blockBorderRadius || {
		    "topLeft": 4,
		    "topRight": 4,
		    "bottomRight": 4,
		    "bottomLeft": 4,
		    "unit": "px"
		};

	return {
		container: {
			backgroundColor: (() => { const val = effectiveValues.wrapperBackgroundColor; if (val === null || val === undefined) return '#ffffff'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return '#ffffff'; })(),
			borderWidth: (() => { const val = effectiveValues.blockBorderWidth; if (val === null || val === undefined) return '1'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return '1'; })(),
			borderRadius: `${blockBorderRadius.topLeft}px ${blockBorderRadius.topRight}px ${blockBorderRadius.bottomRight}px ${blockBorderRadius.bottomLeft}px`,
			boxShadow: (() => { const val = effectiveValues.blockShadow; if (val === null || val === undefined) return 'none'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return 'none'; })(),
			top: (() => { const val = effectiveValues.positionTop; if (val === null || val === undefined) return '6.25rem'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return '6.25rem'; })(),
			zIndex: effectiveValues.zIndex ?? 100,
		},
		title: {
			fontSize: (() => { const val = effectiveValues.titleFontSize; if (val === null || val === undefined) return '1.25rem'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return '1.25rem'; })(),
			fontWeight: (() => { const val = effectiveValues.titleFontWeight; if (val === null || val === undefined) return '700'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return '700'; })(),
			fontStyle: (() => { const val = effectiveValues.titleFontStyle; if (val === null || val === undefined) return 'normal'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return 'normal'; })(),
			textTransform: (() => { const val = effectiveValues.titleTextTransform; if (val === null || val === undefined) return 'none'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return 'none'; })(),
			textDecoration: (() => { const val = effectiveValues.titleTextDecoration; if (val === null || val === undefined) return 'none'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return 'none'; })(),
			textAlign: (() => { const val = effectiveValues.titleAlignment; if (val === null || val === undefined) return 'left'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return 'left'; })(),
		},
		content: {
			padding: (() => { const val = effectiveValues.wrapperPadding; if (val === null || val === undefined) return '1.25rem'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return '1.25rem'; })(),
		},
		icon: {
			display: effectiveValues.showIcon ? 'flex' : 'none',
			transform: `rotate(${effectiveValues.iconRotation ?? '180deg'})`,
			color: (() => { const val = effectiveValues.iconInactiveColor; if (val === null || val === undefined) return '#333333'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return '#333333'; })(),
			fontSize: (() => { const val = effectiveValues.iconInactiveSize; if (val === null || val === undefined) return '16px'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object') { const deviceVal = val[responsiveDevice]; if (deviceVal !== undefined) { if (typeof deviceVal === 'string') return deviceVal; if (typeof deviceVal === 'number') return deviceVal; if (typeof deviceVal === 'object' && deviceVal.value !== undefined) { return `${deviceVal.value}${deviceVal.unit || ''}`; } return deviceVal; } if (val.value !== undefined) { return `${val.value}${val.unit || ''}`; } } return '16px'; })(),
			maxWidth: (() => { const val = effectiveValues.iconInactiveMaxSize; if (val === null || val === undefined) return '24px'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object') { const deviceVal = val[responsiveDevice]; if (deviceVal !== undefined) { if (typeof deviceVal === 'string') return deviceVal; if (typeof deviceVal === 'number') return deviceVal; if (typeof deviceVal === 'object' && deviceVal.value !== undefined) { return `${deviceVal.value}${deviceVal.unit || ''}`; } return deviceVal; } if (val.value !== undefined) { return `${val.value}${val.unit || ''}`; } } return '24px'; })(),
			left: (() => { const val = effectiveValues.iconInactiveOffsetX; if (val === null || val === undefined) return '0px'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object') { const deviceVal = val[responsiveDevice]; if (deviceVal !== undefined) { if (typeof deviceVal === 'string') return deviceVal; if (typeof deviceVal === 'number') return deviceVal; if (typeof deviceVal === 'object' && deviceVal.value !== undefined) { return `${deviceVal.value}${deviceVal.unit || ''}`; } return deviceVal; } if (val.value !== undefined) { return `${val.value}${val.unit || ''}`; } } return '0px'; })(),
			top: (() => { const val = effectiveValues.iconInactiveOffsetY; if (val === null || val === undefined) return '0px'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object') { const deviceVal = val[responsiveDevice]; if (deviceVal !== undefined) { if (typeof deviceVal === 'string') return deviceVal; if (typeof deviceVal === 'number') return deviceVal; if (typeof deviceVal === 'object' && deviceVal.value !== undefined) { return `${deviceVal.value}${deviceVal.unit || ''}`; } return deviceVal; } if (val.value !== undefined) { return `${val.value}${val.unit || ''}`; } } return '0px'; })(),
		},
	};
};
/* ========== AUTO-GENERATED-STYLES-END ========== */

	const styles = getInlineStyles( responsiveDevice );

	// Filter headings based on settings
	const filteredHeadings = filterHeadings( headings, attributes );
	const curatedHeadings = ( tocItems || [] ).map( ( item, index ) => ( {
		id: getItemAnchor( item ) || `heading-${ index }`,
		anchor: getItemAnchor( item ),
		text: item.text || '',
		level: item.level || 2,
	} ) );
	const displayHeadings = curatedHeadings.length > 0 ? curatedHeadings : filteredHeadings;

	// Build inline styles - apply width from attributes
	// IMPORTANT: Force static positioning in editor to prevent overflow issues
	// Position type (sticky/fixed) should only apply on frontend
	const editorCSSVars = buildEditorCssVars( effectiveValues );

	/**
	 * Format dimension value (width/height) with proper unit
	 * Uses responsiveDevice to extract device-specific values
	 *
	 * Data structure:
	 * - Base (desktop): stored at root level as value.value or string
	 * - Tablet/Mobile: stored under value.tablet / value.mobile keys
	 * @param value
	 * @param defaultUnit
	 */
	const formatDimensionValue = ( value, defaultUnit = '%' ) => {
		if ( value === null || value === undefined ) {
			return `100${ defaultUnit }`;
		}
		// Handle responsive structure - extract value for current device
		if (
			typeof value === 'object' &&
			( value.tablet !== undefined || value.mobile !== undefined )
		) {
			// Global uses base value (value.value), tablet/mobile check their key first
			const deviceValue =
				responsiveDevice === 'global'
					? value.value
					: value[ responsiveDevice ] ?? value.value;
			return formatDimensionValue( deviceValue, defaultUnit );
		}
		// Handle { value, unit } object format
		if ( typeof value === 'object' && value.value !== undefined ) {
			return `${ value.value }${ value.unit || defaultUnit }`;
		}
		// Handle plain number
		if ( typeof value === 'number' ) {
			return `${ value }${ defaultUnit }`;
		}
		// Handle string (already formatted)
		return String( value );
	};

	const rootStyles = {
		width: formatDimensionValue( effectiveValues.tocWidth, '%' ),
		...editorCSSVars, // All CSS variables including decomposed
		// Force normal positioning in editor - override any CSS classes
		position: 'static',
		top: 'auto',
		left: 'auto',
		right: 'auto',
		zIndex: 'auto',
	};

	// Block props
	const blockProps = useBlockProps( {
		className: 'gutplus-toc',
		style: rootStyles,
		ref: blockRef,
		'data-gutplus-device': responsiveDevice,
	} );
	const titleTextStyle = {
		color: styles.title.color,
		fontSize: styles.title.fontSize,
		fontWeight: styles.title.fontWeight,
		fontStyle: styles.title.fontStyle,
		textTransform: styles.title.textTransform,
		textDecoration: styles.title.textDecoration,
	};
	const buttonId = `toc-toggle-${ safeTocId }`;
	const contentId = `toc-content-${ safeTocId }`;

	/**
	 * Helper: Get responsive value based on current device
	 * @param {*}      value  - Value that might be responsive (object with global/tablet/mobile keys)
	 * @param {string} device - Current device ('global', 'tablet', 'mobile')
	 * @return {*} Resolved value for current device
	 */
	const getResponsiveValue = ( value, device ) => {
		if ( typeof value === 'object' && value !== null && ! Array.isArray( value ) ) {
			// Check if it's a responsive object (has global/tablet/mobile keys)
			if (
				value.global !== undefined ||
				value.tablet !== undefined ||
				value.mobile !== undefined
			) {
				return value[ device ] !== undefined ? value[ device ] : value.global;
			}
		}
		return value;
	};

	/**
	 * Render library icon (Dashicons or Lucide)
	 * @param {string} iconValue - Format: "library:iconName" (e.g., "dashicons:arrow-down")
	 * @return {JSX.Element|null} Icon element
	 */
	const renderLibraryIcon = ( iconValue ) => {
		if ( ! iconValue || typeof iconValue !== 'string' ) {
			return null;
		}

		const [ library, iconName ] = iconValue.split( ':' );

		if ( library === 'dashicons' && iconName ) {
			// Use native dashicons span to match frontend rendering
			return <span className={ `dashicons dashicons-${ iconName }` } />;
		}

		if ( library === 'lucide' && iconName ) {
			const LucideIcon = LucideIcons[ iconName ];
			return LucideIcon ? <LucideIcon size="1em" /> : null;
		}

		return null;
	};

	/**
	 * Render icon based on new icon system
	 * Uses iconInactiveSource and iconActiveSource with structured {kind, value} format
	 * Applies offsets to wrapper, rotation/color/size to icon element
	 *
	 * @return {JSX.Element|null} Icon element with wrapper
	 */
	const renderIcon = () => {
		const iconPosition = effectiveValues.iconPosition || 'right';

		// Check if icon should be displayed based on showIcon attribute
		// Return null to completely hide icon when Show Icon toggle is off
		if ( effectiveValues.showIcon === false ) {
			return null;
		}

		// Get icon sources (structured objects with {kind, value})
		const inactiveSource = effectiveValues.iconInactiveSource || { kind: 'char', value: '▾' };
		const activeSource = effectiveValues.iconActiveSource;

		// Determine which icon to show based on collapsed state
		// In editor, we use initiallyCollapsed for preview
		const isCollapsed = effectiveValues.initiallyCollapsed || false;
		const hasDifferentActiveIcon = activeSource && activeSource.value;
		const displaySource =
			! isCollapsed && hasDifferentActiveIcon ? activeSource : inactiveSource;
		const displayPrefix =
			! isCollapsed && hasDifferentActiveIcon ? 'iconActive' : 'iconInactive';

		// Get responsive values for current device
		const offsetX =
			getResponsiveValue(
				effectiveValues[ `${ displayPrefix }OffsetX` ],
				responsiveDevice
			) || '0px';
		const offsetY =
			getResponsiveValue(
				effectiveValues[ `${ displayPrefix }OffsetY` ],
				responsiveDevice
			) || '0px';
		const color = effectiveValues[ `${ displayPrefix }Color` ] || '#333333';
		const size =
			getResponsiveValue( effectiveValues[ `${ displayPrefix }Size` ], responsiveDevice ) ||
			'16px';
		const maxSize =
			getResponsiveValue(
				effectiveValues[ `${ displayPrefix }MaxSize` ],
				responsiveDevice
			) || '24px';
		const rotation = ! isCollapsed ? effectiveValues.iconRotation || '180deg' : '0deg';

		// Wrapper styles (layout only)
		// Note: Display is handled by CSS variable (--toc-icon-display)
		// Note: Offsets are handled by CSS variables (--toc-icon-offset-x, --toc-icon-offset-y)
		const wrapperStyle = {
			alignItems: 'center',
		};

		// Icon styles (color, size, rotation) - for char and library icons
		// Icon styles (rotation only) - for char and library icons
		// Note: fontSize and color are handled by CSS variables (--toc-icon-size, --toc-icon-color)
		const iconStyle = {
			transform: `rotate(${ rotation })`,
			display: 'inline-flex',
			alignItems: 'center',
			lineHeight: 1,
		};

		// Image styles (rotation only)
		// Note: max-width/max-height are handled by CSS variables (--toc-icon-max-size)
		const imageStyle = {
			transform: `rotate(${ rotation })`,
			display: 'block',
		};

		// Render based on icon kind
		let iconElement = null;

		if ( displaySource.kind === 'char' ) {
			iconElement = (
				<span className="toc-icon toc-icon-char" style={ iconStyle }>
					{ displaySource.value }
				</span>
			);
		} else if ( displaySource.kind === 'image' ) {
			iconElement = (
				<img
					className="toc-icon toc-icon-image"
					src={ displaySource.value }
					alt=""
					aria-hidden="true"
					style={ imageStyle }
				/>
			);
		} else if ( displaySource.kind === 'library' ) {
			iconElement = (
				<span className="toc-icon toc-icon-library" style={ iconStyle }>
					{ renderLibraryIcon( displaySource.value ) }
				</span>
			);
		}

		if ( ! iconElement ) {
			return null;
		}

		return (
			<span className="toc-icon-wrapper" style={ wrapperStyle } aria-hidden="true">
				{ iconElement }
			</span>
		);
	};

	/* ========== AUTO-GENERATED-RENDER-TITLE-START ========== */
// DO NOT EDIT - This code is auto-generated from schema
// AUTO-GENERATED from schemas/toc-structure-mapping-autogenerated.json
// To modify, update the schema and run: npm run schema:build

/**
 * Render header with accordion-like structure
 */
const renderHeader = () => {
  if ( ! showTitle && ! isCollapsible ) {
    return null;
  }

  const iconElement = renderIcon();
  const hasIcon = !! iconElement;
  const currentIconPosition = iconPosition || 'right';
  const titleAlignment = effectiveValues.titleAlignment || 'left';
  const titleAlignClass = titleAlignment
    ? `title-align-${ titleAlignment }`
    : 'title-align-left';

  // Build header content based on icon position
  let buttonChildren;

  if ( currentIconPosition === 'box-left' ) {
    // Extreme left: icon at far left, text with flex grows to fill
    buttonChildren = (
      <>
        { hasIcon && <span className="toc-icon-slot">{ iconElement }</span> }
        <div className="toc-title-text-wrapper">
          <span className="toc-title-text">{ titleText }</span>
        </div>
      </>
    );
  } else if ( currentIconPosition === 'box-right' ) {
    // Extreme right: text with flex grows, icon at far right
    buttonChildren = (
      <>
        <div className="toc-title-text-wrapper">
          <span className="toc-title-text">{ titleText }</span>
        </div>
        { hasIcon && <span className="toc-icon-slot">{ iconElement }</span> }
      </>
    );
  } else if ( currentIconPosition === 'left' ) {
    // Left of text: wrap icon+text as single group that can be aligned
    buttonChildren = (
      <div className="toc-title-inline">
        { hasIcon && iconElement }
        <span className="toc-title-text">{ titleText }</span>
      </div>
    );
  } else {
    // Right of text (default): wrap text+icon as single group that can be aligned
    buttonChildren = (
      <div className="toc-title-inline">
        <span className="toc-title-text">{ titleText }</span>
        { hasIcon && iconElement }
      </div>
    );
  }

  // If collapsible, render as button
  if ( isCollapsible ) {
    return (
      <button
        id={ buttonId }
        className={ `toc-title toc-toggle-button ${
          currentIconPosition ? `icon-${ currentIconPosition }` : ''
        } ${ titleAlignClass }` }
        aria-expanded={ ! initiallyCollapsed }
        aria-controls={ contentId }
        type="button"
      >
        { buttonChildren }
      </button>
    );
  }

  // If not collapsible but showTitle is true, render as static title
  if ( showTitle ) {
    return (
      <div className={ `toc-title ${ titleAlignClass }` }>
        <span className="toc-title-text">{ titleText }</span>
      </div>
    );
  }

  return null;
};

/* ========== AUTO-GENERATED-RENDER-TITLE-END ========== */

	const numberingStyles = {};
	const numberingDataAttributes = {};
	[ 'h1', 'h2', 'h3', 'h4', 'h5', 'h6' ].forEach( ( level ) => {
		const style = attributes[ `${ level }NumberingStyle` ] || 'decimal';
		numberingStyles[ `--toc-${ level }-numbering` ] = style;
		numberingDataAttributes[ `data-${ level }-numbering` ] = style;
	} );
	const baseLevel = ( () => {
		const levels = ( tocItems || [] )
			.filter( ( item ) => item && item.level )
			.map( ( item ) => item.level );
		let minLevel = levels.length ? Math.min( ...levels ) : 1;
		if ( ( attributes.h1NumberingStyle || 'decimal' ) === 'none' && minLevel <= 1 ) {
			minLevel = 2;
		}
		return minLevel;
	} )();
	numberingDataAttributes[ 'data-base-level' ] = baseLevel;

	return (
		<>
			<InspectorControls>
				<div className="toc-settings-panel">
					<ThemeSelector
						blockType="toc"
						currentTheme={ currentTheme }
						attributes={ attributes }
						themes={ themes }
						themesLoaded={ themesLoaded }
						isCustomized={ isCustomized }
						effectiveValues={ effectiveValues }
						sessionCache={ sessionCache }
						onThemeChange={ handleThemeChange }
						onSaveNew={ handleSaveNewTheme }
						onUpdate={ handleUpdateTheme }
						onDelete={ handleDeleteTheme }
						onRename={ handleRenameTheme }
						onReset={ handleResetCustomizations }
					/>
				</div>

				{ /* Auto-generated panels from schema */ }
				<SchemaPanels
					schema={ tocSchema }
					attributes={ attributes }
					setAttributes={ setAttributes }
					effectiveValues={ effectiveValues }
					theme={ themes[ attributes.currentTheme ]?.values }
					cssDefaults={ allDefaults }
				/>

				{ /* Global breakpoint settings */ }
				<BreakpointSettings />

				{ /* Customization Warning */ }
				{ isCustomized && (
					<div className="customization-warning-wrapper">
						<CustomizationWarning currentTheme={ currentTheme } themes={ themes } />
					</div>
				) }
			</InspectorControls>

			<div { ...blockProps }>
				<div className="toc-header-wrapper">{ renderHeader() }</div>

				<nav className="toc-content">
					<ul className="toc-list toc-hierarchical-numbering">
						<li className="toc-placeholder">Loading table of contents...</li>
					</ul>
				</nav>
			</div>
		</>
	);
}

/**
 * Filter headings based on filter settings
 * Note: Heading level filtering is handled by includeH1-H6 during detection,
 * so this function only needs to check class-based filters.
 * @param headings
 * @param attributes
 */
function filterHeadings( headings, attributes ) {
	const { filterMode, includeClasses, excludeClasses, depthLimit } = attributes;

	let filtered = headings;

	// Apply class-based filter mode
	if ( filterMode === 'Include by class' ) {
		filtered = filtered.filter( ( heading ) => {
			// Include if any class matches
			if ( includeClasses ) {
				const classes = includeClasses.split( ',' ).map( ( c ) => c.trim() );
				return classes.some( ( cls ) => heading.classes.includes( cls ) );
			}

			return false;
		} );
	} else if ( filterMode === 'Excluse by class' ) {
		filtered = filtered.filter( ( heading ) => {
			// Exclude if any class matches
			if ( excludeClasses ) {
				const classes = excludeClasses.split( ',' ).map( ( c ) => c.trim() );
				if ( classes.some( ( cls ) => heading.classes.includes( cls ) ) ) {
					return false;
				}
			}

			return true;
		} );
	}

	// Apply depth limit
	if ( depthLimit && depthLimit > 0 ) {
		const minLevel = Math.min( ...filtered.map( ( h ) => h.level ) );
		filtered = filtered.filter( ( heading ) => heading.level - minLevel < depthLimit );
	}

	return filtered;
}

/**
 * Render headings as nested list
 * @param headings
 * @param effectiveValues
 * @param attributes
 */
function renderHeadingsList( headings, effectiveValues, attributes ) {
	if ( headings.length === 0 ) {
		return null;
	}

	const linkColorVar = getCssVarName( 'linkColor', 'toc' );
	const numberingStyles = {};
	const numberingDataAttributes = {};
	[ 'h1', 'h2', 'h3', 'h4', 'h5', 'h6' ].forEach( ( level ) => {
		const style = attributes[ `${ level }NumberingStyle` ] || 'decimal';
		numberingStyles[ `--toc-${ level }-numbering` ] = style;
		numberingDataAttributes[ `data-${ level }-numbering` ] = style;
	} );

	return (
		<ul
			className="toc-list toc-hierarchical-numbering"
			style={ numberingStyles }
			{ ...numberingDataAttributes }
			data-base-level={ ( () => {
				const levels = headings.filter( ( h ) => h && h.level ).map( ( h ) => h.level );
				let minLevel = levels.length ? Math.min( ...levels ) : 1;
				if ( ( attributes.h1NumberingStyle || 'decimal' ) === 'none' && minLevel <= 1 ) {
					minLevel = 2;
				}
				return minLevel;
			} )() }
		>
			{ headings.map( ( heading, index ) => {
				const levelClass = heading.level ? `toc-h${ heading.level }` : '';

				return (
					<li key={ index } className={ `toc-item ${ levelClass }` }>
						<a
							href={ `#${ heading.id || heading.anchor || `heading-${ index }` }` }
							className="toc-link"
							style={ linkColorVar ? { color: `var(${ linkColorVar })` } : undefined }
						>
							{ heading.text }
						</a>
					</li>
				);
			} ) }
		</ul>
	);
}

function slugify( text = '' ) {
	return text
		.toString()
		.trim()
		.toLowerCase()
		.replace( /[^a-z0-9\s-]/g, '' )
		.replace( /\s+/g, '-' )
		.replace( /-+/g, '-' )
		.replace( /^-+|-+$/g, '' );
}

const getItemAnchor = ( item = {} ) => item.anchor || item.id || '';

function buildHeadingAnchor( heading = {}, tocId = '', index = 0 ) {
	if ( heading.id ) {
		return heading.id;
	}

	if ( heading.anchor ) {
		return heading.anchor;
	}

	const textSlug = slugify( heading.text || `heading-${ index + 1 }` );
	const safeTocId = tocId || 'toc';
	const suffix = heading.sourceClientId ? `-${ heading.sourceClientId }` : `-${ index + 1 }`;
	return `${ safeTocId }-${ textSlug || `heading-${ index + 1 }` }${ suffix }`;
}

function headingToItem( heading, tocId, index = 0 ) {
	const anchor = buildHeadingAnchor( heading, tocId, index );
	return {
		anchor,
		id: anchor,
		text: heading.text || '',
		level: heading.level || 2,
		sourceClientId: heading.sourceClientId || null,
	};
}

function mergeHeadingsWithExisting( headings, existingItems, deletedHeadingIds, tocId ) {
	const deletedSet = new Set( deletedHeadingIds );
	const incoming = new Map();

	// Build map of incoming headings (respects current filter settings)
	headings.forEach( ( heading, index ) => {
		const anchor = buildHeadingAnchor( heading, tocId, index );
		if ( ! anchor || deletedSet.has( anchor ) ) {
			return;
		}
		incoming.set( anchor, headingToItem( heading, tocId, index ) );
	} );

	const merged = [];

	// Only preserve existing items that are still in the incoming headings
	// This ensures that when users change filter settings (e.g., turn off H3),
	// those headings are removed from tocItems on the next scan
	existingItems.forEach( ( item ) => {
		const anchor = getItemAnchor( item );
		if ( ! anchor || deletedSet.has( anchor ) ) {
			return;
		}

		// Only keep existing items if they're in the new incoming set
		if ( incoming.has( anchor ) ) {
			// Preserve custom edits (like manual text changes) while updating detected values
			merged.push( { ...item, ...incoming.get( anchor ) } );
			incoming.delete( anchor );
		}
		// Items not in incoming are dropped (they were filtered out or no longer exist)
	} );

	// Add any new headings that weren't in existingItems
	incoming.forEach( ( item ) => {
		merged.push( item );
	} );

	return merged;
}
