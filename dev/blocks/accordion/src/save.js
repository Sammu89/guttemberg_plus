/**
 * Accordion Block - Save Component
 *
 * Renders the frontend HTML structure with proper ARIA attributes.
 * Applies theme class names and only outputs inline CSS for explicit customizations.
 * Uses hybrid Tier 2 CSS approach for optimal performance.
 *
 * IMPORTANT: Sections marked with AUTO-GENERATED comments are automatically
 * regenerated from the schema on every build. Do not edit code between these markers.
 *
 * To modify styles:
 * 1. Edit the schema: schemas/accordion.json
 * 2. Run: npm run schema:build
 * 3. The code between markers will update automatically
 *
 * @package
 * @since 1.0.0
 */

import { useBlockProps, RichText, InnerBlocks } from '@wordpress/block-editor';
import { getAllEffectiveValues, getAccordionButtonAria, getAccordionPanelAria, getAllDefaults, getAlignmentClass, buildBoxShadow } from '@shared';
import { formatCssValue, getCssVarName } from '@shared/config/css-var-mappings-generated';
import { accordionAttributes } from './accordion-attributes';

/**
 * Build inline CSS variables ONLY for explicit customizations (Tier 3)
 * Theme values (Tier 2) are applied via CSS classes generated by PHP
 * CSS defaults (Tier 1) are in the stylesheet
 */
const getCustomizationStyles = ( customizations = {} ) => {
	const styles = {};

	const applyMarginVars = ( marginValue, suffix = '' ) => {
		if ( ! marginValue || typeof marginValue !== 'object' ) {
			return;
		}
		const unit = marginValue.unit || 'px';
		if ( marginValue.top !== undefined ) {
			styles[ `--accordion-block-margin-top${ suffix }` ] = `${ marginValue.top }${ unit }`;
		}
		if ( marginValue.bottom !== undefined ) {
			styles[ `--accordion-block-margin-bottom${ suffix }` ] = `${ marginValue.bottom }${ unit }`;
		}
	};

	Object.entries( customizations ).forEach( ( [ attrName, value ] ) => {
		if ( value === null || value === undefined ) {
			return;
		}

		// Special handling for blockMargin (top/bottom only)
		if ( attrName === 'blockMargin' ) {
			const isResponsive =
				value &&
				typeof value === 'object' &&
				( value.tablet !== undefined || value.mobile !== undefined );

			if ( isResponsive ) {
				// Base (desktop) is at root level, not under value.desktop
				const baseValue = value.value || value;
				if ( baseValue && typeof baseValue === 'object' ) {
					applyMarginVars( baseValue, '' );
				}
				if ( value.tablet ) {
					applyMarginVars( value.tablet, '-tablet' );
				}
				if ( value.mobile ) {
					applyMarginVars( value.mobile, '-mobile' );
				}
			} else {
				applyMarginVars( value, '' );
			}
			return;
		}

		// Special handling for shadow arrays (box-shadow with multiple layers)
		if ( attrName === 'shadow' && Array.isArray( value ) ) {
			const shadowCss = buildBoxShadow( value );
			if ( shadowCss && shadowCss !== 'none' ) {
				styles[ '--accordion-shadow' ] = shadowCss;
			}
			return;
		}

		const cssVar = getCssVarName( attrName, 'accordion' );
		if ( ! cssVar ) {
			return;
		}

		const isResponsive =
			value &&
			typeof value === 'object' &&
			( value.tablet !== undefined || value.mobile !== undefined );

		if ( isResponsive ) {
			// Handle base value (desktop is at root level as value.value, not value.desktop)
			const baseValue = value.value !== undefined ? value.value : value;
			if ( baseValue !== null && baseValue !== undefined ) {
				const formattedDesktop = formatCssValue( attrName, baseValue, 'accordion' );
				if ( formattedDesktop !== null ) {
					styles[ cssVar ] = formattedDesktop;
				}
			}

			if ( value.tablet !== undefined && value.tablet !== null ) {
				const formattedTablet = formatCssValue( attrName, value.tablet, 'accordion' );
				if ( formattedTablet !== null ) {
					styles[ `${ cssVar }-tablet` ] = formattedTablet;
				}
			}

			if ( value.mobile !== undefined && value.mobile !== null ) {
				const formattedMobile = formatCssValue( attrName, value.mobile, 'accordion' );
				if ( formattedMobile !== null ) {
					styles[ `${ cssVar }-mobile` ] = formattedMobile;
				}
			}

			return;
		}

		const formattedValue = formatCssValue( attrName, value, 'accordion' );
		if ( formattedValue !== null ) {
			styles[ cssVar ] = formattedValue;
		}
	} );

	// Handle titleFormatting array to build text-decoration-line
	const titleFormatting = customizations.titleFormatting || [];
	const decorationLines = titleFormatting.filter( ( f ) =>
		[ 'underline', 'overline', 'line-through' ].includes( f )
	);
	if ( decorationLines.length > 0 ) {
		styles[ '--accordion-title-text-decoration-line' ] = decorationLines.join( ' ' );
	}

	// Font weight (only if bold is selected)
	if ( titleFormatting.includes( 'bold' ) && customizations.titleFontWeight ) {
		styles[ '--accordion-title-font-weight' ] = customizations.titleFontWeight;
	}

	// Font style (only if italic is selected)
	if ( titleFormatting.includes( 'italic' ) ) {
		styles[ '--accordion-title-font-style' ] = 'italic';
	}

	// Decoration styling (only if any decoration is active)
	if ( decorationLines.length > 0 ) {
		if ( customizations.titleDecorationColor ) {
			styles[ '--accordion-title-decoration-color' ] = customizations.titleDecorationColor;
		}
		if ( customizations.titleDecorationStyle ) {
			styles[ '--accordion-title-decoration-style' ] = customizations.titleDecorationStyle;
		}
		if ( customizations.titleDecorationWidth ) {
			styles[ '--accordion-title-decoration-width' ] = customizations.titleDecorationWidth;
		}
	}

	return styles;
};

/**
 * Accordion Save Component
 *
 * @param {Object} props            Block props
 * @param {Object} props.attributes Block attributes
 * @return {JSX.Element} Save component
 */
export default function Save( { attributes } ) {
	// Extract schema defaults (single source of truth)
	const schemaDefaults = {};
	Object.keys( accordionAttributes ).forEach( ( key ) => {
		if ( accordionAttributes[ key ].default !== undefined ) {
			schemaDefaults[ key ] = accordionAttributes[ key ].default;
		}
	} );
	const allDefaults = getAllDefaults( schemaDefaults );

	// Get effective values for display purposes (icon rendering, etc.)
	const effectiveValues = getAllEffectiveValues(
		attributes,
		{}, // Themes are resolved server-side via CSS classes
		allDefaults,
		'accordion'
	);

	const accordionId = attributes.accordionId || '';

	const customizationStyles = getCustomizationStyles( attributes.customizations || {} );
	const hasCustomizations = Object.keys( customizationStyles ).length > 0;

	/**
	 * Render icon based on settings
	 */
	const renderIcon = () => {
		if ( ! effectiveValues.showIcon ) {
			return null;
		}

		const iconContent = effectiveValues.iconTypeClosed || 'â–¾';
		const iconOpen = effectiveValues.iconTypeOpen;
		const isImage = iconContent.startsWith( 'http' );

		if ( isImage ) {
			return (
				<img
					src={ iconContent }
					alt=""
					aria-hidden="true"
					className="accordion-icon accordion-icon-image"
					data-icon-closed={ iconContent }
					data-icon-open={ iconOpen !== 'none' ? iconOpen : iconContent }
				/>
			);
		}

		return (
			<span
				className="accordion-icon"
				aria-hidden="true"
				data-icon-closed={ iconContent }
				data-icon-open={ iconOpen !== 'none' ? iconOpen : iconContent }
			>
				{ iconContent }
			</span>
		);
	};

	/**
	 * Render title with optional heading wrapper
	 */
	const renderTitle = () => {
		const headingLevel = effectiveValues.headingLevel || 'none';
		const iconPosition = effectiveValues.iconPosition || 'right';
		const titleAlignment = effectiveValues.titleAlignment || 'left';
		const titleAlignClass = titleAlignment ? `title-align-${ titleAlignment }` : 'title-align-left';

		// ARIA attributes for button
		const buttonAria = getAccordionButtonAria(
			accordionId,
			attributes.initiallyOpen || false
		);

		const iconElement = renderIcon();
		const hasIcon = !! iconElement;

		// Build button content - icon position affects layout structure
		let buttonChildren;

		if ( iconPosition === 'extreme-left' ) {
			// Extreme left: icon at far left, text with flex grows to fill
			buttonChildren = (
				<>
					{ hasIcon && (
						<span className="accordion-icon-slot">
							{ iconElement }
						</span>
					) }
					<div className="accordion-title-text-wrapper">
						<RichText.Content
							tagName="span"
							value={ attributes.title || '' }
							className="accordion-title-text"
						/>
					</div>
				</>
			);
		} else if ( iconPosition === 'extreme-right' ) {
			// Extreme right: text with flex grows, icon at far right
			buttonChildren = (
				<>
					<div className="accordion-title-text-wrapper">
						<RichText.Content
							tagName="span"
							value={ attributes.title || '' }
							className="accordion-title-text"
						/>
					</div>
					{ hasIcon && (
						<span className="accordion-icon-slot">
							{ iconElement }
						</span>
					) }
				</>
			);
		} else if ( iconPosition === 'left' ) {
			// Left of text: wrap icon+text as single group that can be aligned
			buttonChildren = (
				<div className="accordion-title-inline">
					{ hasIcon && iconElement }
					<RichText.Content
						tagName="span"
						value={ attributes.title || '' }
						className="accordion-title-text"
					/>
				</div>
			);
		} else {
			// Right of text (default): wrap text+icon as single group that can be aligned
			buttonChildren = (
				<div className="accordion-title-inline">
					<RichText.Content
						tagName="span"
						value={ attributes.title || '' }
						className="accordion-title-text"
					/>
					{ hasIcon && iconElement }
				</div>
			);
		}

		const buttonContent = (
			<button
				type="button"
				className={ `accordion-title ${ iconPosition ? `icon-${ iconPosition }` : '' } ${ titleAlignClass }` }
				{ ...buttonAria }
			>
				{ buttonChildren }
			</button>
		);

		if ( headingLevel !== 'none' ) {
			const HeadingTag = headingLevel;
			return <HeadingTag className="accordion-heading">{ buttonContent }</HeadingTag>;
		}

		return buttonContent;
	};

	// ARIA attributes for panel
	const panelAria = getAccordionPanelAria( accordionId );

	// Build class names - accordion-item is now the root element
	const classNames = [ 'gutplus-accordion' ];

	// Add open state class
	if ( attributes.initiallyOpen ) {
		classNames.push( 'is-open' );
	}

	// Add theme class if using a theme
	if ( attributes.currentTheme ) {
		// Sanitize theme ID for CSS class (alphanumeric and hyphens only)
		const safeThemeId = attributes.currentTheme.replace( /[^a-zA-Z0-9\-]/g, '' );
		classNames.push( `gutplus-accordion-theme-${ safeThemeId }` );
	}

	// Add alignment class
	const alignmentClass = getAlignmentClass( attributes.accordionHorizontalAlign );
	classNames.push( alignmentClass );

	/**
	 * Format dimension value (width/height) with proper unit
	 * Handles both number and { value, unit } object formats
	 */
	const formatDimensionValue = ( value, defaultUnit = '%' ) => {
		if ( value === null || value === undefined ) {
			return null; // Don't apply default in save - let CSS handle it
		}
		// Handle responsive structure - extract base value (desktop is at root, not under .desktop key)
		if ( typeof value === 'object' && ( value.tablet !== undefined || value.mobile !== undefined ) ) {
			const baseValue = value.value ?? value;
			return formatDimensionValue( baseValue, defaultUnit );
		}
		// Handle { value, unit } object format
		if ( typeof value === 'object' && value.value !== undefined ) {
			return `${ value.value }${ value.unit || defaultUnit }`;
		}
		// Handle plain number
		if ( typeof value === 'number' ) {
			return `${ value }${ defaultUnit }`;
		}
		// Handle string (already formatted)
		return String( value );
	};

	// Format accordion width for inline style
	const formattedWidth = formatDimensionValue( attributes.accordionWidth, '%' );

	// Combine customization styles with width
	const inlineStyles = {
		...customizationStyles,
		...( formattedWidth && { width: formattedWidth } ),
	};
	const hasInlineStyles = Object.keys( inlineStyles ).length > 0;

	const blockProps = useBlockProps.save( {
		className: classNames.join( ' ' ),
		'data-accordion-id': accordionId,
		'data-gutplus-device': 'global',
		// Add id attribute for CSS selector targeting (Tier 3 customizations)
		...( accordionId && hasCustomizations && { id: accordionId } ),
		// Apply inline styles (width + customizations)
		...( hasInlineStyles && { style: inlineStyles } ),
	} );

	return (
		<>
			<div { ...blockProps }>
				<div className="accordion-title-wrapper">
					{ renderTitle() }
				</div>

				<div
					className="accordion-content"
					{ ...panelAria }
					{ ...( ! attributes.initiallyOpen && { hidden: true } ) }
				>
					<div className="accordion-content-inner">
						<InnerBlocks.Content />
					</div>
				</div>
			</div>
		</>
	);
}
