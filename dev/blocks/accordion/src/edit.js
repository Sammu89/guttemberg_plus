/**
 * Accordion Block - Edit Component
 *
 * Editor interface for accordion block with full theme integration.
 * Uses shared UI components and cascade resolution.
 *
 * IMPORTANT: Sections marked with AUTO-GENERATED comments are automatically
 * regenerated from the schema on every build. Do not edit code between these markers.
 *
 * To modify styles:
 * 1. Edit the schema: schemas/accordion.json
 * 2. Run: npm run schema:build
 * 3. The code between markers will update automatically
 *
 * @package
 * @since 1.0.0
 */

import { __ } from '@wordpress/i18n';
import { useBlockProps, InspectorControls, RichText, InnerBlocks } from '@wordpress/block-editor';
import { PanelBody, ToggleControl, TextControl, SelectControl } from '@wordpress/components';
import { useEffect, useState, useMemo, useRef } from '@wordpress/element';

import {
	generateUniqueId,
	getAllDefaults,
	ThemeSelector,
	TabbedInspector,
	SettingsPanels,
	AppearancePanels,
	CustomizationWarning,
	BreakpointSettings,
	useThemeManager,
	useBlockAlignment,
	useResponsiveDevice,
	renderSingleIcon,
	renderIconWrapper,
} from '@shared';
import * as LucideIcons from 'lucide-react';
import { buildBoxShadow, buildTextShadow } from '@shared/utils';
import accordionSchema from '../../../schemas/accordion-schema-autogenerated.json';
import { accordionAttributes } from './accordion-attributes';
import { buildEditorCssVars } from '@shared/styles/accordion-css-vars-generated';

/**
 * MANUAL DEPENDENCY: Icon rendering uses @shared/utils/icon-renderer.js
 * If you add new icon types (beyond char/image/library) or new icon libraries
 * (beyond dashicons/lucide), update the shared utility manually.
 * See: docs/AUTOGENERATIONSAVEANDEDIT.md for details.
 */

/**
 * Accordion Edit Component
 *
 * @param {Object}   props               Block props
 * @param {Object}   props.attributes    Block attributes
 * @param {Function} props.setAttributes Attribute setter
 * @param {string}   props.clientId      Block client ID
 * @return {JSX.Element} Edit component
 */
export default function Edit( { attributes, setAttributes, clientId } ) {
	// Use centralized alignment hook
	const blockRef = useBlockAlignment( attributes.accordionHorizontalAlign );
	const responsiveDevice = useResponsiveDevice();

	// Generate unique ID on mount if not set
	useEffect( () => {
		if ( ! attributes.accordionId ) {
			setAttributes( {
				accordionId: `acc-${ generateUniqueId() }`,
			} );
		}
	}, [ attributes.accordionId, setAttributes ] );

	// Extract schema defaults from accordionAttributes (SINGLE SOURCE OF TRUTH!)
	const schemaDefaults = useMemo( () => {
		const defaults = {};
		Object.keys( accordionAttributes ).forEach( ( key ) => {
			if ( accordionAttributes[ key ].default !== undefined ) {
				defaults[ key ] = accordionAttributes[ key ].default;
			}
		} );
		return defaults;
	}, [] );

	// All defaults come from schema - single source of truth!
	const allDefaults = useMemo( () => {
		const merged = getAllDefaults( schemaDefaults );
		return merged;
	}, [ schemaDefaults ] );

	// Use centralized theme management hook (provides ALL theme logic in one place)
	const {
		themes,
		themesLoaded,
		currentTheme,
		expectedValues,
		isCustomized,
		sessionCache,
		handlers: {
			handleSaveNewTheme,
			handleUpdateTheme,
			handleDeleteTheme,
			handleRenameTheme,
			handleResetCustomizations,
			handleThemeChange,
		},
	} = useThemeManager( {
		blockType: 'accordion',
		schema: accordionSchema,
		attributes,
		setAttributes,
		allDefaults,
	} );

	// SOURCE OF TRUTH: attributes = merged state (what you see in sidebar)
	const effectiveValues = attributes;

	// Local state for width input (allows typing without validation)
	const [ widthInput, setWidthInput ] = useState( attributes.accordionWidth || '100%' );

	// Editor-only icon preview state (driven by icon tabs)
	const [ iconPreviewState, setIconPreviewState ] = useState( 'inactive' );

	// Sync local input state when attribute changes externally
	useEffect( () => {
		const newWidth = attributes.accordionWidth || '100%';
		setWidthInput( newWidth );
	}, [ attributes.accordionWidth ] );

	// Reset icon preview to inactive whenever dual-icon mode is toggled
	useEffect( () => {
		setIconPreviewState( 'inactive' );
	}, [ attributes.useDifferentIcons ] );

	/**
	 * Apply inline styles from effective values
	 */
	/* ========== AUTO-GENERATED-STYLES-START ========== */
// DO NOT EDIT - This code is auto-generated from schema
// AUTO-GENERATED from schemas/accordion.json
// To modify styles, update the schema and run: npm run schema:build

const getInlineStyles = (responsiveDevice = 'global') => {
  // Extract object-type attributes with fallbacks
	const iconInactiveSource = effectiveValues.iconInactiveSource || {
		    "kind": "char",
		    "value": "▾"
		};
	const iconActiveSource = effectiveValues.iconActiveSource || {
		    "kind": "char",
		    "value": "▾"
		};

	return {
		container: {
			transitionDuration: (() => { const val = effectiveValues.animationDuration; if (val === null || val === undefined) return '250ms'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return '250ms'; })(),
		},
		icon: {
			display: effectiveValues.showIcon ? 'flex' : 'none',
			transform: `rotate(${effectiveValues.iconRotation ?? '180deg'})`,
			color: (() => { const val = effectiveValues.iconInactiveColor; if (val === null || val === undefined) return '#333333'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object' && val.value !== undefined) { return `${val.value}${val.unit || ''}`; } return '#333333'; })(),
			fontSize: (() => { const val = effectiveValues.iconInactiveSize; if (val === null || val === undefined) return '16px'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object') { const deviceVal = val[responsiveDevice]; if (deviceVal !== undefined) { if (typeof deviceVal === 'string') return deviceVal; if (typeof deviceVal === 'number') return deviceVal; if (typeof deviceVal === 'object' && deviceVal.value !== undefined) { return `${deviceVal.value}${deviceVal.unit || ''}`; } return deviceVal; } if (val.value !== undefined) { return `${val.value}${val.unit || ''}`; } } return '16px'; })(),
			maxWidth: (() => { const val = effectiveValues.iconInactiveMaxSize; if (val === null || val === undefined) return '24px'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object') { const deviceVal = val[responsiveDevice]; if (deviceVal !== undefined) { if (typeof deviceVal === 'string') return deviceVal; if (typeof deviceVal === 'number') return deviceVal; if (typeof deviceVal === 'object' && deviceVal.value !== undefined) { return `${deviceVal.value}${deviceVal.unit || ''}`; } return deviceVal; } if (val.value !== undefined) { return `${val.value}${val.unit || ''}`; } } return '24px'; })(),
			left: (() => { const val = effectiveValues.iconInactiveOffsetX; if (val === null || val === undefined) return '0px'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object') { const deviceVal = val[responsiveDevice]; if (deviceVal !== undefined) { if (typeof deviceVal === 'string') return deviceVal; if (typeof deviceVal === 'number') return deviceVal; if (typeof deviceVal === 'object' && deviceVal.value !== undefined) { return `${deviceVal.value}${deviceVal.unit || ''}`; } return deviceVal; } if (val.value !== undefined) { return `${val.value}${val.unit || ''}`; } } return '0px'; })(),
			top: (() => { const val = effectiveValues.iconInactiveOffsetY; if (val === null || val === undefined) return '0px'; if (typeof val === 'string') return val; if (typeof val === 'number') return val; if (typeof val === 'object') { const deviceVal = val[responsiveDevice]; if (deviceVal !== undefined) { if (typeof deviceVal === 'string') return deviceVal; if (typeof deviceVal === 'number') return deviceVal; if (typeof deviceVal === 'object' && deviceVal.value !== undefined) { return `${deviceVal.value}${deviceVal.unit || ''}`; } return deviceVal; } if (val.value !== undefined) { return `${val.value}${val.unit || ''}`; } } return '0px'; })(),
		},
	};
};
/* ========== AUTO-GENERATED-STYLES-END ========== */

	const styles = getInlineStyles( responsiveDevice );
	console.log(
		'[ACCORDION] responsiveDevice:',
		responsiveDevice,
		'styles.title.fontSize:',
		styles.title.fontSize,
		'styles.title.left:',
		styles.title.left,
		'styles.title.top:',
		styles.title.top
	);

	// Build font-weight from formatting selection
	const titleFormatting = effectiveValues.titleFormatting || [];
	const fontWeight = titleFormatting.includes( 'bold' )
		? effectiveValues.titleFontWeight || 400
		: 400;

	// Build font-style from formatting selection
	const fontStyle = titleFormatting.includes( 'italic' ) ? 'italic' : 'normal';

	// Build text-decoration from formatting selection
	const decorationLines = titleFormatting.filter( ( f ) =>
		[ 'underline', 'overline', 'line-through' ].includes( f )
	);
	const hasDecoration = decorationLines.length > 0;
	const textDecorationLine = hasDecoration ? decorationLines.join( ' ' ) : 'none';

	// Build formatting styles object to merge with title styles
	const titleFormattingStyles = {
		fontWeight,
		fontStyle,
		textDecorationLine,
		textDecorationColor: hasDecoration
			? effectiveValues.titleDecorationColor || 'currentColor'
			: undefined,
		textDecorationStyle: hasDecoration
			? effectiveValues.titleDecorationStyle || 'solid'
			: undefined,
		textDecorationThickness: hasDecoration
			? effectiveValues.titleDecorationWidth || 'auto'
			: undefined,
	};

	const titleTextInlineStyles =
		effectiveValues.titleNoLineBreak === 'nowrap' ? { whiteSpace: 'nowrap' } : undefined;

	/**
	 * Helper: Get responsive value based on current device
	 * @param {*}      value  - Value that might be responsive (object with global/tablet/mobile keys)
	 * @param {string} device - Current device ('global', 'tablet', 'mobile')
	 * @return {*} Resolved value for current device
	 */
	const getResponsiveValue = ( value, device ) => {
		if ( typeof value === 'object' && value !== null && ! Array.isArray( value ) ) {
			// Check if it's a responsive object (has global/tablet/mobile keys)
			if (
				value.global !== undefined ||
				value.tablet !== undefined ||
				value.mobile !== undefined
			) {
				return value[ device ] !== undefined ? value[ device ] : value.global;
			}
		}
		return value;
	};

	/**
	 * Render icon wrapper with both inactive and active states
	 * Uses shared utility function with LucideIcons passed as parameter
	 *
	 * @param {string} position - Icon position ('left', 'right', 'box-left', 'box-right')
	 * @return {JSX.Element|null} Icon element with wrapper
	 */
	const renderIcon = ( position = 'right' ) => {
		const showIcon = effectiveValues.showIcon ?? true;
		const inactiveSource = effectiveValues.iconInactiveSource || { kind: 'char', value: '▾' };
		const activeSource = effectiveValues.iconActiveSource;
		const useDifferentIcons = effectiveValues.useDifferentIcons;

		return renderIconWrapper(
			showIcon,
			inactiveSource,
			activeSource,
			useDifferentIcons,
			( source, state ) => renderSingleIcon( source, state, LucideIcons )
		);
	};

	/* ========== AUTO-GENERATED-RENDER-TITLE-START ========== */
// DO NOT EDIT - This code is auto-generated from schema
// AUTO-GENERATED from schemas/accordion-structure-mapping-autogenerated.json
// To modify, update the schema and run: npm run schema:build

/**
 * Render title with optional heading wrapper
 */
const renderTitle = () => {
  const headingLevel = effectiveValues.headingLevel || 'none';
  const iconPosition = effectiveValues.iconPosition || 'right';
  const titleAlignment = effectiveValues.titleAlignment || 'left';
  const titleAlignClass = titleAlignment
    ? `title-align-${ titleAlignment }`
    : 'title-align-left';

  const iconElement = renderIcon();
  const hasIcon = !! iconElement;

  // Build button content - icon position affects layout structure
  let buttonChildren;

  if ( iconPosition === 'box-left' ) {
    // Extreme left: icon at far left, text with flex grows to fill
    buttonChildren = (
      <>
        { hasIcon && <span className="accordion-icon-slot">{ iconElement }</span> }
        <div className="accordion-title-text-wrapper">
          <RichText
            tagName="span"
            value={ attributes.title || '' }
            onChange={ (value) => setAttributes({ title: value }) }
            placeholder={ __('Accordion title…', 'guttemberg-plus') }
            className="accordion-title-text"
            style={ {
              ...titleTextInlineStyles,
              ...titleFormattingStyles,
            } }
          />
        </div>
      </>
    );
  } else if ( iconPosition === 'box-right' ) {
    // Extreme right: text with flex grows, icon at far right
    buttonChildren = (
      <>
        <div className="accordion-title-text-wrapper">
          <RichText
            tagName="span"
            value={ attributes.title || '' }
            onChange={ (value) => setAttributes({ title: value }) }
            placeholder={ __('Accordion title…', 'guttemberg-plus') }
            className="accordion-title-text"
            style={ {
              ...titleTextInlineStyles,
              ...titleFormattingStyles,
            } }
          />
        </div>
        { hasIcon && <span className="accordion-icon-slot">{ iconElement }</span> }
      </>
    );
  } else if ( iconPosition === 'left' ) {
    // Left of text: wrap icon+text as single group that can be aligned
    buttonChildren = (
      <div className="accordion-title-inline">
        { hasIcon && iconElement }
        <RichText
          tagName="span"
          value={ attributes.title || '' }
          onChange={ (value) => setAttributes({ title: value }) }
          placeholder={ __('Accordion title…', 'guttemberg-plus') }
          className="accordion-title-text"
          style={ {
            ...titleTextInlineStyles,
            ...titleFormattingStyles,
          } }
        />
      </div>
    );
  } else {
    // Right of text (default): wrap text+icon as single group that can be aligned
    buttonChildren = (
      <div className="accordion-title-inline">
        <RichText
          tagName="span"
          value={ attributes.title || '' }
          onChange={ (value) => setAttributes({ title: value }) }
          placeholder={ __('Accordion title…', 'guttemberg-plus') }
          className="accordion-title-text"
          style={ {
            ...titleTextInlineStyles,
            ...titleFormattingStyles,
          } }
        />
        { hasIcon && iconElement }
      </div>
    );
  }

  const buttonContent = (
    <button
      type="button"
      className={ `accordion-title ${
        iconPosition ? `icon-${ iconPosition }` : ''
      } ${ titleAlignClass }` }
    >
      { buttonChildren }
    </button>
  );

  if ( headingLevel !== 'none' ) {
    const HeadingTag = headingLevel;
    return <HeadingTag className="accordion-heading">{ buttonContent }</HeadingTag>;
  }

  return buttonContent;
};

/* ========== AUTO-GENERATED-RENDER-TITLE-END ========== */

	// Validate width input - accepts pixels or percentage
	const validateWidth = ( value ) => {
		if ( ! value || value.trim() === '' ) {
			return '100%';
		}

		// Trim whitespace
		value = value.trim();

		// Check if it's a valid pixel value (number followed by 'px')
		const pxMatch = value.match( /^(\d+(?:\.\d+)?)px$/i );
		if ( pxMatch ) {
			return value;
		}

		// Check if it's a valid percentage (number followed by '%')
		const percentMatch = value.match( /^(\d+(?:\.\d+)?)%$/i );
		if ( percentMatch ) {
			return value;
		}

		// Check if it's just a number (assume pixels)
		const numberMatch = value.match( /^(\d+(?:\.\d+)?)$/ );
		if ( numberMatch ) {
			return `${ value }px`;
		}

		// Invalid format - default to 100%
		return '100%';
	};

	/**
	 * Format dimension value (width/height) with proper unit
	 * Handles both number and { value, unit } object formats
	 * Uses responsiveDevice to extract device-specific values
	 *
	 * Data structure:
	 * - Base (desktop): stored at root level as value.value or string
	 * - Tablet/Mobile: stored under value.tablet / value.mobile keys
	 * @param value
	 * @param defaultUnit
	 */
	const formatDimensionValue = ( value, defaultUnit = '%' ) => {
		if ( value === null || value === undefined ) {
			return `100${ defaultUnit }`;
		}
		// Handle responsive structure - extract value for current device
		if (
			typeof value === 'object' &&
			( value.tablet !== undefined || value.mobile !== undefined )
		) {
			// Global uses base value (value.value), tablet/mobile check their key first
			const deviceValue =
				responsiveDevice === 'global'
					? value.value
					: value[ responsiveDevice ] ?? value.value;
			return formatDimensionValue( deviceValue, defaultUnit );
		}
		// Handle { value, unit } object format
		if ( typeof value === 'object' && value.value !== undefined ) {
			return `${ value.value }${ value.unit || defaultUnit }`;
		}
		// Handle plain number
		if ( typeof value === 'number' ) {
			return `${ value }${ defaultUnit }`;
		}
		// Handle string (already formatted)
		return String( value );
	};

	// Build inline styles - accordion-item is now the root element
	// Combines wrapper styles (width) with item styles (borders, shadows)
	// Note: alignment margins are applied via ref with !important
	const editorCSSVars = buildEditorCssVars( effectiveValues );
	const rootStyles = {
		width: formatDimensionValue( effectiveValues.accordionWidth, '%' ),
		overflow: 'hidden', // Clip border-radius in editor
		...editorCSSVars, // Apply all CSS variables (including decomposed ones!)
		...styles.container, // Apply container styles (margin, radius, box effects)
	};

	// Build class names - match frontend structure
	const classNames = [ 'gutplus-accordion' ];

	// Add open state class for editor preview when dual icons are active
	const hasDifferentIcons = !! (
		effectiveValues.useDifferentIcons &&
		effectiveValues.iconActiveSource &&
		effectiveValues.iconActiveSource.value
	);
	const isPreviewOpen = hasDifferentIcons && iconPreviewState === 'active';
	if ( isPreviewOpen ) {
		classNames.push( 'is-open' );
	}

	// Add alignment class (same as frontend)
	const alignmentClass = attributes.accordionHorizontalAlign
		? `gutplus-align-${ attributes.accordionHorizontalAlign }`
		: 'gutplus-align-left';
	classNames.push( alignmentClass );

	const blockProps = useBlockProps( {
		className: classNames.join( ' ' ),
		style: rootStyles,
		ref: blockRef,
		'data-gutplus-device': responsiveDevice,
	} );

	/* ========== AUTO-GENERATED-BLOCK-CONTENT-START ========== */
// DO NOT EDIT - This code is auto-generated from schema

	const blockContentJSX = (
		<div { ...blockProps }>
			{ renderTitle() }

			<div className="accordion-content" style={ { ...styles.content } }>
				<div className="accordion-content-inner">
					<InnerBlocks
						templateLock={ false }
						placeholder={ __(
							'Add accordion content…',
							'guttemberg-plus'
						) }
					/>
				</div>
			</div>
		</div>
	);
/* ========== AUTO-GENERATED-BLOCK-CONTENT-END ========== */

	return (
		<>
			{ /* Make Gutenberg's blue selection outline follow accordion's border-radius */ }
			<style>
				{ `
					.block-editor-block-list__block.is-selected.accordion-item::after {
						border-radius: var(--accordion-border-radius, 4px) !important;
					}
				` }
			</style>
			<InspectorControls>
				<div className="accordion-settings-panel">
					<ThemeSelector
						blockType="accordion"
						currentTheme={ attributes.currentTheme }
						isCustomized={ isCustomized }
						attributes={ attributes }
						effectiveValues={ effectiveValues }
						themes={ themes }
						themesLoaded={ themesLoaded }
						onSaveNew={ handleSaveNewTheme }
						onUpdate={ handleUpdateTheme }
						onDelete={ handleDeleteTheme }
						onRename={ handleRenameTheme }
						onReset={ handleResetCustomizations }
						onThemeChange={ handleThemeChange }
						sessionCache={ sessionCache }
					/>
				</div>

				{ /* Tabbed inspector with settings and appearance panels */ }
				<TabbedInspector
					settingsContent={
						<>
							<SettingsPanels
								schema={ accordionSchema }
								attributes={ attributes }
								setAttributes={ setAttributes }
								effectiveValues={ effectiveValues }
								theme={ themes[ attributes.currentTheme ]?.values }
								cssDefaults={ allDefaults }
								onIconPreviewChange={ setIconPreviewState }
							/>
							<BreakpointSettings />
						</>
					}
					appearanceContent={
						<AppearancePanels
							schema={ accordionSchema }
							attributes={ attributes }
							setAttributes={ setAttributes }
							effectiveValues={ effectiveValues }
							theme={ themes[ attributes.currentTheme ]?.values }
							cssDefaults={ allDefaults }
							onIconPreviewChange={ setIconPreviewState }
						/>
					}
				/>

				{ isCustomized && (
					<div className="customization-warning-wrapper">
						<CustomizationWarning
							currentTheme={ attributes.currentTheme }
							themes={ themes }
						/>
					</div>
				) }
			</InspectorControls>

			{ blockContentJSX }
		</>
	);
}
