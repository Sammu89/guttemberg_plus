/**
 * Accordion Block - Save Component
 *
 * Renders the frontend HTML structure with proper ARIA attributes.
 * Applies theme class names and only outputs inline CSS for explicit customizations.
 * Uses hybrid Tier 2 CSS approach for optimal performance.
 *
 * IMPORTANT: Sections marked with AUTO-GENERATED comments are automatically
 * regenerated from the schema on every build. Do not edit code between these markers.
 *
 * To modify styles:
 * 1. Edit the schema: schemas/accordion.json
 * 2. Run: npm run schema:build
 * 3. The code between markers will update automatically
 *
 * @package
 * @since 1.0.0
 */

import { useBlockProps, RichText, InnerBlocks } from '@wordpress/block-editor';
import { select } from '@wordpress/data';
import {
	getAllEffectiveValues,
	getAccordionButtonAria,
	getAccordionPanelAria,
	getAllDefaults,
	getAlignmentClass,
	renderSingleIcon,
	renderIconWrapper,
	applyDeltas,
	STORE_NAME,
} from '@shared';
import { buildFrontendCssVars } from '@shared/styles/accordion-frontend-css-vars-generated';
import accordionSchema from '../../schemas/generated/accordion.json';
import * as LucideIcons from 'lucide-react';

/**
 * MANUAL DEPENDENCY: Icon rendering uses @shared/utils/icon-renderer.js
 * If you add new icon types (beyond char/image/library) or new icon libraries
 * (beyond dashicons/lucide), update the shared utility manually.
 * See: docs/AUTOGENERATIONSAVEANDEDIT.md for details.
 */

/**
 * Accordion Save Component
 *
 * @param {Object} props            Block props
 * @param {Object} props.attributes Block attributes
 * @return {JSX.Element} Save component
 */
export default function Save( { attributes } ) {
	// Use pre-computed defaults from comprehensive schema
	const allDefaults = accordionSchema.defaultValues || {};

	// Get effective values for display purposes (icon rendering, etc.)
	const effectiveValues = getAllEffectiveValues(
		attributes,
		{}, // Themes are resolved server-side via CSS classes
		allDefaults,
		'accordion'
	);

	const accordionId = attributes.accordionId || '';

	// Build expected values (defaults + theme deltas if available)
	const expectedValues = (() => {
		if ( ! attributes.currentTheme ) {
			return allDefaults;
		}
		try {
			const themes = select( STORE_NAME )?.getThemes?.( 'accordion' ) || {};
			const theme = themes[ attributes.currentTheme ];
			if ( theme && theme.values ) {
				return applyDeltas( allDefaults, theme.values );
			}
		} catch ( error ) {
			// Fall back to defaults when store data isn't available.
		}
		return allDefaults;
	})();

	const excludeFromCustomizationCheck = (() => {
		const schemaExclusions = Object.entries( accordionSchema.attributes )
			.filter( ( [ , attr ] ) => attr.themeable !== true )
			.map( ( [ key ] ) => key );
		if ( ! schemaExclusions.includes( 'customizations' ) ) {
			schemaExclusions.push( 'customizations' );
		}
		return schemaExclusions;
	})();

	const rawCustomizations =
		attributes.customizations && typeof attributes.customizations === 'object'
			? attributes.customizations
			: {};

	// Fallback: recompute customizations from attributes when missing
	const customizations = (() => {
		if ( Object.keys( rawCustomizations ).length > 0 ) {
			return rawCustomizations;
		}

		const next = {};
		Object.keys( attributes ).forEach( ( key ) => {
			if ( excludeFromCustomizationCheck.includes( key ) || key === 'customizations' ) {
				return;
			}
			const attrValue = attributes[ key ];
			const expectedValue = expectedValues[ key ];
			if ( attrValue === undefined || attrValue === null ) {
				return;
			}
			if ( expectedValue === undefined ) {
				return;
			}
			const isDifferent =
				typeof attrValue === 'object' && attrValue !== null
					? JSON.stringify( attrValue ) !== JSON.stringify( expectedValue )
					: attrValue !== expectedValue;
			if ( isDifferent ) {
				next[ key ] = attrValue;
			}
		} );
		return next;
	})();

	const inlineStyles = buildFrontendCssVars( customizations, attributes );
	const hasCustomizations = Object.keys( customizations ).length > 0;

	const titleTextInlineStyles = undefined;

	/**
	 * Render icon wrapper with both inactive and active states
	 * Uses shared utility function with LucideIcons passed as parameter
	 */
	const renderIcon = () => {
		return renderIconWrapper(
			attributes.iconInactiveSource,
			attributes.iconActiveSource,
			attributes.useDifferentIcons,
			attributes.showIcon,
			LucideIcons
		);
	};

	/* ========== AUTO-GENERATED-RENDER-TITLE-START ========== */
// DO NOT EDIT - This code is auto-generated from schema
// AUTO-GENERATED from schemas/accordion-structure-mapping-autogenerated.json
// To modify, update the schema and run: npm run schema:build

/**
 * Render title with optional heading wrapper
 */
const renderTitle = () => {
  const headingLevel = effectiveValues.headingLevel || 'none';
  const iconPosition = effectiveValues.iconPosition || 'right';
  const titleAlignment = effectiveValues.titleAlignment || 'left';
  const titleAlignClass = titleAlignment
    ? `title-align-${ titleAlignment }`
    : 'title-align-left';

  // ARIA attributes for button
  const buttonAria = getAccordionButtonAria( accordionId, attributes.initiallyOpen || false );

  const iconElement = renderIcon();
  const hasIcon = !! iconElement;

  // Build button content - icon position affects layout structure
  let buttonChildren;

  if ( iconPosition === 'box-left' ) {
    // Extreme left: icon at far left, text with flex grows to fill
    buttonChildren = (
      <>
        { hasIcon && <span className="accordion-icon-slot">{ iconElement }</span> }
        <div className="accordion-title-text-wrapper">
          <RichText.Content
            tagName="span"
            value={ attributes.title || '' }
            className="accordion-title-text"
            style={ titleTextInlineStyles }
          />
        </div>
      </>
    );
  } else if ( iconPosition === 'box-right' ) {
    // Extreme right: text with flex grows, icon at far right
    buttonChildren = (
      <>
        <div className="accordion-title-text-wrapper">
          <RichText.Content
            tagName="span"
            value={ attributes.title || '' }
            className="accordion-title-text"
            style={ titleTextInlineStyles }
          />
        </div>
        { hasIcon && <span className="accordion-icon-slot">{ iconElement }</span> }
      </>
    );
  } else if ( iconPosition === 'left' ) {
    // Left of text: wrap icon+text as single group that can be aligned
    buttonChildren = (
      <div className="accordion-title-inline">
        { hasIcon && iconElement }
        <RichText.Content
          tagName="span"
          value={ attributes.title || '' }
          className="accordion-title-text"
          style={ titleTextInlineStyles }
        />
      </div>
    );
  } else {
    // Right of text (default): wrap text+icon as single group that can be aligned
    buttonChildren = (
      <div className="accordion-title-inline">
        <RichText.Content
          tagName="span"
          value={ attributes.title || '' }
          className="accordion-title-text"
          style={ titleTextInlineStyles }
        />
        { hasIcon && iconElement }
      </div>
    );
  }

  const buttonContent = (
    <button
      type="button"
      className={ `accordion-title ${
        iconPosition ? `icon-${ iconPosition }` : ''
      } ${ titleAlignClass }` }
      { ...buttonAria }
    >
      { buttonChildren }
    </button>
  );

  if ( headingLevel !== 'none' ) {
    const HeadingTag = headingLevel;
    return <HeadingTag className="accordion-heading">{ buttonContent }</HeadingTag>;
  }

  return buttonContent;
};

/* ========== AUTO-GENERATED-RENDER-TITLE-END ========== */

	/* ========== AUTO-GENERATED-BLOCK-CONTENT-START ========== */
// DO NOT EDIT - This code is auto-generated from schema

	// ARIA attributes for panel
	const panelAria = getAccordionPanelAria( accordionId );

	// Build class names - accordion-item is now the root element
	const classNames = [ 'gutplus-accordion' ];

	// Add open state class
	if ( attributes.initiallyOpen ) {
		classNames.push( 'is-open' );
	}

	// Add theme class if using a theme
	if ( attributes.currentTheme ) {
		// Sanitize theme ID for CSS class (alphanumeric and hyphens only)
		const safeThemeId = attributes.currentTheme.replace( /[^a-zA-Z0-9\-]/g, '' );
		classNames.push( `gutplus-accordion-theme-${ safeThemeId }` );
	}

	// Add alignment class
	const alignmentClass = getAlignmentClass( attributes.accordionHorizontalAlign );
	classNames.push( alignmentClass );

	const hasInlineStyles = Object.keys( inlineStyles ).length > 0;

	const blockProps = useBlockProps.save( {
		className: classNames.join( ' ' ),
		'data-accordion-id': accordionId,
		'data-animation-type': attributes.animationType || 'slide',
		'data-gutplus-device': 'global',
		// Add id attribute for CSS selector targeting (Tier 3 customizations)
		...( accordionId && hasCustomizations && { id: accordionId } ),
		// Apply inline styles (CSS variables + manual overrides)
		...( hasInlineStyles && { style: inlineStyles } ),
	} );

	return (
		<>
			<div { ...blockProps }>
				<div className="accordion-title-wrapper">{ renderTitle() }</div>

				<div
					className="accordion-content"
					{ ...panelAria }
					{ ...( ! attributes.initiallyOpen && { hidden: true } ) }
				>
					<div className="accordion-content-inner">
						<InnerBlocks.Content />
					</div>
				</div>
			</div>
		</>
	);
/* ========== AUTO-GENERATED-BLOCK-CONTENT-END ========== */
}
