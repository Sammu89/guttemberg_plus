# Advanced Sidebar Implementation Guide

## Overview

This document outlines the implementation of a sophisticated, multi-level sidebar control system using Gutenberg's ToolsPanel component, combined with a schema-first architecture that auto-generates all necessary translator and UI components.

**Goal:** Create a clean, organized sidebar that matches modern WordPress design patterns while maintaining full integration with the theme system and native Gutenberg controls.

---

## Architecture Layers

### Layer 1: Single Source of Truth (Schema)
- All attribute definitions live in `schemas/{block}.json`
- Schema includes new fields for sidebar organization and control properties
- No manual synchronization needed

### Layer 2: Auto-Generated Configuration Files
Generated by `build-tools/schema-compiler.js`:
- `tools-panel-hierarchy-extended-generated.js` - Organizational structure
- `native-controls-mapping-generated.js` - Translator between schema ↔ Gutenberg
- `use-gutenberg-translator-generated.js` - Syncing hook
- `block-supports-generated.json` - For block.json
- `tools-panel-ui-generator-generated.js` - UI rendering component

### Layer 3: Block Implementation
- `block.json` - Uses auto-generated supports
- `edit.js` - Uses translator hook + auto-generated UI component
- Theme system - Unchanged, continues working as-is

---

## Implementation Steps

### Step 1: Extend the Schema Format

Add new fields to each attribute in `schemas/{block}.json`:

```json
{
  "attributeName": {
    // Existing fields (unchanged)
    "type": "string",
    "default": "value",
    "cssVar": "css-variable-name",
    "cssProperty": "css-property",
    "themeable": true,
    "control": "ColorPicker",

    // NEW: Sidebar Organization (4-tier hierarchy)
    "toolsPanelGroup": "Main Group Name",          // Tier 1: Panel group
    "toolsPanelSubGroup": "Sub-Item Name",         // Tier 2: Dropdown item
    "controlSection": "SECTION HEADER",            // Tier 3: Section in panel

    // NEW: Control Properties (UI variations)
    "showSlider": true,                            // Include slider for RangeControl
    "showUnitSelector": true,                      // Show unit picker dropdown
    "availableUnits": ["px", "rem", "em", "vw", "vh"], // Available unit options
    "defaultUnit": "px",                           // Default unit when selector is shown
    "showIcon": true,                              // Show visual icon/preview
    "showLinkIcon": true,                          // Show link/unlink toggle (for multi-part controls)
    "showPresets": true,                           // Show preset options
    "presets": ["option1", "option2"],            // Preset values
    "helperText": "Help text for users",          // Description below control
    "placeholder": "Placeholder text",            // Placeholder in text inputs
    "enableAlpha": false,                          // For color pickers

    // NEW: Sub-group Features
    "resetButton": true,                           // Show RESET button for sub-group

    // NEW: Collapsible Sections
    "isCollapsibleSection": true,                  // Make entire section collapsible
    "isCollapsibleOpen": false,                    // Start open/closed

    // NEW: Gutenberg Integration
    "gutenbergControl": "border.color",            // Maps to native Gutenberg control
    "isShownByDefault": true,                      // Show by default in ToolsPanel

    // NEW: Sidebar Visibility
    "visibleOnSidebar": true                       // Include in sidebar UI (default: true)
  }
}
```

---

### Step 2: Update schema-compiler.js

Modify `build-tools/schema-compiler.js` to generate new files:

#### 2.1 Parse new schema fields

```javascript
const parseControlProperties = (attr) => {
  return {
    showSlider: attr.showSlider ?? false,
    showUnitSelector: attr.showUnitSelector ?? false,
    availableUnits: attr.availableUnits ?? [],
    defaultUnit: attr.defaultUnit ?? 'px',
    showIcon: attr.showIcon ?? false,
    showLinkIcon: attr.showLinkIcon ?? false,
    showPresets: attr.showPresets ?? false,
    presets: attr.presets ?? [],
    helperText: attr.helperText ?? null,
    placeholder: attr.placeholder ?? null,
    enableAlpha: attr.enableAlpha ?? false,
    resetButton: attr.resetButton ?? false,
    isCollapsibleSection: attr.isCollapsibleSection ?? false,
    isCollapsibleOpen: attr.isCollapsibleOpen ?? false,
    gutenbergControl: attr.gutenbergControl ?? null,
    isShownByDefault: attr.isShownByDefault ?? false,
    visibleOnSidebar: attr.visibleOnSidebar ?? true
  };
};
```

#### 2.2 Generate tools-panel-hierarchy-extended-generated.js

```javascript
const generateToolsPanelHierarchy = (schema, blockType) => {
  const hierarchy = {};

  // Group attributes by toolsPanelGroup
  const groups = {};

  Object.entries(schema.attributes).forEach(([key, attr]) => {
    if (!attr.visibleOnSidebar) return; // Skip invisible items

    const groupName = attr.toolsPanelGroup || 'Other';
    const subGroupName = attr.toolsPanelSubGroup || 'Default';

    if (!groups[groupName]) {
      groups[groupName] = {
        subGroups: {},
        isCollapsible: attr.isCollapsibleSection,
        isOpen: attr.isCollapsibleOpen
      };
    }

    if (!groups[groupName].subGroups[subGroupName]) {
      groups[groupName].subGroups[subGroupName] = {
        label: subGroupName,  // Store label when creating subGroup
        items: [],
        resetButton: false
      };
    }

    groups[groupName].subGroups[subGroupName].items.push({
      key,
      label: attr.label,
      section: attr.controlSection,
      control: attr.control,
      ...parseControlProperties(attr)
    });
  });

  return {
    [blockType]: groups
  };
};
```

#### 2.3 Generate native-controls-mapping-generated.js

```javascript
const generateNativeControlsMapping = (schema, blockType) => {
  const mapping = {};

  Object.entries(schema.attributes).forEach(([key, attr]) => {
    if (!attr.visibleOnSidebar || !attr.gutenbergControl) return;

    mapping[attr.gutenbergControl] = {
      schemaAttribute: key,
      cssVar: attr.cssVar,
      cssProperty: attr.cssProperty,
      appliesTo: attr.appliesTo,
      type: attr.type,
      themeable: attr.themeable
    };
  });

  return {
    [blockType]: mapping
  };
};
```

#### 2.4 Generate use-gutenberg-translator-generated.js

**IMPORTANT:** The translator must handle nested ↔ flat conversion.

Native Gutenberg format is nested:
```javascript
attributes.style.border.color  // nested
```

Schema format is flat:
```javascript
attributes.borderColor  // flat
```

```javascript
const generateTranslatorHook = (blockType, mapping) => {
  return `
// AUTO-GENERATED - Do not edit
import { useEffect } from '@wordpress/element';
import { GUTENBERG_MAPPING } from './native-controls-mapping-generated';

// Helper functions for nested object access
function getNestedValue(obj, path) {
  if (!obj || !path) return undefined;
  return path.split('.').reduce((acc, key) => acc?.[key], obj);
}

function setNestedValue(obj, path, value) {
  const keys = path.split('.');
  const lastKey = keys.pop();
  const target = keys.reduce((acc, key) => {
    if (!acc[key]) acc[key] = {};
    return acc[key];
  }, obj);
  target[lastKey] = value;
  return obj;
}

export function useGutenbergTranslator(attributes, setAttributes) {
  const mapping = GUTENBERG_MAPPING['${blockType}'];

  useEffect(() => {
    Object.entries(mapping).forEach(([gutenbergKey, schemaInfo]) => {
      // Gutenberg stores in nested format (e.g., style.border.color)
      const gutenbergValue = getNestedValue(attributes.style, gutenbergKey);
      // Schema stores in flat format (e.g., borderColor)
      const schemaValue = attributes[schemaInfo.schemaAttribute];

      if (gutenbergValue !== schemaValue && gutenbergValue !== undefined) {
        // Sync Gutenberg → Schema
        setAttributes({
          [schemaInfo.schemaAttribute]: gutenbergValue
        });
      } else if (schemaValue !== undefined && gutenbergValue === undefined) {
        // Sync Schema → Gutenberg (when user changes via our controls)
        const newStyle = { ...attributes.style };
        setNestedValue(newStyle, gutenbergKey, schemaValue);
        setAttributes({ style: newStyle });
      }
    });
  }, [attributes, setAttributes]);
}
`;
};
```

#### 2.5 Generate block-supports-generated.json

```javascript
const generateBlockSupports = (schema) => {
  const supports = {
    spacing: { padding: false, margin: false },
    border: { color: false, radius: false, style: false, width: false },
    shadow: false
  };

  Object.values(schema.attributes).forEach(attr => {
    if (!attr.gutenbergControl) return;

    if (attr.gutenbergControl.startsWith('spacing.')) {
      const type = attr.gutenbergControl.split('.')[1];
      supports.spacing[type] = true;
    } else if (attr.gutenbergControl.startsWith('border.')) {
      const type = attr.gutenbergControl.split('.')[1];
      supports.border[type] = true;
    } else if (attr.gutenbergControl === 'shadow') {
      supports.shadow = true;
    }
  });

  return supports;
};
```

---

### Step 3: Generate ToolsPanel UI Component

Create `tools-panel-ui-generator-generated.js`:

```javascript
// AUTO-GENERATED - Do not edit
// NOTE: These are experimental APIs and may change in future WordPress versions
import {
  __experimentalToolsPanel as ToolsPanel,
  __experimentalToolsPanelItem as ToolsPanelItem,
  __experimentalUnitControl as UnitControl,
} from '@wordpress/components';
import { TOOLS_PANEL_HIERARCHY } from './tools-panel-hierarchy-extended-generated';
import { renderControl } from './control-renderer';

export function generateToolsPanelUI(
  blockType,
  attributes,
  setAttributes,
  schema
) {
  const hierarchy = TOOLS_PANEL_HIERARCHY[blockType];

  return Object.entries(hierarchy).map(([groupKey, groupData]) => {
    if (groupData.isCollapsible) {
      return (
        <CollapsibleSection
          key={groupKey}
          title={groupData.label}
          isOpen={groupData.isCollapsibleOpen}
        >
          {renderSubGroups(blockType, groupData.subGroups, attributes, setAttributes, schema)}
        </CollapsibleSection>
      );
    }

    return (
      <ToolsPanel
        key={groupKey}
        label={groupKey}
        panelId={`${blockType}-${groupKey.toLowerCase().replace(/\s+/g, '-')}`}
        resetAll={() => resetAllInGroup(groupData, setAttributes)}
      >
        {renderSubGroups(blockType, groupData.subGroups, attributes, setAttributes, schema)}
      </ToolsPanel>
    );
  });
}

function renderSubGroups(blockType, subGroups, attributes, setAttributes, schema) {
  return Object.entries(subGroups).map(([subGroupKey, subGroupData]) => (
    <div key={subGroupKey} className="tools-panel-subgroup">
      <div className="subgroup-header">
        <span>{subGroupData.label}</span>
        {subGroupData.resetButton && (
          <button onClick={() => resetSubGroup(subGroupData, setAttributes)}>
            RESET
          </button>
        )}
      </div>

      {subGroupData.items.map(item => (
        <ToolsPanelItem
          key={item.key}
          label={item.label}
          hasValue={() => {
            const value = attributes[item.key];
            const defaultValue = schema.attributes[item.key].default;
            return value !== undefined && value !== defaultValue;
          }}
          onDeselect={() => setAttributes({ [item.key]: schema.attributes[item.key].default })}
          resetAllFilter={() => ({ [item.key]: schema.attributes[item.key].default })}
          isShownByDefault={item.isShownByDefault}
        >
          {renderControl(
            item.control,
            item,
            attributes[item.key],
            setAttributes,
            schema.attributes[item.key]
          )}
        </ToolsPanelItem>
      ))}
    </div>
  ));
}
```

---

### Step 4: Update block.json

Replace hardcoded supports with auto-generated version:

```json
{
  "supports": {
    // ... other supports
    // These are auto-generated from schema
    "spacing": {
      "padding": false,
      "margin": true
    },
    "border": {
      "color": true,
      "radius": true,
      "style": true,
      "width": true
    },
    "shadow": true
  }
}
```

Or load from generated file programmatically if using a build step.

---

### Step 5: Update edit.js

Integrate translator hook and auto-generated UI:

```javascript
import { useGutenbergTranslator } from './generated/use-gutenberg-translator-generated';
import { generateToolsPanelUI } from './generated/tools-panel-ui-generator-generated';

export default function Edit({ attributes, setAttributes, clientId }) {
  // Auto-sync Gutenberg ↔ Schema
  useGutenbergTranslator(attributes, setAttributes);

  // Use existing theme manager (unchanged)
  const { themes, handlers, expectedValues } = useThemeManager({
    blockType: 'accordion',
    schema: accordionSchema,
    attributes,
    setAttributes,
    allDefaults
  });

  return (
    <>
      <InspectorControls group="styles">
        {/* Auto-generated hierarchical ToolsPanel UI */}
        {generateToolsPanelUI(
          'accordion',
          attributes,
          setAttributes,
          accordionSchema
        )}
      </InspectorControls>

      {/* Rest of editor content... */}
    </>
  );
}
```

---

### Step 6: Update Build Pipeline

Modify npm scripts in `package.json`:

```json
{
  "scripts": {
    "schema:build": "node build-tools/schema-compiler.js",
    "schema:validate": "node build-tools/schema-validator.js",
    "build": "npm run schema:build && webpack --mode production"
  }
}
```

---

## File Generation Summary

When you run `npm run schema:build`, the compiler generates:

| File | Purpose | Location |
|------|---------|----------|
| `tools-panel-hierarchy-extended-generated.js` | Organizational structure | `shared/src/config/` |
| `native-controls-mapping-generated.js` | Translator map | `shared/src/config/` |
| `use-gutenberg-translator-generated.js` | Syncing hook | `shared/src/hooks/` |
| `block-supports-generated.json` | Block supports config | `blocks/{block}/` |
| `tools-panel-ui-generator-generated.js` | UI rendering component | `shared/src/components/` |
| `accordion-attributes.js` | Block attributes (existing) | `blocks/accordion/src/` |
| `accordion-theme.ts` | TypeScript types (existing) | `shared/src/types/` |
| `accordion-schema.ts` | Zod validator (existing) | `shared/src/validators/` |

---

## Control Types & Properties

### RangeControl
```json
{
  "control": "RangeControl",
  "min": 0,
  "max": 100,
  "step": 1,
  "showSlider": true,
  "showUnitSelector": true,
  "availableUnits": ["px", "em", "%", "rem", "vw", "vh"],
  "unit": "px"
}
```

### ColorPicker
```json
{
  "control": "ColorPicker",
  "showIcon": true,
  "enableAlpha": false,
  "showUnitSelector": false
}
```

**Note:** Colors don't have units. Never add `availableUnits` to ColorPicker.

### TextControl
```json
{
  "control": "TextControl",
  "placeholder": "Enter text",
  "helperText": "Help description"
}
```

### SelectControl
```json
{
  "control": "SelectControl",
  "options": [
    { "label": "Option 1", "value": "opt1" },
    { "label": "Option 2", "value": "opt2" }
  ]
}
```

### BorderRadiusControl
```json
{
  "control": "BorderRadiusControl",
  "showSlider": true,
  "showUnitSelector": true,
  "showLinkIcon": true,
  "availableUnits": ["px", "em", "rem", "%"],
  "showPresets": true,
  "presets": [
    { "name": "None", "value": "0" },
    { "name": "Small", "value": "4px" },
    { "name": "Medium", "value": "8px" },
    { "name": "Large", "value": "16px" },
    { "name": "Full", "value": "9999px" }
  ]
}
```

### ShadowControl
```json
{
  "control": "ShadowControl",
  "showIcon": true,
  "showPresets": true,
  "presets": ["none", "natural", "deep", "sharp", "outlined", "crisp"],
  "allowCustom": true
}
```

---

## Organization Best Practices

### Panel Groups (Tier 1)
Use clear, category-based names:
- `"Colors"` - All color controls
- `"Typography"` - Font settings
- `"Spacing"` - Padding, margin
- `"Border & Shadow"` - Border, radius, shadow
- `"Layout"` - Size, alignment
- `"Effects"` - Animations, transforms

### Sub-Groups (Tier 2)
Be specific about what part of the element:
- `"Text"`, `"Background"`, `"Link"` (under Colors)
- `"Size"`, `"Weight"`, `"Decoration"` (under Typography)
- `"Border"`, `"Radius"`, `"Shadow"` (under Border & Shadow)

### Control Sections (Tier 3)
Use UPPERCASE for clarity:
- `"TEXT COLOR"`, `"BACKGROUND COLOR"`
- `"FONT SIZE"`, `"FONT WEIGHT"`
- `"BORDER"`, `"RADIUS"`, `"SHADOW"`

### Sub-Group Reset Buttons
Add `"resetButton": true` to important groupings:
- Border controls (so users can reset all border properties)
- Shadow controls (so users can reset all shadow properties)

### Collapsible Sections
Use for advanced/less common controls:
- `"Advanced"` section for HTML anchors, CSS classes
- `"Animations"` section for transform, transition
- `"Accessibility"` section for ARIA attributes

---

## Important Notes

### Reset Values
The reset value for any attribute is simply the `default` field from the schema. There is no need for a separate `resetValue` field.

```javascript
// When resetting, use the schema default:
onDeselect={() => setAttributes({ [item.key]: schema.attributes[item.key].default })}
```

### Available Units
Common unit types:
- **Length:** `px`, `em`, `rem`, `%`, `vw`, `vh`, `vmin`, `vmax`
- **Angles:** `deg`, `rad`, `grad`, `turn`
- **Time:** `s`, `ms`

**Never use made-up units like "DX"** - stick to valid CSS units only.

### Experimental APIs Warning
The ToolsPanel components use experimental WordPress APIs:
- `__experimentalToolsPanel`
- `__experimentalToolsPanelItem`
- `__experimentalUnitControl`

These APIs may change in future WordPress versions. Always check WordPress documentation for updates.

---

## Validation

Before building, validate schema with:

```bash
npm run schema:validate
```

This checks:
- ✓ All required fields present
- ✓ Valid control types
- ✓ Valid Gutenberg control mappings
- ✓ No circular dependencies
- ✓ Proper CSS variable naming
- ✓ Valid CSS units in `availableUnits`

---

## Migration Checklist

- [ ] Extend accordion schema with new fields
- [ ] Update schema-compiler.js to generate new files
- [ ] Run `npm run schema:build`
- [ ] Update block.json with generated supports
- [ ] Add translator hook to edit.js
- [ ] Add auto-generated UI component to edit.js
- [ ] Test sidebar displays correctly
- [ ] Test theme system still works
- [ ] Test Gutenberg native controls sync
- [ ] Test reset buttons work
- [ ] Test collapsible sections work
- [ ] Run full build: `npm run build`
- [ ] Test in WordPress editor

---

## Troubleshooting

**Sidebar controls not appearing:**
- Check `visibleOnSidebar: true` on attribute
- Check control type is valid
- Check schema compiled successfully

**Gutenberg controls not syncing:**
- Check `gutenbergControl` field is set
- Verify value format matches schema type
- Check translator hook is imported in edit.js
- Verify nested ↔ flat conversion is working

**Theme system not working:**
- Check `themeable: true` on attribute
- Verify `cssVar` is set
- Ensure translator doesn't override theme values

**Reset button not appearing:**
- Check `resetButton: true` on sub-group attribute
- Verify all items in sub-group have onDeselect logic

**hasValue not working correctly:**
- Ensure comparison is against schema default value
- Check that value is not just `undefined` but also not equal to default

---

## Future Enhancements

- Custom control components
- Conditional visibility (show control only if X is true)
- Dynamic preset generation
- Per-control validation
- Control dependencies
