# Icon Panel Generation and Runtime Pipeline

This document is the single technical source of truth for how the Icon Panel is defined, generated, and rendered for accordion/tabs/TOC blocks. It describes the full build-time pipeline (schema -> macro expansion -> generated artifacts) and the runtime pipeline (editor UI -> attributes -> CSS variables -> frontend).

## Scope
- Blocks: `accordion`, `tabs`, `toc`.
- UI: inspector sidebar Icon panel and its controls.
- Data: icon attributes, responsive values, theme/cascade behavior.
- Styling: editor sidebar styles and frontend icon styles.

## Key Files (roles)
- Schema input:
  - `schemas/accordion.json`
  - `schemas/tabs.json`
  - `schemas/toc.json`
- Macro expansion + generation:
  - `build-tools/schema-compiler.js` (reads schema, expands icon-panel macro, writes generated files)
- Expanded schema (runtime editor input):
  - `schemas/accordion-schema-autogenerated.json`
  - `schemas/tabs-schema-autogenerated.json`
  - `schemas/toc-schema-autogenerated.json`
- Block attribute definitions (WordPress attribute registration):
  - `blocks/accordion/src/accordion-attributes.js`
  - `blocks/tabs/src/tabs-attributes.js`
  - `blocks/toc/src/toc-attributes.js`
- Control config (labels, defaults, allowed positions):
  - `shared/src/config/control-config-generated.js`
- CSS variable mappings:
  - `shared/src/config/css-var-mappings-generated.js`
- CSS var builders:
  - `shared/src/styles/accordion-css-vars-generated.js`
  - `shared/src/styles/tabs-css-vars-generated.js`
  - `shared/src/styles/toc-css-vars-generated.js`
  - `shared/src/styles/accordion-frontend-css-vars-generated.js` (and tabs/toc equivalents)
- Panel assembly:
  - `shared/src/components/SchemaPanels.js`
  - `shared/src/components/controls/IconPanel.js`
  - `shared/src/components/controls/IconPicker.js`
  - `shared/src/components/controls/UtilityBar.js`
  - `shared/src/hooks/useResponsiveDevice.js`
  - `shared/src/utils/responsive-device.js`
- Editor styling:
  - `blocks/accordion/src/editor.scss` (imports `shared/src/components/controls/SidebarStyling.scss`)
  - `shared/src/components/controls/IconPicker.scss`
  - `shared/src/components/controls/SidebarStyling.scss`
- Frontend styling + behavior:
  - `blocks/accordion/src/style.scss` (and tabs/toc equivalents)
  - `blocks/accordion/src/frontend.js` (and tabs/toc equivalents)

## Quick Reference (Accordion only)

| Item | Value / Location | Notes |
| --- | --- | --- |
| Macro entry | `schemas/accordion.json` -> `attributes.titleIcon` | `type: "icon-panel"` |
| cssVar prefix | `accordion-icon` | Expands to `--accordion-icon-*` |
| appliesToElement | `icon` | CSS target for icon vars |
| Generated attributes | `showIcon`, `useDifferentIcons`, `iconPosition`, `iconRotation`, `iconInactive*`, `iconActive*` | 18 total |
| Editor panel | `shared/src/components/controls/IconPanel.js` | Used when group id is `icon` |
| Icon picker | `shared/src/components/controls/IconPicker.js` | `kind: char | image | library` |
| CSS var mapping | `shared/src/config/css-var-mappings-generated.js` | Accordion mappings for icon vars |
| Editor CSS vars | `shared/src/styles/accordion-css-vars-generated.js` | Emits base + tablet/mobile vars |
| Frontend CSS | `blocks/accordion/src/style.scss` | Uses `--accordion-icon-*` |

## Accordion Icon Panel UX (Product Requirement)

This section captures the intended UX requirements for the accordion Icon panel. It is the target behavior even if the current implementation differs.

- Controls order (top to bottom):
  - `Show Icon` toggle.
  - `Icon Position` control.
  - `Different icons for open/close` toggle.
  - `Rotation Animation` slider with label text: "Animation rotation added when open".
- If "Different icons for open/close" is **off**:
  - Panel shows a single "Icon Settings" block.
  - Includes `Icon Picker` (Character/Image/Library).
  - Includes `Icon Color`, `Icon Size`, `Offset X`, `Offset Y`.
  - Includes `Rotation Angle` (initial rotation) after icon color.
  - `Icon Size`, `Offset X`, `Offset Y` are responsive.
  - Rotation animation applies on open/close in addition to the initial rotation.
  - Disabling dual icon mode does not clear the open icon settings.
- If "Different icons for open/close" is **on**:
  - The settings are split into two tabs: `Closed` and `Open`.
  - Editor preview follows the selected tab (inactive/active) without a separate toggle.
  - Both tabs expose the same controls (Icon Picker + color/rotation/size/offset).
  - The `Open` state inherits the `Closed` state values by default until overridden.
  - Rotation animation still applies as the transition between closed and open states.
- Icon kinds can differ between states (char/image/library), and each state can have unique color, size, and offsets.

### Known gaps vs requirement (current code)
~~- Lucide icons are not appearing in the library picker (empty list).~~ **FIXED 2026-01-01**
~~- Rotation control is hidden when `useDifferentIcons` is enabled.~~ **FIXED 2026-01-01**

See `docs/ICON_PANEL_FIXES_IMPLEMENTATION_PLAN.md` for fix details.

## 1. Schema Definition (icon-panel macro)

### Where the macro lives
Each block schema contains one `type: "icon-panel"` entry:
- Accordion: `titleIcon` in `schemas/accordion.json`
- Tabs: `tabIcon` in `schemas/tabs.json`
- TOC: `tocIcon` in `schemas/toc.json`

### Macro shape (schema input)
The schema entry is minimal and declarative. Example (accordion):
```
"titleIcon": {
  "type": "icon-panel",
  "order": 2,
  "cssVar": "accordion-icon",
  "appliesToElement": "icon",
  "themeable": true,
  "outputsCSS": false,
  "default": {
    "position": "right",
    "rotation": "180deg",
    "inactive": {
      "source": { "icon-type": "char", "value": "<default-char>" },
      "color": "#333333",
      "size": "16px",
      "maxSize": "24px",
      "offsetX": "0px",
      "offsetY": "0px"
    }
  }
}
```
Notes:
- `cssVar` is the base prefix used to build icon CSS variables.
- `appliesToElement` is used as the target element name for CSS variable application.
- `default.active` is optional. If missing, active defaults are treated as "inherit" by the macro (see expansion logic below).
- The default inactive `source` uses `"icon-type"` which is normalized to `{ kind, value }` by the macro expander.

## 2. Macro Expansion (build-tools/schema-compiler.js)

### How schemas are read
Build step: `npm run schema:build`.
1. `loadSchema(blockType)` reads the JSON file from `schemas/*.json`.
2. `processAttributes()` walks `schema.attributes`:
   - If `attr.type === "icon-panel"`, it calls `expandIconPanelMacro(name, attr, blockType)`.
   - Otherwise, attributes are passed through unchanged.
3. The expanded schema is written to `schemas/<block>-schema-autogenerated.json`.

### Expansion logic and defaults
Function: `expandIconPanelMacro(macroName, macro, blockType)` in `build-tools/schema-compiler.js`.

Defaults and inferred fields:
- `group`: defaults to `"icon"` if missing.
- `label`: derived from macro name if missing (e.g., `titleIcon` -> `Title Icon`).
- `description`: defaults to `Icon settings for ${blockType}`.
- `positioningProfile`: defaults to `blockType`, used to compute allowed icon positions.
- `appliesToElement`: defaults to `macro.appliesToElement`, then `macro.appliesTo`, then `"icon"`.
- `responsiveAttrs`: always `["size", "maxSize", "offsetX", "offsetY"]`.
- `allowedPositions`: from `POSITIONING_PROFILES` in `schema-compiler.js`:
  - Accordion, TOC: `left`, `right`, `box-left`, `box-right`
  - Tabs: `left`, `right`

Active defaults:
- If `default.active` is missing, the macro treats active defaults as "inherit".
- Implementation detail: `getDefault()` returns `null` for active keys, but each attribute also has a fallback (e.g., color -> `#333333`). This means active defaults are still set unless the UI explicitly nulls them.
- The UI (`IconPanel`) clears active values when `useDifferentIcons` is turned off.

### Generated attributes (16 total)
The macro expands into the following attributes. `cssVar` values shown are for accordion; tabs/toc use `--tabs-...` or `--toc-...` prefixes.

Global icon controls:
1. `showIcon`
   - type: boolean
   - default: `true`
   - control: `ToggleControl`
   - cssVar: `--accordion-icon-display`
   - cssProperty: `display`
   - cssValueMap: `{ true: "inline-flex", false: "none" }`
   - outputsCSS: `true`
2. `useDifferentIcons`
   - type: boolean
   - default: `false`
   - control: `ToggleControl`
   - outputsCSS: `false`
   - showWhen: `showIcon === true`
3. `iconPosition`
   - type: string
   - default: `defaults.position || "right"`
   - control: `IconPositionControl`
   - allowedPositions: derived from `positioningProfile`
   - outputsCSS: `false`
   - showWhen: `showIcon === true`
4. `iconRotation`
   - type: string
   - default: `defaults.rotation || "180deg"`
   - control: `SliderWithInput`
   - cssVar: `--accordion-icon-rotation`
   - cssProperty: `transform`
   - outputsCSS: `true`
   - showWhen: `showIcon === true`

Inactive (closed) state:
5. `iconInactiveSource`
   - type: object
   - default: normalized to `{ kind, value }` from `default.inactive.source`
   - control: `IconPicker`
   - subgroup: `inactive`
6. `iconInactiveColor`
   - type: string
   - default: `default.inactive.color || "#333333"`
   - control: `ColorControl`
   - cssVar: `--accordion-icon-color`
   - cssProperty: `color`
   - conditionalRender: `iconInactiveSource.kind !== "image"`
7. `iconInactiveRotation`
   - type: string
   - default: `default.inactive.rotation || "0deg"`
   - control: `SliderWithInput`
   - cssVar: `--accordion-icon-initial-rotation`
   - cssProperty: `transform`
8. `iconInactiveSize`
   - type: string
   - default: `default.inactive.size || "16px"`
   - control: `SliderWithInput`
   - cssVar: `--accordion-icon-size`
   - cssProperty: `font-size`
   - responsive: `true`
   - conditionalRender: `iconInactiveSource.kind !== "image"`
9. `iconInactiveMaxSize`
   - type: string
   - default: `default.inactive.maxSize || "24px"`
   - control: `SliderWithInput`
   - cssVar: `--accordion-icon-max-size`
   - cssProperty: `max-width`
   - responsive: `true`
   - conditionalRender: `iconInactiveSource.kind === "image"`
10. `iconInactiveOffsetX`
   - type: string
   - default: `default.inactive.offsetX || "0px"`
   - control: `SliderWithInput`
   - cssVar: `--accordion-icon-offset-x`
   - cssProperty: `left`
   - responsive: `true`
11. `iconInactiveOffsetY`
    - type: string
    - default: `default.inactive.offsetY || "0px"`
    - control: `SliderWithInput`
    - cssVar: `--accordion-icon-offset-y`
    - cssProperty: `top`
    - responsive: `true`

Active (open) state:
12. `iconActiveSource`
    - type: object
    - default: normalized to `{ kind, value }`
    - control: `IconPicker`
    - subgroup: `active`
    - showWhen: `showIcon === true && useDifferentIcons === true`
13. `iconActiveColor`
    - type: string
    - default: `default.active.color || "#333333"` (or fallback)
    - control: `ColorControl`
    - cssVar: `--accordion-icon-active-color`
    - cssProperty: `color`
    - conditionalRender: `iconActiveSource.kind !== "image"`
    - showWhen: `showIcon === true && useDifferentIcons === true`
14. `iconActiveRotation`
    - type: string
    - default: `default.active.rotation || "0deg"` (or fallback)
    - control: `SliderWithInput`
    - cssVar: `--accordion-icon-active-initial-rotation`
    - cssProperty: `transform`
    - showWhen: `showIcon === true && useDifferentIcons === true`
15. `iconActiveSize`
    - type: string
    - default: `default.active.size || "16px"` (or fallback)
    - control: `SliderWithInput`
    - cssVar: `--accordion-icon-active-size`
    - cssProperty: `font-size`
    - responsive: `true`
    - conditionalRender: `iconActiveSource.kind !== "image"`
    - showWhen: `showIcon === true && useDifferentIcons === true`
16. `iconActiveMaxSize`
    - type: string
    - default: `default.active.maxSize || "24px"` (or fallback)
    - control: `SliderWithInput`
    - cssVar: `--accordion-icon-active-max-size`
    - cssProperty: `max-width`
    - responsive: `true`
    - conditionalRender: `iconActiveSource.kind === "image"`
    - showWhen: `showIcon === true && useDifferentIcons === true`
17. `iconActiveOffsetX`
    - type: string
    - default: `default.active.offsetX || "0px"` (or fallback)
    - control: `SliderWithInput`
    - cssVar: `--accordion-icon-active-offset-x`
    - cssProperty: `left`
    - responsive: `true`
    - showWhen: `showIcon === true && useDifferentIcons === true`
18. `iconActiveOffsetY`
    - type: string
    - default: `default.active.offsetY || "0px"` (or fallback)
    - control: `SliderWithInput`
    - cssVar: `--accordion-icon-active-offset-y`
    - cssProperty: `top`
    - responsive: `true`
    - showWhen: `showIcon === true && useDifferentIcons === true`

Note: The macro expansion code returns 18 attributes (4 global + 7 inactive + 7 active). The header comment in `build-tools/schema-compiler.js` may be outdated.

### Schema Compiler showWhen Logic Implementation

The `expandIconPanelMacro` function in `build-tools/schema-compiler.js` generates `showWhen` conditions for each attribute to control visibility based on other attributes.

#### Global Attributes showWhen Rules

```javascript
// 1. showIcon - always visible (no showWhen)
expanded.showIcon = {
  type: 'boolean',
  default: true,
  control: 'ToggleControl',
  // ... no showWhen - always visible
};

// 2. useDifferentIcons - only visible when icon is shown
expanded.useDifferentIcons = {
  type: 'boolean',
  default: false,
  control: 'ToggleControl',
  showWhen: {
    showIcon: [true]  // Only show when icon is enabled
  }
};

// 3. iconPosition - only visible when icon is shown
expanded.iconPosition = {
  type: 'string',
  default: defaults.position || 'right',
  control: 'IconPositionControl',
  showWhen: {
    showIcon: [true]  // Only show when icon is enabled
  }
};

// 4. iconRotation - visible when icon is shown
// NOTE: Previously had useDifferentIcons: [false], removed in 2026-01-01 fix
expanded.iconRotation = {
  type: 'string',
  default: defaults.rotation || '180deg',
  control: 'SliderWithInput',
  showWhen: {
    showIcon: [true]
    // REMOVED: useDifferentIcons: [false]
    // Rotation now always visible when showIcon is true
  }
};
```

**showWhen Semantics:**
- `showIcon: [true]` means "only show this control when showIcon attribute equals true"
- Multiple keys create an AND condition (all must match)
- Array values create an OR condition (any value matches)
- Example: `showWhen: { showIcon: [true], useDifferentIcons: [false, null] }` means "show when icon is on AND useDifferentIcons is false or null"

#### State Attributes showWhen Rules

The `generateStateAttributes` helper function creates showWhen rules for inactive and active state attributes:

```javascript
const generateStateAttributes = (state) => {
  // Base showWhen for all icon controls
  const baseShowWhen = {
    showIcon: [true]
  };

  // State-specific showWhen
  const stateShowWhen = state === 'inactive'
    ? baseShowWhen  // Inactive: just showIcon
    : { ...baseShowWhen, useDifferentIcons: [true] };  // Active: showIcon AND useDifferentIcons

  return {
    // Source (IconPicker)
    [`${statePrefix}Source`]: {
      type: 'object',
      control: 'IconPicker',
      showWhen: stateShowWhen
      // inactive: { showIcon: [true] }
      // active:   { showIcon: [true], useDifferentIcons: [true] }
    },

    // Color, Size, MaxSize, OffsetX, OffsetY all use same stateShowWhen
    [`${statePrefix}Color`]: {
      showWhen: stateShowWhen
    },
    // ... etc
  };
};
```

**Inactive vs Active:**
- **Inactive attributes** (`iconInactive*`): Only require `showIcon: [true]`
  - Always visible when icon is shown (in both single and dual icon modes)
  - In single icon mode, these are the only icon attributes shown
  - In dual icon mode, these appear in the "Inactive (Closed)" tab

- **Active attributes** (`iconActive*`): Require `showIcon: [true]` AND `useDifferentIcons: [true]`
  - Only visible when dual icon mode is enabled
  - Appear in the "Active (Open)" tab
  - Hidden completely in single icon mode

#### Important Note: showWhen vs Actual UI Behavior

**Schema showWhen is NOT enforced by IconPanel:**

The `showWhen` conditions in the schema are metadata that describe when attributes should be visible. However, IconPanel.js **does NOT read or enforce these conditions** from the schema. Instead, it implements its own conditional rendering logic:

```javascript
// IconPanel implements its own visibility logic, NOT from schema
{/* Rotation Animation - always visible when icon shown (ignores schema showWhen) */}
<div style={ { marginTop: '16px', marginBottom: '16px' } }>
  <SliderWithInput
    label="Rotation Animation"
    // ... rendered based on component logic, not schema showWhen
  />
</div>

{/* Active attributes - only shown in DualIconMode */}
{ useDifferentIcons ? (
  <DualIconMode /* active attributes appear here */ />
) : (
  <SingleIconMode /* only inactive attributes appear here */ />
) }
```

**Why showWhen exists:**
- Documents intended visibility behavior
- Used by ControlRenderer (generic control renderer for non-icon panels)
- Provides metadata for potential future auto-generated UIs
- Helps developers understand attribute relationships

**Why IconPanel doesn't use it:**
- IconPanel has complex custom UI (tabs, conditional controls, responsive wrappers)
- showWhen is designed for simple show/hide, not complex nested structures
- IconPanel's visibility logic is more nuanced (e.g., rotation help text changes, not just visibility)

#### Example: Full showWhen Set for Accordion Icons

After macro expansion, the accordion gets these showWhen conditions:

```javascript
{
  showIcon: {}, // No showWhen - always visible

  useDifferentIcons: {
    showWhen: { showIcon: [true] }
  },

  iconPosition: {
    showWhen: { showIcon: [true] }
  },

  iconRotation: {
    showWhen: { showIcon: [true] }
  },

  // Inactive state (always visible when icon shown)
  iconInactiveSource: {
    showWhen: { showIcon: [true] }
  },
  iconInactiveColor: {
    showWhen: { showIcon: [true] }
  },
  iconInactiveSize: {
    showWhen: { showIcon: [true] }
  },
  iconInactiveMaxSize: {
    showWhen: { showIcon: [true] }
  },
  iconInactiveOffsetX: {
    showWhen: { showIcon: [true] }
  },
  iconInactiveOffsetY: {
    showWhen: { showIcon: [true] }
  },

  // Active state (only visible when dual icon mode enabled)
  iconActiveSource: {
    showWhen: { showIcon: [true], useDifferentIcons: [true] }
  },
  iconActiveColor: {
    showWhen: { showIcon: [true], useDifferentIcons: [true] }
  },
  iconActiveSize: {
    showWhen: { showIcon: [true], useDifferentIcons: [true] }
  },
  iconActiveMaxSize: {
    showWhen: { showIcon: [true], useDifferentIcons: [true] }
  },
  iconActiveOffsetX: {
    showWhen: { showIcon: [true], useDifferentIcons: [true] }
  },
  iconActiveOffsetY: {
    showWhen: { showIcon: [true], useDifferentIcons: [true] }
  }
}
```

## 3. Generated Artifacts (build output)

### Expanded schema (editor runtime)
`schemas/<block>-schema-autogenerated.json` is what the editor imports (e.g., `blocks/accordion/src/edit.js` uses `schemas/accordion-schema-autogenerated.json`).

### Block attributes
`blocks/<block>/src/<block>-attributes.js` is generated from the expanded schema and is passed to `registerBlockType` in `blocks/<block>/src/index.js`.
Important: this overrides the attributes in `blocks/<block>/block.json`. The generated attributes file is the true runtime source.

### Control configuration
`shared/src/config/control-config-generated.js`:
- Provides defaults, options, and allowed positions.
- `IconPositionControl` reads allowed positions from here.
- `IconPanel` uses `getNumericDefault()` from here to extract numeric values from strings.

### CSS variable mappings
`shared/src/config/css-var-mappings-generated.js`:
- Maps each icon attribute to a CSS variable (`--accordion-icon-*`, `--tabs-icon-*`, `--toc-icon-*`).
- `showIcon` uses `cssValueMap` to map boolean -> `inline-flex`/`none`.

### CSS var builders
- `buildEditorCssVars()` in `shared/src/styles/<block>-css-vars-generated.js`:
  - Emits CSS vars for editor preview.
  - If an attribute is responsive (has `tablet`/`mobile` keys), it emits `--var`, `--var-tablet`, `--var-mobile`.
- `buildFrontendCssVars()` in `shared/src/styles/<block>-frontend-css-vars-generated.js`:
  - Emits CSS vars for frontend (uses `attributes.customizations`).

## 4. Editor Panel Assembly (runtime UI)

### Panel routing
`blocks/<block>/src/edit.js` renders the inspector:
1. `TabbedInspector` hosts "Settings" and "Appearance".
2. `AppearancePanels` renders `SchemaPanels` with `tab="appearance"`.
3. `SchemaPanels` inspects schema groups. If `groupId === "icon"`, it renders `IconPanel` instead of the generic panel.

### IconPanel composition (control building blocks)
File: `shared/src/components/controls/IconPanel.js`.

Main building blocks:
- `PanelBody` (container)
- `ToggleControl` (show icon, different icons)
- `IconPositionControl` (position selector)
- `SliderWithInput` (rotation animation, initial rotation, size, max size, offsets)
- `IconPicker` (character/image/library)
- `ColorControl` (icon color for char/library)
- `BaseControl` + `UtilityBar` (responsive device switching and reset for size/offset)
- `TabPanel` (inactive/active tabs when `useDifferentIcons` is true)

Control flow:
- `showIcon` toggle gates the entire panel (if false, only the toggle is shown).
- `useDifferentIcons` toggle:
  - When turned on: shows "Inactive" and "Active" tabs.
  - When turned off: returns editor preview to the inactive icon while preserving `iconActive*` values.
- `iconRotation` slider is always shown and controls animation rotation.
- Per-state `Rotation Angle` sliders control initial rotation for inactive/active icons.
- `IconPositionControl` uses allowed positions from `control-config-generated.js`.
- `IconPicker` output is `{ kind: "char" | "image" | "library", value: string }`.
- Tab selection updates the editor-only preview state (no separate toggle).

Important UI vs schema differences:
- IconPanel does not read schema `min/max/step` or `showWhen` for icon controls.
- Slider ranges in IconPanel are hardcoded (e.g., rotation -180..180, offsets -50..50, image size 16..128).
- Schema `showWhen` and `conditionalRender` are still generated, but they only apply if the icon controls are rendered by `ControlRenderer` (not the case for group `icon`).

## 4.1 Reusing IconPanel for Other Elements and Blocks

The icon panel is portable. It can target any schema element and any DOM subtree as long as you wire the schema macro, UI routing, markup, and CSS vars together.

### A) Schema-level reuse (target another element)
Use the `type: "icon-panel"` macro on a different schema attribute and point it at the element you want:
```json
"buttonIcon": {
  "type": "icon-panel",
  "order": 3,
  "cssVar": "accordion-button-icon",
  "appliesToElement": "buttonIcon",
  "themeable": true,
  "outputsCSS": false,
  "default": {
    "position": "right",
    "rotation": "180deg",
    "inactive": { "source": { "icon-type": "char", "value": "▾" } }
  }
}
```
Notes:
- `cssVar` becomes the prefix for generated variables (e.g., `--accordion-button-icon-*`).
- `appliesToElement` must match the element name in schema styles (the element the CSS vars are applied to).
- Use `positioningProfile` if the icon should allow different positions than the block default (see `POSITIONING_PROFILES` in `build-tools/schema-compiler.js`).

### B) UI routing reuse (make the editor show IconPanel)
`SchemaPanels` currently renders `IconPanel` only when `groupId === "icon"`.
Options:
- Set the macro `group` to `"icon"` if you want to reuse the existing routing.
- For multiple icon panels or a different group name, update `shared/src/components/SchemaPanels.js` to detect `attr.type === "icon-panel"` and render `IconPanel` for each macro instance.

### C) DOM + CSS reuse (frontend + editor)
You must render the icon markup and consume the generated CSS vars:
1. Add the icon markup in `blocks/<block>/src/edit.js` and `blocks/<block>/src/save.js`.
2. Apply CSS that references the new vars (e.g., `color: var(--accordion-button-icon-color)`).
3. Ensure the element class/selector matches the element targeted by `appliesToElement`.

### D) Frontend var emission (customizations)
`buildFrontendCssVars()` only outputs CSS vars for values present in `attributes.customizations`. That is expected:
- The icon attributes are themeable, so they only emit inline vars when customized.
- If a value should always be emitted, it must be treated as non-themeable or written into CSS defaults.

### E) UI constraints to keep in mind
- The current `IconPanel` ignores schema ranges and `showWhen`. If another element needs different ranges or visibility logic, add a variant panel or use `ControlRenderer`.
- `useDifferentIcons` is UI-only state for preview; it does not change frontend rendering unless the attributes are saved.

## 5. IconPicker (selection UI)
File: `shared/src/components/controls/IconPicker.js`.

Output format:
- `kind: "char"` -> `value` is a string character
- `kind: "image"` -> `value` is image URL (from WP Media Library)
- `kind: "library"` -> `value` is `"dashicons:icon-name"` or `"lucide:IconName"`

Tabs:
- Character: text input + quick-pick list (default char is defined in schema)
- Image: WP MediaUpload (stores URL)
- Library: Dashicons + Lucide icons

Styling:
- `shared/src/components/controls/IconPicker.scss` provides grid and tabs styling.

### IconPicker Implementation Details

#### Lucide Icon Filtering
The `getLucideIcons()` function filters Lucide-react exports to show only valid icon components:

```javascript
const getLucideIcons = () => {
  const allKeys = Object.keys( LucideIcons );
  console.log('Total Lucide exports:', allKeys.length);

  const filtered = allKeys.filter(
    ( name ) =>
      // Exclude utility functions
      ! name.startsWith( 'create' ) &&
      name !== 'Icon' &&
      name !== 'default' &&
      // Check if it's a valid React component
      typeof LucideIcons[ name ] === 'function' &&
      // Icon components start with uppercase
      /^[A-Z]/.test( name )
  );

  console.log('Filtered Lucide icons:', filtered.length);
  console.log('Sample icons:', filtered.slice(0, 10));

  return filtered;
};
```

**Filtering Logic:**
- Excludes `createLucideIcon` and other utility functions
- Excludes the base `Icon` component and default exports
- Only includes functions (React components)
- Only includes names starting with uppercase letter (e.g., `ChevronDown`, `Plus`)
- Typically returns 200+ icons

**Console Output:**
When the Library tab is opened, the console logs:
```
Total Lucide exports: 250
Filtered Lucide icons: 234
Sample icons: ['Activity', 'Airplay', 'AlertCircle', 'AlertOctagon', ...]
```

#### Dashicons List
Hardcoded array of 146 commonly used WordPress Dashicons:
```javascript
const DASHICONS = [
  'arrow-down-alt2', 'arrow-right-alt2', 'arrow-up-alt2', 'arrow-left-alt2',
  'arrow-down', 'arrow-right', 'arrow-up', 'arrow-left',
  'plus', 'plus-alt2', 'minus', 'no-alt',
  // ... 134 more icons
];
```

#### LucideIcon Rendering Component
Helper component that renders Lucide icons with error handling:

```javascript
function LucideIcon( { name, size = 24 } ) {
  const IconComponent = LucideIcons[ name ];

  if ( ! IconComponent ) {
    console.warn( `Lucide icon not found: ${name}` );
    return null;
  }

  return <IconComponent size={ size } />;
}
```

**Error Handling:**
- Logs warning if icon component not found
- Returns null to prevent rendering errors
- Accepts dynamic `size` prop (default 24px)

#### LibraryTab Implementation
The Library tab manages icon library selection and rendering:

```javascript
function LibraryTab( { value, onChange } ) {
  const [ search, setSearch ] = useState( '' );
  const [ library, setLibrary ] = useState( 'dashicons' );

  const currentIcon = value?.kind === 'library' ? value.value : '';
  const LUCIDE_ICONS = getLucideIcons();

  const handleSelect = ( iconName ) => {
    onChange( {
      kind: 'library',
      value: `${ library }:${ iconName }`,
    } );
  };

  const filteredIcons =
    library === 'dashicons'
      ? DASHICONS.filter( ( icon ) =>
          icon.toLowerCase().includes( search.toLowerCase() )
        )
      : LUCIDE_ICONS.filter( ( icon ) =>
          icon.toLowerCase().includes( search.toLowerCase() )
        );

  return (
    <div className="icon-picker-library-tab">
      <div className="library-selector">
        <ButtonGroup>
          <Button
            variant={ library === 'dashicons' ? 'primary' : 'secondary' }
            onClick={ () => setLibrary( 'dashicons' ) }
          >
            Dashicons (WP)
          </Button>
          <Button
            variant={ library === 'lucide' ? 'primary' : 'secondary' }
            onClick={ () => setLibrary( 'lucide' ) }
          >
            Lucide Icons
          </Button>
        </ButtonGroup>
      </div>

      <SearchControl
        value={ search }
        onChange={ setSearch }
        placeholder="Search icons..."
      />

      <div className="icon-grid">
        { filteredIcons.slice( 0, 200 ).map( ( iconName ) => {
          const isSelected = currentIcon === `${ library }:${ iconName }`;
          return (
            <button
              key={ iconName }
              className={ `icon-button ${ isSelected ? 'selected' : '' }` }
              onClick={ () => handleSelect( iconName ) }
              title={ iconName }
              type="button"
            >
              { library === 'dashicons' ? (
                <Dashicon icon={ iconName } size={ 24 } />
              ) : (
                <LucideIcon name={ iconName } size={ 24 } />
              ) }
            </button>
          );
        } ) }
      </div>

      { filteredIcons.length === 0 && (
        <p className="no-results">No icons found matching "{ search }"</p>
      ) }
      { filteredIcons.length > 200 && (
        <p className="results-limit">
          Showing first 200 of { filteredIcons.length } results. Try searching
          to narrow down.
        </p>
      ) }
    </div>
  );
}
```

**Key Features:**
- State management for library selection (`dashicons` vs `lucide`)
- Live search filtering (case-insensitive)
- Icon grid rendering (max 200 at once for performance)
- Selected state highlighting
- Empty state and pagination messages

#### Output Value Format
When an icon is selected, the value format is:

```javascript
// Character icon
{ kind: 'char', value: '▾' }

// Image icon
{ kind: 'image', value: 'https://example.com/icon.png' }

// Dashicon
{ kind: 'library', value: 'dashicons:arrow-down-alt2' }

// Lucide icon
{ kind: 'library', value: 'lucide:ChevronDown' }
```

The `kind` determines which controls are shown (color/size for char/library, maxSize for image).

## 6. Responsive Values (icons)

### Storage format (flat base)
Responsive values use a flat object:
```
{
  value: 16,
  unit: "px",
  tablet: { value: 14, unit: "px" },
  mobile: { value: 12, unit: "px" }
}
```
There is no `global` key; the base lives at the root.

### UI mechanics
IconPanel uses `UtilityBar` directly:
- Uses global device state from `useResponsiveDevice()`.
- Mobile inherits tablet; tablet inherits base (inheritance logic in `getResponsiveValue()` helper).
- `setResponsiveValue()` in IconPanel creates/updates the flat structure.
- `getResponsiveValue()` in IconPanel converts strings like `"16px"` to numbers for sliders using `getNumericDefault()`.

### Responsive Controls Pattern (canBeResponsive)

**IMPORTANT:** As of 2026-01-03, icon responsive controls use the "canBeResponsive" pattern, matching the behavior of other panels like Typography, Padding, and Margins.

#### Initial State: Collapsed
Icon responsive controls (Size, Max Size, Offset X, Offset Y) start **collapsed** by default:
- Shows only a small "Enable Responsive" icon button + reset button
- No device switcher visible initially
- Matches behavior of other responsive controls in the system

#### Expanding Responsive Mode
When the user clicks "Enable Responsive":
1. The control expands to show the full device switcher (Global/Tablet/Mobile)
2. The `responsiveEnabled` attribute object is updated to track this state
3. User can now set different values per device breakpoint

#### Implementation Details

**BaseControl + UtilityBar Pattern:**
Icon responsive controls use BaseControl with UtilityBar in the label, following the same pattern as SpacingControl and other full controls:
```javascript
<BaseControl
  label={
    <Flex justify="space-between" style={{ width: '100%' }}>
      <span>Icon Size</span>
      <UtilityBar
        canBeResponsive={true}
        isResponsiveEnabled={attributes.responsiveEnabled?.iconInactiveSize || false}
        currentDevice={currentDevice}
        onResponsiveToggle={() => onResponsiveToggle('iconInactiveSize', true)}
        onReset={() => onChange(getResponsiveResetUpdate('iconInactiveSize', '16px'))}
        resetDisabled={!attributes.iconInactiveSize && currentDevice === 'global'}
      />
    </Flex>
  }
  __nextHasNoMarginBottom
>
  <SliderWithInput
    value={parseValueWithUnit(getResponsiveValue(attributes.iconInactiveSize, currentDevice) || '16px')}
    onChange={(val) => {
      onChange({
        iconInactiveSize: setResponsiveValue(attributes.iconInactiveSize, currentDevice, val)
      });
    }}
    min={8}
    max={64}
    units={['px', 'rem', 'em']}
    responsive={false}
    canBeResponsive={false}
  />
</BaseControl>
```

**State Tracking:**
The `responsiveEnabled` attribute is an object that tracks which responsive controls are currently expanded:
```javascript
// Default state (all collapsed)
responsiveEnabled: {
  iconInactiveSize: false,
  iconInactiveMaxSize: false,
  iconInactiveOffsetX: false,
  iconInactiveOffsetY: false,
  iconActiveSize: false,
  iconActiveMaxSize: false,
  iconActiveOffsetX: false,
  iconActiveOffsetY: false,
  // ... other responsive attributes
}

// After user enables responsive mode for size
responsiveEnabled: {
  iconInactiveSize: true,  // Now expanded
  iconInactiveOffsetX: false,  // Still collapsed
  // ...
}
```

**Toggle Handler:**
IconPanel includes a helper function to toggle responsive mode:
```javascript
const handleResponsiveToggle = (attributeName, enabled) => {
  onChange({
    responsiveEnabled: {
      ...(attributes.responsiveEnabled || {}),
      [attributeName]: enabled,
    },
  });
};
```

#### UtilityBar Integration

IconPanel uses `UtilityBar` directly to provide unified controls:
- **Collapsed state:** Shows responsive icon button + reset button
- **Expanded state:** Shows device switcher (Global/Tablet/Mobile) + reset button
- Consistent with all other responsive controls (padding, margins, typography)

Files involved:
- `shared/src/components/controls/UtilityBar.js` - Unified control bar
- `shared/src/components/controls/IconPanel.js` - Icon-specific implementation with direct UtilityBar usage

#### Why This Matters

**User Experience:**
- Cleaner UI: Controls start compact and only expand when needed
- Consistent behavior across all panels
- Reduces visual clutter in the sidebar

**Implementation Consistency:**
- Schema-driven controls (via ControlRenderer) automatically get this pattern
- Custom panels like IconPanel must manually implement it
- All responsive controls should follow the same pattern

#### Affected Controls in IconPanel

All icon size and offset controls use this pattern:

**Inactive (Closed) State:**
1. Icon Size (char/library only) - `iconInactiveSize`
2. Image Size (images only) - `iconInactiveMaxSize`
3. Offset X - `iconInactiveOffsetX`
4. Offset Y - `iconInactiveOffsetY`

**Active (Open) State:**
5. Icon Size (char/library only) - `iconActiveSize`
6. Image Size (images only) - `iconActiveMaxSize`
7. Offset X - `iconActiveOffsetX`
8. Offset Y - `iconActiveOffsetY`

Each control starts collapsed and can be independently expanded by the user.

#### Critical Implementation Details

**Prop Passing Pattern:**

Since IconPanel has a nested component structure (IconPanel → SingleIconMode/DualIconMode → IconStateControls), callback functions must be properly passed through the component tree:

```javascript
// In IconPanel component
const handleResponsiveToggle = ( attributeName, enabled ) => {
  handleChange( {
    responsiveEnabled: {
      ...( attributes.responsiveEnabled || {} ),
      [ attributeName ]: enabled,
    },
  } );
};

// Pass to child components
<SingleIconMode
  attributes={ attributes }
  onChange={ handleChange }
  onResponsiveToggle={ handleResponsiveToggle }  // ← Must pass through
/>

<DualIconMode
  attributes={ attributes }
  onChange={ handleChange }
  onResponsiveToggle={ handleResponsiveToggle }  // ← Must pass through
/>
```

**Child Components Must Use Props:**

Child components (SingleIconMode, IconStateControls) receive `onChange` and `onResponsiveToggle` as props, NOT the original `handleChange` or `handleResponsiveToggle` function names:

```javascript
// CORRECT - use the prop name
function SingleIconMode( { onChange, onResponsiveToggle, currentDevice, attributes } ) {
  return (
    <BaseControl
      label={
        <Flex justify="space-between" style={{ width: '100%' }}>
          <span>Icon Size</span>
          <UtilityBar
            canBeResponsive={true}
            isResponsiveEnabled={attributes.responsiveEnabled?.iconInactiveSize || false}
            currentDevice={currentDevice}
            onResponsiveToggle={() => onResponsiveToggle('iconInactiveSize', true)}
            onReset={() => onChange(getResponsiveResetUpdate('iconInactiveSize', '16px'))}
            resetDisabled={!attributes.iconInactiveSize && currentDevice === 'global'}
          />
        </Flex>
      }
      __nextHasNoMarginBottom
    >
      <SliderWithInput
        value={parseValueWithUnit(getResponsiveValue(attributes.iconInactiveSize, currentDevice) || '16px')}
        onChange={(val) => {
          onChange({
            iconInactiveSize: setResponsiveValue(attributes.iconInactiveSize, currentDevice, val)
          });
        }}
        min={8}
        max={64}
        units={['px', 'rem', 'em']}
        responsive={false}
        canBeResponsive={false}
      />
    </BaseControl>
  );
}

// WRONG - these functions don't exist in child component scope
onChange={ () => handleChange(...) }  // ❌ handleChange is undefined
onResponsiveToggle={ () => handleResponsiveToggle(...) }  // ❌ undefined
```

**Common Errors to Avoid:**

1. ❌ Calling `handleChange` directly in child components (it's not in scope)
2. ❌ Calling `handleResponsiveToggle` directly in child components (it's not in scope)
3. ❌ Forgetting to pass `onResponsiveToggle` through DualIconMode to IconStateControls
4. ❌ Passing `label` to SliderWithInput when using BaseControl (BaseControl provides the label)

### Device state
`shared/src/utils/responsive-device.js` manages global device:
- `window.gutplusDevice` stores `global | tablet | mobile`.
- `setGlobalResponsiveDevice()` dispatches an event and applies iframe width simulation in the editor.

### CSS application
`buildEditorCssVars()` and `buildFrontendCssVars()` emit:
- `--<var>` for base
- `--<var>-tablet` for tablet
- `--<var>-mobile` for mobile

Frontend JS (`blocks/<block>/src/frontend.js`) sets `data-gutplus-device` on the block root based on viewport width. CSS uses `[data-gutplus-device="tablet"]` and `[data-gutplus-device="mobile"]` to select the correct responsive variables.

## 6.5. IconPanel Component Architecture

File: `shared/src/components/controls/IconPanel.js`

The IconPanel component is the main UI container for all icon controls. It has a complex internal structure with conditional rendering based on user selections.

### Component Hierarchy

```
IconPanel (main export)
  └─ PanelBody
      ├─ ToggleControl (Show Icon)
      ├─ IconPositionControl
      ├─ ToggleControl (Different Icons)
      ├─ SliderWithInput (Rotation Animation) - always visible when showIcon=true
      ├─ <hr> divider
      └─ Conditional rendering:
          ├─ If !useDifferentIcons:
          │   └─ SingleIconMode (receives: onChange, onResponsiveToggle, currentDevice)
          │       ├─ IconPicker (inactive)
          │       ├─ ColorControl (inactive, if not image)
          │       ├─ SliderWithInput (Rotation Angle)
          │       ├─ BaseControl + UtilityBar + SliderWithInput (size/maxSize)
          │       ├─ BaseControl + UtilityBar + SliderWithInput (offsetX)
          │       └─ BaseControl + UtilityBar + SliderWithInput (offsetY)
          │
          └─ If useDifferentIcons:
              └─ DualIconMode (receives: onChange, onResponsiveToggle, currentDevice)
                  └─ TabPanel
                      ├─ Tab: Inactive (Closed)
                      │   └─ IconStateControls (state="inactive", receives: onChange, onResponsiveToggle, currentDevice)
                      │       ├─ IconPicker
                      │       ├─ ColorControl (if not image)
                      │       ├─ SliderWithInput (Rotation Angle)
                      │       ├─ BaseControl + UtilityBar + SliderWithInput (size/maxSize)
                      │       ├─ BaseControl + UtilityBar + SliderWithInput (offsetX)
                      │       └─ BaseControl + UtilityBar + SliderWithInput (offsetY)
                      │
                      └─ Tab: Active (Open)
                          └─ IconStateControls (state="active", receives: onChange, onResponsiveToggle, currentDevice)
                              ├─ IconPicker
                              ├─ ColorControl (if not image)
                              ├─ SliderWithInput (Rotation Angle)
                              ├─ BaseControl + UtilityBar + SliderWithInput (size/maxSize)
                              ├─ BaseControl + UtilityBar + SliderWithInput (offsetX)
                              ├─ BaseControl + UtilityBar + SliderWithInput (offsetY)
                              └─ Fallback message
```

**Key Prop Flow:**
- IconPanel defines `handleChange` and `handleResponsiveToggle`
- These are passed as `onChange` and `onResponsiveToggle` to child components
- DualIconMode must forward these props to IconStateControls
- All UtilityBar instances in children use the received prop names

### Main Component: IconPanel

```javascript
export function IconPanel( {
  blockType,
  attributes,
  setAttributes,
  effectiveValues,
  label = 'Icon',
  help,
} ) {
  const currentDevice = useResponsiveDevice();
  const isIconVisible = effectiveValues?.showIcon !== false;
  const [ useDifferentIcons, setUseDifferentIcons ] = useState(
    effectiveValues?.useDifferentIcons || false
  );

  // Sync state with effectiveValues when it changes
  useEffect( () => {
    setUseDifferentIcons( effectiveValues?.useDifferentIcons || false );
  }, [ effectiveValues?.useDifferentIcons ] );

  const handleChange = ( updates ) => {
    setAttributes( updates );
  };

  // Helper to toggle responsive mode for a specific attribute
  const handleResponsiveToggle = ( attributeName, enabled ) => {
    handleChange( {
      responsiveEnabled: {
        ...( attributes.responsiveEnabled || {} ),
        [ attributeName ]: enabled,
      },
    } );
  };

  // If icon is hidden, show only the toggle
  if ( ! isIconVisible ) {
    return (
      <PanelBody title={ label } initialOpen={ false }>
        <ToggleControl
          label="Show Icon"
          checked={ false }
          onChange={ ( checked ) => handleChange( { showIcon: checked } ) }
          help="Display expand/collapse icon"
          __nextHasNoMarginBottom
        />
      </PanelBody>
    );
  }

  return (
    <PanelBody title={ label } initialOpen={ false }>
      {/* Show Icon Toggle */}
      <ToggleControl
        label="Show Icon"
        checked={ isIconVisible }
        onChange={ ( checked ) => handleChange( { showIcon: checked } ) }
        help="Display expand/collapse icon"
        __nextHasNoMarginBottom
      />

      {/* Icon Position */}
      <div style={ { marginTop: '16px', marginBottom: '16px' } }>
        <IconPositionControl
          label="Icon Position"
          value={ effectiveValues?.iconPosition || 'right' }
          onChange={ ( position ) => handleChange( { iconPosition: position } ) }
          blockType={ blockType }
        />
      </div>

      {/* Different Icons Toggle */}
      <ToggleControl
        label="Different icons for open/close"
        checked={ useDifferentIcons }
        onChange={ ( checked ) => {
          setUseDifferentIcons( checked );
          handleChange( { useDifferentIcons: checked } );
        } }
        help="Use separate icon when accordion/tab is open"
        __nextHasNoMarginBottom
      />

      {/* Rotation Animation Slider - Always visible when icon is shown */}
      <div style={ { marginTop: '16px', marginBottom: '16px' } }>
        <SliderWithInput
          label="Rotation Animation"
          value={ parseValueWithUnit( effectiveValues?.iconRotation || '180deg' ) }
          onChange={ ( val ) => {
            const valueStr = typeof val === 'object' && val.value !== undefined
              ? `${ val.value }${ val.unit || 'deg' }`
              : `${ val }deg`;
            handleChange( { iconRotation: valueStr } );
          } }
          min={ -180 }
          max={ 180 }
          step={ 1 }
          units={ [ 'deg' ] }
          help={ useDifferentIcons
            ? "Animation rotation added on open/close (on top of initial rotation)"
            : "Animation rotation added when open (on top of initial rotation)"
          }
          responsive={ false }
          canBeResponsive={ false }
        />
      </div>

      <hr style={ { margin: '16px 0', borderTop: '1px solid #ddd' } } />

      {/* Single Icon Mode OR Inactive/Active Tabs */}
      { ! useDifferentIcons ? (
        <SingleIconMode
          attributes={ attributes }
          effectiveValues={ effectiveValues }
          onChange={ handleChange }
          onResponsiveToggle={ handleResponsiveToggle }
          currentDevice={ currentDevice }
          blockType={ blockType }
        />
      ) : (
        <DualIconMode
          attributes={ attributes }
          effectiveValues={ effectiveValues }
          onChange={ handleChange }
          onResponsiveToggle={ handleResponsiveToggle }
          currentDevice={ currentDevice }
          blockType={ blockType }
        />
      ) }
    </PanelBody>
  );
}
```

**Key Features:**
- Early return if icon is hidden (shows only toggle)
- State management for `useDifferentIcons` with sync to `effectiveValues`
- Clears all active attributes when switching from dual to single mode
- Rotation Animation always visible; initial rotation controls live in SingleIconMode/State tabs
- Conditional rendering of SingleIconMode vs DualIconMode

### SingleIconMode Component

Renders controls for a single icon (animation rotation handles state change):

```javascript
function SingleIconMode( { attributes, effectiveValues, onChange, currentDevice, blockType } ) {
  const iconSource = effectiveValues?.iconInactiveSource || { kind: 'char', value: '▾' };
  const isImage = iconSource.kind === 'image';

  return (
    <div className="single-icon-mode">
      <h4 style={ { margin: '0 0 12px 0', fontSize: '13px', fontWeight: 600 } }>
        Icon Settings
      </h4>

      {/* Icon Picker */}
      <IconPicker
        label="Icon"
        value={ iconSource }
        onChange={ ( newSource ) => onChange( { iconInactiveSource: newSource } ) }
      />

      {/* Color (only for char/library) */}
      { ! isImage && (
        <div style={ { marginTop: '16px' } }>
          <ColorControl
            label="Icon Color"
            value={ effectiveValues?.iconInactiveColor || '#666666' }
            onChange={ ( color ) => onChange( { iconInactiveColor: color } ) }
          />
        </div>
      ) }

      {/* Initial Rotation */}
      <div style={ { marginTop: '16px' } }>
        <SliderWithInput
          label="Rotation Angle"
          value={ parseValueWithUnit( effectiveValues?.iconInactiveRotation || '0deg' ) }
          onChange={ ( val ) => {
            const valueStr = typeof val === 'object' && val.value !== undefined
              ? `${ val.value }${ val.unit || 'deg' }`
              : `${ val }deg`;
            onChange( { iconInactiveRotation: valueStr } );
          } }
          min={ -180 }
          max={ 180 }
          step={ 1 }
          units={ [ 'deg' ] }
          responsive={ false }
          canBeResponsive={ false }
        />
      </div>

      {/* Size (char/library) or MaxSize (image) - responsive */}
      {/* BaseControl + UtilityBar + SliderWithInput for size/maxSize */}
      {/* BaseControl + UtilityBar + SliderWithInput for offsetX */}
      {/* BaseControl + UtilityBar + SliderWithInput for offsetY */}
    </div>
  );
}
```

**Key Features:**
- Uses only `iconInactive*` attributes
- Conditional color control (hidden for images)
- Conditional size control (size for char/library, maxSize for images)
- All size/offset controls use BaseControl + UtilityBar pattern

### DualIconMode Component

Renders tabs for inactive and active states; tab selection drives editor preview:

```javascript
function DualIconMode( { attributes, effectiveValues, onChange, currentDevice, blockType, onIconPreviewChange } ) {
  const tabs = [
    { name: 'inactive', title: 'Inactive (Closed)' },
    { name: 'active', title: 'Active (Open)' },
  ];

  return (
    <div className="dual-icon-mode">
      {/* Inactive/Active Tabs */}
      <TabPanel
        className="icon-state-tabs"
        tabs={ tabs }
        initialTabName="inactive"
        onSelect={ ( tabName ) => onIconPreviewChange?.( tabName ) }
      >
        { ( tab ) => (
          <IconStateControls
            state={ tab.name }
            attributes={ attributes }
            effectiveValues={ effectiveValues }
            onChange={ onChange }
            currentDevice={ currentDevice }
            blockType={ blockType }
          />
        ) }
      </TabPanel>
    </div>
  );
}
```

**Key Features:**
- Two tabs: Inactive (Closed) and Active (Open)
- Both tabs render IconStateControls with different state parameter
- Tab selection drives editor-only preview state (no separate toggle)

### IconStateControls Component

Renders icon controls for a specific state (inactive or active):

```javascript
function IconStateControls( { state, attributes, effectiveValues, onChange, currentDevice, blockType } ) {
  const prefix = state === 'inactive' ? 'iconInactive' : 'iconActive';
  const iconSource = effectiveValues?.[ `${ prefix }Source` ] || { kind: 'char', value: '▾' };
  const isImage = iconSource.kind === 'image';

  return (
    <div className={ `icon-state-${ state }` } style={ { marginTop: '16px' } }>
      {/* Icon Picker */}
      <IconPicker
        label={ `${ state === 'inactive' ? 'Closed' : 'Open' } Icon` }
        value={ iconSource }
        onChange={ ( newSource ) => onChange( { [ `${ prefix }Source` ]: newSource } ) }
      />

      {/* Color (only for char/library) */}
      { ! isImage && (
        <div style={ { marginTop: '16px' } }>
          <ColorControl
            label="Icon Color"
            value={ effectiveValues?.[ `${ prefix }Color` ] || '#666666' }
            onChange={ ( color ) => onChange( { [ `${ prefix }Color` ]: color } ) }
          />
        </div>
      ) }

      {/* Initial Rotation */}
      <div style={ { marginTop: '16px' } }>
        <SliderWithInput
          label="Rotation Angle"
          value={ parseValueWithUnit( effectiveValues?.[ `${ prefix }Rotation` ] || '0deg' ) }
          onChange={ ( val ) => {
            const valueStr = typeof val === 'object' && val.value !== undefined
              ? `${ val.value }${ val.unit || 'deg' }`
              : `${ val }deg`;
            onChange( { [ `${ prefix }Rotation` ]: valueStr } );
          } }
          min={ -180 }
          max={ 180 }
          step={ 1 }
          units={ [ 'deg' ] }
          responsive={ false }
          canBeResponsive={ false }
        />
      </div>

      {/* Size/MaxSize (responsive) */}
      {/* OffsetX (responsive) */}
      {/* OffsetY (responsive) */}

      {/* Active state fallback message */}
      { state === 'active' && (
        <p
          className="description"
          style={ {
            fontSize: '12px',
            color: '#666',
            marginTop: '16px',
            fontStyle: 'italic',
          } }
        >
          Active values fallback to inactive values if not set.
        </p>
      ) }
    </div>
  );
}
```

**Key Features:**
- Dynamic attribute prefix based on state (iconInactive vs iconActive)
- Same controls for both states
- Fallback message shown only in active tab
- No preview toggle here (moved to DualIconMode)

### Responsive Value Helpers

IconPanel includes utility functions for managing responsive values:

```javascript
// Get responsive value for current device with inheritance
function getResponsiveValue( value, device ) {
  if ( value === null || value === undefined ) return 0;
  if ( typeof value !== 'object' ) return getNumericDefault( value );

  const baseValue = getBaseValue( value );
  const tabletValue = value.tablet;
  const mobileValue = value.mobile;

  switch ( device ) {
    case 'global':
      return getNumericDefault( baseValue );
    case 'tablet':
      return getNumericDefault( tabletValue !== undefined ? tabletValue : baseValue );
    case 'mobile':
      return getNumericDefault( mobileValue !== undefined ? mobileValue : ( tabletValue !== undefined ? tabletValue : baseValue ) );
    default:
      return 0;
  }
}

// Set responsive value for specific device
function setResponsiveValue( currentValue, device, newValue ) {
  if ( device === 'global' ) {
    if ( ! currentValue || typeof currentValue !== 'object' || ! ( 'tablet' in currentValue || 'mobile' in currentValue ) ) {
      return newValue;
    }
    const { tablet, mobile } = currentValue;
    const result = { ...parseValueWithUnit( newValue ) };
    if ( tablet !== undefined ) result.tablet = tablet;
    if ( mobile !== undefined ) result.mobile = mobile;
    return result;
  }

  if ( ! currentValue || typeof currentValue !== 'object' ) {
    return {
      ...parseValueWithUnit( currentValue || '0px' ),
      [ device ]: parseValueWithUnit( newValue ),
    };
  }

  const { tablet, mobile, ...base } = currentValue;
  const result = { ...base };
  if ( tablet !== undefined && device !== 'tablet' ) result.tablet = tablet;
  if ( mobile !== undefined && device !== 'mobile' ) result.mobile = mobile;
  result[ device ] = parseValueWithUnit( newValue );
  return result;
}

// Parse value with unit into object
function parseValueWithUnit( value ) {
  if ( typeof value === 'string' ) {
    const match = value.match( /^([0-9.]+)(.*)$/ );
    if ( match ) {
      return { value: parseFloat( match[ 1 ] ), unit: match[ 2 ] || '' };
    }
  }
  if ( typeof value === 'number' ) {
    return { value, unit: 'px' };
  }
  return value;
}
```

**Key Features:**
- Device inheritance: mobile → tablet → global
- Preserves existing device overrides when updating base
- Converts between string formats ("16px") and object formats ({value: 16, unit: "px"})

## 7. Theming and Cascade (how values become CSS)

Editor:
- `useThemeManager()` computes `expectedValues` = defaults + theme.
- Block `attributes` remain the source of truth in the editor.
- `customizations` is auto-updated to contain only values that differ from the expected theme.

Save (frontend):
- `getAllEffectiveValues(attributes, {}, defaults)` merges attributes with defaults.
- `buildFrontendCssVars(customizations, attributes)` outputs CSS vars only for customized values.
- CSS vars are applied inline on the block root.

Important: Icon attributes are `themeable: true` in schema, so they participate in theme deltas and the `customizations` snapshot.

## 8. CSS Variables and Icon Styling

Icon-related CSS vars (accordion):
- `--accordion-icon-display` (from `showIcon`)
- `--accordion-icon-rotation` (from `iconRotation`)
- `--accordion-icon-color` (inactive color)
- `--accordion-icon-size` (inactive size)
- `--accordion-icon-max-size` (inactive image max size)
- `--accordion-icon-offset-x`, `--accordion-icon-offset-y`
- `--accordion-icon-active-color`
- `--accordion-icon-active-size`
- `--accordion-icon-active-max-size`
- `--accordion-icon-active-offset-x`, `--accordion-icon-active-offset-y`

Frontend CSS uses these in `blocks/accordion/src/style.scss`:
- `.accordion-icon-wrapper` uses `--accordion-icon-display` and offsets.
- `.accordion-icon` uses `--accordion-icon-color`, `--accordion-icon-size`.
- `.gutplus-accordion.is-open` swaps to active vars where available.

Editor styling for the panel UI (tabs and icon grid) is defined in:
- `shared/src/components/controls/SidebarStyling.scss`
- `shared/src/components/controls/IconPicker.scss`

## 9. Runtime Rendering (where attributes are used)

Editor markup:
- `blocks/<block>/src/edit.js` renders icons using `iconInactiveSource` and `iconActiveSource`.
- Live preview uses editor-only state driven by the inactive/active tab selection.

Save markup:
- `blocks/<block>/src/save.js` renders the initial icon and attaches data attributes:
  - `data-icon-inactive`, `data-icon-active`, `data-has-different-icons`
- `blocks/<block>/src/frontend.js` toggles `is-open` class and handles rotation/state.

## 10. Diagram (compile-time + runtime)
```
schemas/*.json (icon-panel macro)
  |
  | npm run schema:build
  v
build-tools/schema-compiler.js
  - processAttributes -> expandIconPanelMacro
  - generate artifacts
  |
  +--> schemas/*-schema-autogenerated.json
  +--> blocks/*/src/*-attributes.js
  +--> shared/src/config/control-config-generated.js
  +--> shared/src/config/css-var-mappings-generated.js
  +--> shared/src/styles/*-css-vars-generated.js
  |
Editor runtime:
  blocks/*/src/edit.js
    -> TabbedInspector
    -> AppearancePanels
    -> SchemaPanels (group "icon")
    -> IconPanel
       -> IconPicker / ColorControl / SliderWithInput / BaseControl + UtilityBar
       -> setAttributes (icon* values)
       -> useThemeManager updates customizations
       -> buildEditorCssVars -> inline CSS vars
Frontend runtime:
  blocks/*/src/save.js
    -> renders markup + data attributes + inline CSS vars
  blocks/*/src/style.scss
    -> uses CSS vars for icon display/size/color/offset
  blocks/*/src/frontend.js
    -> toggles is-open + updates data-gutplus-device
```

---

## 11. Critical Runtime Issues and Resolutions

This section documents critical implementation issues discovered and resolved during development and testing.

### 11.1. Icon Rendering Consistency (Editor vs Frontend)

**Issue Date:** 2026-01-03
**Status:** RESOLVED

**Problem:**
The editor (edit.js) and frontend (save.js) were using different methods to render Dashicons, causing inconsistencies:

- **Frontend (save.js):** Used native HTML spans
  ```javascript
  <span className={`dashicons dashicons-${iconName}`} />
  ```

- **Editor (edit.js):** Used WordPress Dashicon React component
  ```javascript
  import { Dashicon } from '@wordpress/components';
  <Dashicon icon={iconName} style={{ fontSize: 'inherit', width: '1em', height: '1em' }} />
  ```

**Impact:**
- Icon rendering differed between editor preview and frontend display
- Potential styling inconsistencies
- Additional import dependency that wasn't necessary

**Solution:**
Changed all three blocks (accordion, tabs, toc) to use the same native HTML approach in both edit.js and save.js:

```javascript
// Before (edit.js)
import { Dashicon } from '@wordpress/components';
return <Dashicon icon={iconName} style={{...}} />;

// After (edit.js)
return <span className={`dashicons dashicons-${iconName}`} />;
```

**Files Modified:**
- `blocks/accordion/src/edit.js` - Line ~334
- `blocks/tabs/src/edit.js` - Line ~691
- `blocks/toc/src/edit.js` - Line ~653

**Benefit:**
- Consistent rendering between editor and frontend
- Simplified code (removed unnecessary React component wrapper)
- Better matches WordPress core patterns

### 11.2. Dashicons CSS Not Loading in Block Editor (WordPress 6.3+)

**Issue Date:** 2026-01-03
**Status:** RESOLVED
**WordPress Version:** 6.3+

**Problem:**
Dashicons were not appearing in the block editor preview, despite working correctly on the frontend. The HTML markup was correct (`<span class="dashicons dashicons-*">`), but the CSS file `dashicons.min.css` was not being loaded in the editor.

**Root Cause:**
Since WordPress 6.3, the block editor runs in an **iframe** for better isolation. The `enqueue_block_editor_assets` hook does not properly load stylesheets into this iframe context, which is a known breaking change in WordPress 6.3.

**Technical Details:**
- WordPress 6.3 introduced iframed editor when all blocks use Block API version 3+
- Previous enqueue method:
  ```php
  function guttemberg_plus_enqueue_editor_assets() {
      wp_enqueue_style( 'dashicons' );
  }
  add_action( 'enqueue_block_editor_assets', 'guttemberg_plus_enqueue_editor_assets' );
  ```
- This hook loads assets in the parent frame, not the editor iframe
- Dashicons CSS was not reaching the actual editor content

**Solution:**
Changed from `enqueue_block_editor_assets` to `enqueue_block_assets` hook, which is the **official WordPress-recommended solution** for WordPress 6.3+:

```php
/**
 * Enqueue Dashicons for both editor and frontend
 *
 * Uses enqueue_block_assets instead of enqueue_block_editor_assets
 * to ensure assets load in the iframed editor (WordPress 6.3+)
 *
 * @see https://developer.wordpress.org/block-editor/how-to-guides/enqueueing-assets-in-the-editor/
 */
function guttemberg_plus_enqueue_block_assets() {
    // Enqueue Dashicons for icon library support
    // This loads in both editor and frontend
    wp_enqueue_style( 'dashicons' );
}
add_action( 'enqueue_block_assets', 'guttemberg_plus_enqueue_block_assets' );
```

**Why This Works:**
- `enqueue_block_assets` was specifically designed for WordPress 6.3+ iframed editor
- It loads assets in both the editor iframe AND the frontend
- Official WordPress documentation recommends this approach
- More elegant than workarounds (no conditional checks or manual registrations needed)

**Additional Changes:**
Removed redundant Dashicons enqueuing from individual block render callbacks:

```php
// Before - in each render callback
function guttemberg_plus_render_accordion_block( $attributes, $content ) {
    if ( ! is_admin() ) {
        wp_enqueue_style( 'dashicons' );
    }
    return $content;
}

// After - simplified (global enqueue handles it)
function guttemberg_plus_render_accordion_block( $attributes, $content ) {
    // Note: Dashicons are now globally enqueued via enqueue_block_assets hook
    return $content;
}
```

**Files Modified:**
- `includes/block-registration.php` - Lines 45-58 (enqueue function)
- `includes/block-registration.php` - Lines 70-97 (render callbacks cleaned up)

**References:**
- [WordPress Block Editor Handbook - Enqueueing Assets](https://developer.wordpress.org/block-editor/how-to-guides/enqueueing-assets-in-the-editor/)
- [WordPress Core - Miscellaneous Editor Changes in 6.3](https://make.wordpress.org/core/2023/07/18/miscellaneous-editor-changes-in-wordpress-6-3/)
- [GitHub Issue #41821 - enqueue_block_editor_assets not working with iframe](https://github.com/WordPress/gutenberg/issues/41821)

**Testing:**
After this fix, `dashicons.min.css` should appear in the Network tab when the editor loads, and Dashicons should render correctly in both:
1. Editor preview (inside the iframe)
2. Frontend display

### 11.3. useDifferentIcons Attribute Not Respected in Frontend

**Issue Date:** 2026-01-03
**Status:** RESOLVED

**Problem:**
When "Different icons for open/close" toggle was turned OFF in the editor, the frontend would still display different icons for open/closed states if an old `iconActiveSource` value existed in the saved attributes.

**Root Cause:**
The frontend `save.js` files were only checking if `iconActiveSource` had a value, but NOT checking whether `useDifferentIcons` was actually enabled:

```javascript
// Before - incorrect logic
const hasDifferentIcons = !! ( activeSource && activeSource.value );
```

This meant that even when the user disabled dual icon mode, if they had previously set an active icon, it would continue to render.

**Expected Behavior:**
- When `useDifferentIcons === false`: Use only `iconInactiveSource` for both states
- When `useDifferentIcons === true` AND `iconActiveSource` exists: Use both icons
- Icon rotation should still apply in both modes

**Solution:**
Added `useDifferentIcons` check to the frontend rendering logic in all three blocks:

**Accordion (save.js):**
```javascript
// Before
const hasDifferentIcons = !! ( activeSource && activeSource.value );

// After
const useDifferentIcons = attributes.useDifferentIcons;
const hasDifferentIcons = useDifferentIcons && activeSource && activeSource.value;

// Render inactive icon (always visible when closed)
const inactiveIcon = renderSingleIcon( inactiveSource, 'inactive' );

// Render active icon only if different icons mode is enabled
const activeIcon = hasDifferentIcons ? renderSingleIcon( activeSource, 'active' ) : null;
```

**Tabs (save.js):**
```javascript
// Before
const initialSource = isActive && activeSource && activeSource.value
    ? activeSource
    : inactiveSource;

// After
const useDifferentIcons = attributes.useDifferentIcons;
const initialSource = isActive && useDifferentIcons && activeSource && activeSource.value
    ? activeSource
    : inactiveSource;

const hasDifferentIcons = useDifferentIcons && activeSource && activeSource.value;
const dataAttrs = {
    'data-icon-inactive': JSON.stringify( inactiveSource ),
    'data-icon-active': hasDifferentIcons ? JSON.stringify( activeSource ) : null,
    'data-has-different-icons': hasDifferentIcons,
};
```

**TOC (save.js):**
```javascript
// Before
const initialSource = ( ! initiallyCollapsed ) && activeSource && activeSource.value
    ? activeSource
    : inactiveSource;

// After
const useDifferentIcons = attributes.useDifferentIcons;
const initialSource = ( ! initiallyCollapsed ) && useDifferentIcons && activeSource && activeSource.value
    ? activeSource
    : inactiveSource;

const hasDifferentIcons = useDifferentIcons && activeSource && activeSource.value;
```

**Files Modified:**
- `blocks/accordion/src/save.js` - Lines 174-187 (renderIcon function)
- `blocks/tabs/src/save.js` - Lines 117-133 (renderIcon function)
- `blocks/toc/src/save.js` - Lines 237-253 (renderIcon function)

**Testing Scenarios:**
1. **Single Icon Mode** (`useDifferentIcons = false`):
   - ✅ Only `iconInactiveSource` should render
   - ✅ Icon rotation should still apply
   - ✅ Same icon appears in both open/closed states

2. **Dual Icon Mode** (`useDifferentIcons = true`):
   - ✅ Different icons render for inactive and active states
   - ✅ Icon rotation still applies during transition
   - ✅ Active icon has its own color, size, offset values

3. **Toggling Between Modes:**
   - ✅ Turning OFF dual mode clears active attributes in editor
   - ✅ Frontend respects the toggle immediately
   - ✅ No "ghost" active icons from previous settings

**Key Insight:**
The editor (IconPanel.js) already had the correct behavior - it clears active attributes when turning off dual mode. The bug was purely in the frontend rendering logic not checking the flag properly.

### 11.4. Responsive Icon Size/Offset Preview System

**Overview:**
Icon size and offset attributes (iconInactiveSize, iconInactiveMaxSize, iconInactiveOffsetX, iconInactiveOffsetY) support responsive values that preview correctly in the editor across all device modes.

**CSS Generation from Expanded Schemas:**

The CSS generator reads from **expanded schemas** (`schemas/{blockType}-schema-autogenerated.json`) rather than base schemas. This ensures icon attributes (generated by the icon-panel macro expansion) are included in CSS generation.

```javascript
// build-tools/css-generator.js - loadSchema function
function loadSchema(blockType) {
  const expandedPath = path.join(SCHEMAS_DIR, `${blockType}-schema-autogenerated.json`);
  const basePath = path.join(SCHEMAS_DIR, `${blockType}.json`);

  // Prioritizes expanded schema (contains macro-generated icon attributes)
  const schemaPath = fs.existsSync(expandedPath) ? expandedPath : basePath;
  // ... loads and returns schema
}
```

**Generated Responsive CSS Selectors:**

Icon attributes with `responsive: true` generate device-specific CSS selectors:

```scss
// Base (desktop)
.accordion-icon {
  font-size: var(--accordion-icon-size, 16px);
  width: var(--accordion-icon-size, 16px);
  height: var(--accordion-icon-size, 16px);
}

// Tablet
[data-gutplus-device="tablet"] .accordion-icon {
  font-size: var(--accordion-icon-size-tablet, var(--accordion-icon-size, 16px));
  width: var(--accordion-icon-size-tablet, var(--accordion-icon-size, 16px));
  height: var(--accordion-icon-size-tablet, var(--accordion-icon-size, 16px));
}

// Mobile (cascades: mobile → tablet → base)
[data-gutplus-device="mobile"] .accordion-icon {
  font-size: var(--accordion-icon-size-mobile, var(--accordion-icon-size-tablet, var(--accordion-icon-size, 16px)));
  width: var(--accordion-icon-size-mobile, var(--accordion-icon-size-tablet, var(--accordion-icon-size, 16px)));
  height: var(--accordion-icon-size-mobile, var(--accordion-icon-size-tablet, var(--accordion-icon-size, 16px)));
}

// Icon offset wrapper
[data-gutplus-device="tablet"] .accordion-icon-wrapper {
  transform: translate(
    var(--accordion-icon-offset-x-tablet, var(--accordion-icon-offset-x, 0px)),
    var(--accordion-icon-offset-y-tablet, var(--accordion-icon-offset-y, 0px))
  );
}

[data-gutplus-device="mobile"] .accordion-icon-wrapper {
  transform: translate(
    var(--accordion-icon-offset-x-mobile, var(--accordion-icon-offset-x-tablet, var(--accordion-icon-offset-x, 0px))),
    var(--accordion-icon-offset-y-mobile, var(--accordion-icon-offset-y-tablet, var(--accordion-icon-offset-y, 0px)))
  );
}
```

**IconPanel Responsive Mode Behavior:**

IconPanel respects the `responsiveEnabled` state when writing attribute values. All onChange callbacks check whether responsive mode is active for that specific attribute:

```javascript
// Example: iconInactiveSize onChange (line 457)
onChange({
  iconInactiveSize: setResponsiveValue(
    attributes.iconInactiveSize,
    attributes.responsiveEnabled?.iconInactiveSize ? currentDevice : 'global',
    valueStr
  ),
});
```

**Responsive Callbacks (all 8 attributes):**
- `iconInactiveSize` (line 457)
- `iconInactiveMaxSize` (line 503)
- `iconInactiveOffsetX` (line 548)
- `iconInactiveOffsetY` (line 592)
- `iconActiveSize` (line 766, dynamic prefix)
- `iconActiveMaxSize` (line 812, dynamic prefix)
- `iconActiveOffsetX` (line 857, dynamic prefix)
- `iconActiveOffsetY` (line 901, dynamic prefix)

**Behavior:**
- **Responsive Mode OFF:** Changes write to `'global'` device, creating/updating base value only
- **Responsive Mode ON:** Changes write to current device (global/tablet/mobile), creating device-specific overrides

**Value Structure Examples:**

Responsive mode OFF (base value only):
```javascript
iconInactiveSize: "20px"
// or
iconInactiveSize: { value: 20, unit: "px" }
```

Responsive mode ON (with device overrides):
```javascript
iconInactiveSize: {
  value: 16,
  unit: "px",
  tablet: { value: 20, unit: "px" },
  mobile: { value: 12, unit: "px" }
}
```

**Key Implementation Files:**
- `build-tools/css-generator.js` (lines 42-68) - Schema loading logic
- `shared/src/components/controls/IconPanel.js` (lines 457, 503, 548, 592, 766, 812, 857, 901) - Responsive onChange callbacks
- `css/generated/*_variables.scss` (generated) - Responsive CSS selectors

---

## Document History and References

### Recent Updates

**2026-01-04 - Responsive Icon Preview Documentation:**
- Added Section 11.4: Responsive Icon Size/Offset Preview System
  - Documents CSS generation from expanded schemas
  - Documents responsive CSS selector generation for icon attributes
  - Documents IconPanel responsive mode behavior and onChange callbacks
  - Includes value structure examples for responsive vs non-responsive modes

**2026-01-03 - Critical Runtime Fixes:**
- Added Section 11: Critical Runtime Issues and Resolutions
  - 11.1: Icon Rendering Consistency - Fixed Dashicon component vs native HTML inconsistency
  - 11.2: Dashicons CSS Not Loading in WordPress 6.3+ - Changed from `enqueue_block_editor_assets` to `enqueue_block_assets` hook
  - 11.3: useDifferentIcons Not Respected - Fixed frontend save.js to check `useDifferentIcons` attribute
- All three issues resolved with complete documentation of root cause, solution, and testing steps
- Updated includes/block-registration.php for proper WordPress 6.3+ asset enqueuing
- Updated all three blocks (accordion/tabs/toc) in both edit.js and save.js

**2026-01-01 - Comprehensive Implementation Details Added:**
- Added detailed IconPicker implementation section (5.1)
  - Lucide icon filtering logic with actual code
  - LucideIcon component implementation
  - LibraryTab implementation details
  - Output value format examples
- Added IconPanel Component Architecture section (6.5)
  - Complete component hierarchy diagram
  - Full source code for all components (IconPanel, SingleIconMode, DualIconMode, IconStateControls)
  - Responsive value helper functions implementation
- Added Schema Compiler showWhen Logic section (2.1)
  - Detailed showWhen generation rules
  - Explanation of inactive vs active showWhen differences
  - Important clarification: showWhen is metadata, not enforced by IconPanel
  - Complete example of all showWhen conditions for accordion
- Updated "Known gaps" section - marked all three gaps as FIXED with date

**Purpose of Updates:**
These additions ensure developers can understand the full Icon Panel implementation without needing to explore beyond this document. All critical implementation details are now documented with actual code examples.

### Related Documentation

- `docs/ICON_PANEL_FIXES_IMPLEMENTATION_PLAN.md` - Implementation plan for fixing the three known gaps (2026-01-01)
- `CLAUDE.md` - Overall project architecture and schema-first development approach
- `docs/accordion-attributes.md` - Auto-generated attribute documentation (includes icon attributes)
- `docs/tabs-attributes.md` - Auto-generated attribute documentation for tabs block
- `docs/toc-attributes.md` - Auto-generated attribute documentation for TOC block

### Key Insights from Implementation Exploration

1. **showWhen is Documentation, Not Enforcement:**
   - Schema showWhen conditions document intended visibility behavior
   - IconPanel implements its own visibility logic (doesn't read schema showWhen)
   - This separation allows IconPanel's complex UI (tabs, nested controls) to function independently

2. **Component Architecture is Modular:**
   - IconPanel → SingleIconMode/DualIconMode → IconStateControls
   - Each component handles its own state management and rendering
   - Responsive values use helper functions (getResponsiveValue, setResponsiveValue)

3. **Icon Library Integration:**
   - Dashicons: Hardcoded array of 146 icons
   - Lucide: Dynamic filtering from lucide-react exports (200+ icons)
   - Filtering logic crucial for performance and avoiding utility exports

4. **Rotation Behavior:**
   - Rotation Animation slider is always visible when icon is shown
   - Initial Rotation sliders live in SingleIconMode and each state tab
   - Animation rotation is added on top of the initial rotation values

5. **Preview Behavior:**
   - Editor preview follows the selected inactive/active tab
   - Preview is editor-only and does not change `initiallyOpen`

---

## Troubleshooting Common Issues

### Lucide Icons Not Appearing
**Symptoms:** Library picker shows empty list when "Lucide Icons" is selected

**Diagnosis:**
- Check browser console for log messages: "Total Lucide exports: X", "Filtered Lucide icons: Y"
- If filtered count is 0, the filter logic is too restrictive
- If no logs appear, getLucideIcons() isn't being called

**Solution:**
- Ensure lucide-react is installed: `npm install lucide-react`
- Verify import statement: `import * as LucideIcons from 'lucide-react';`
- Check filter includes uppercase check: `/^[A-Z]/.test(name)`
- Rebuild: `npm run build`

### Preview Tab Not Updating
**Symptoms:** Switching Inactive/Active tabs doesn't change the icon preview

**Diagnosis:**
- Verify `TabPanel` `onSelect` calls `onIconPreviewChange`
- Check edit.js uses editor-only preview state to add the `is-open` class
- Confirm `useDifferentIcons` is true and an active icon exists

**Solution:**
- Ensure `SchemaPanels` passes `onIconPreviewChange` into `IconPanel`
- Verify edit.js uses preview state instead of `initiallyOpen` for editor icon state

### Rotation Not Applying
**Symptoms:** Rotation controls visible but icon doesn't rotate or starts at wrong angle

**Diagnosis:**
- Check CSS variables are generated: `--accordion-icon-rotation`, `--accordion-icon-initial-rotation`, `--accordion-icon-active-initial-rotation`
- Verify CSS uses `calc(initial + rotation)` for open/active state
- Confirm frontend.js toggles classes correctly for open/close

**Solution:**
- Run `npm run schema:build` to regenerate CSS mappings
- Verify `style.scss` uses initial rotation vars and adds the animation rotation
- Check frontend.js class toggles for active/open state

---

**Document Version:** 2.2 (Updated 2026-01-04)
**Maintained by:** Development Team
**Last Update:** 2026-01-04 (Responsive Icon Preview System)
