# Schema to Editor to Frontend: Complete Data Flow Documentation

> **Technical Reference for Block Implementation with State-Aware CSS**
>
> This document explains the COMPLETE data flow from schema definition through editor rendering to frontend display, including the state-aware CSS generation system. Understanding this flow is critical for maintaining consistency across all blocks (accordion, tabs, toc).

---

## Table of Contents

1. [Overview: The 3-Tier CSS Cascade System](#overview-the-3-tier-css-cascade-system)
2. [Schema Definition (Source of Truth)](#schema-definition-source-of-truth)
3. [Schema Compilation Process](#schema-compilation-process)
4. [Editor Component (edit.js)](#editor-component-editjs)
5. [Save Component (save.js)](#save-component-savejs)
6. [Frontend Rendering](#frontend-rendering)
7. [UI State Management (Base vs Interactive States)](#ui-state-management-base-vs-interactive-states)
8. [Complete User Interaction Flow](#complete-user-interaction-flow)
9. [Critical Implementation Details](#critical-implementation-details)

---

## Overview: The 3-Tier CSS Cascade System

The entire plugin is built on a **3-tier CSS cascade** that provides defaults, themes, and customizations:

```
┌─────────────────────────────────────────────────────────────┐
│                    3-TIER CSS CASCADE                        │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  TIER 1: CSS Defaults (Lowest Priority)                     │
│  ├─ _theme-generated.scss (AUTO-GENERATED)                  │
│  ├─ Uses CSS variables with default values extracted from schema              │
│  └─ Example: color: var(--accordion-title-color)   │
│                                                              │
│  TIER 2: Theme Styles (Medium Priority)                     │
│  ├─ Generated by PHP at runtime     
│  ├─ Only contains DELTAS from default values               │                        │
│  ├─ CSS classes like .accordion-theme-dark                  │
│  └─ Example: .accordion-theme-dark {                        │
│              --accordion-title-color: #ffffff;              │
│            }                                                 │
│                                                              │
│  TIER 3: Inline Customizations (Highest Priority)           │
│  ├─ Output in save.js as inline styles                      │
│  ├─ Only contains DELTAS from expected values               │
│  └─ Example: style="--accordion-title-color: #ff0000"       │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**Key Principle:** CSS cascades naturally from Tier 1 → 2 → 3, with higher tiers overriding lower ones.

---

## Schema Definition (Source of Truth)

**Location:** `schemas/accordion.json`

Every block attribute is defined in a JSON schema. This is the **single source of truth** for:
- Attribute names and types
- Default values
- CSS variable mappings
- Control UI configurations
- Documentation

### Anatomy of a Schema Attribute

```json
{
  "titleColor": {
    "type": "string",                    // Data type: string, number, boolean, object
    "default": "#333333",                // Default value (TIER 1)
    "cssVar": "accordion-title-color",   // CSS variable name (without --)
    "group": "headerColors",             // UI panel grouping
    "label": "Title Color",              // Human-readable label
    "description": "Text color for the accordion title",
    "themeable": true,                   // Include in theme system?
    "control": "ColorPicker",            // Editor UI control type
    "state": "base",                     // UI state: base, hover, active, focus, disabled
    "order": 15,                         // Display order in sidebar
    "appliesTo": "title",                // Which element gets this style
    "cssProperty": "color"               // CSS property to set
  }
}
```

### Understanding Key Fields

| Field | Purpose | Example |
|-------|---------|---------|
| `themeable: true` | Attribute can be saved in themes | Most visual properties |
| `themeable: false` | Excluded from themes (structural/behavioral) | `accordionId`, `title`, `initiallyOpen` |
| `cssVar` | Maps to CSS variable `--{cssVar}` | `"accordion-title-color"` → `--accordion-title-color` |
| `cssProperty` | Which CSS property to set | `"color"`, `"font-size"`, `"border-radius"` |
| `appliesTo` | Target element from structure schema | `"title"`, `"content"`, `"icon"`, `"item"` |
| `control` | Editor UI component | `ColorPicker`, `RangeControl`, `SelectControl` |
| `state` | UI state for interactive styling | `"base"`, `"hover"`, `"active"`, `"focus"`, `"disabled"` |
| `unit` | CSS unit for numeric values | `"px"`, `"deg"`, `"%"` |

### State Field: Interactive CSS States

The optional `state` field defines which UI state an attribute applies to:

**Available States:**
- `"base"` - Default state (always applied, no special selector)
- `"hover"` - Mouse hover state (generates `:hover` selector)
- `"active"` - Active/selected state (generates `.active` class selector)
- `"focus"` - Keyboard focus state (generates `:focus` selector)
- `"disabled"` - Disabled state (generates `.disabled` or `[disabled]` selector)

**Example: Tabs Button States**

```json
{
  "tabButtonColor": {
    "type": "string",
    "default": "#666666",
    "cssVar": "tabs-button-color",
    "state": "base",
    "appliesTo": "tabButton",
    "cssProperty": "color"
  },
  "tabButtonHoverColor": {
    "type": "string",
    "default": "#333333",
    "cssVar": "tabs-button-hover-color",
    "state": "hover",
    "appliesTo": "tabButton",
    "cssProperty": "color"
  },
  "tabButtonActiveColor": {
    "type": "string",
    "default": "#333333",
    "cssVar": "tabs-button-active-color",
    "state": "active",
    "appliesTo": "tabButton",
    "cssProperty": "color"
  }
}
```

**Note:** If `state` is omitted, the attribute is treated as `"base"` state.

### Non-Themeable Attributes (Exclusions)

```json
{
  "accordionId": {
    "type": "string",
    "default": "",
    "themeable": false,
    "reason": "structural"    // Excluded because it's structural
  },
  "title": {
    "type": "string",
    "default": "Accordion Title",
    "themeable": false,
    "reason": "content"       // Excluded because it's content
  },
  "initiallyOpen": {
    "type": "boolean",
    "default": false,
    "themeable": false,
    "reason": "behavioral"    // Excluded because it's behavioral
  }
}
```

**Exclusion Reasons:**
- `structural` - IDs and identifiers
- `content` - User-entered text/data
- `behavioral` - Functional settings (not visual)

---

## Schema Compilation Process

**Script:** `build-tools/schema-compiler.js`

**Trigger:** `npm run schema:build` (also runs automatically in `npm run build`)

### What Gets Auto-Generated

When you run the schema compiler, **24 files** are created from the 3 schema files:

```
schemas/accordion.json
       ↓
  [COMPILER]
       ↓
┌──────────────────────────────────────────────────────────┐
│ BLOCK-SPECIFIC FILES (3 × 8 = 24 files)                  │
├──────────────────────────────────────────────────────────┤
│                                                           │
│ 1. Block Attributes (JavaScript)                         │
│    blocks/accordion/src/accordion-attributes.js          │
│                                                           │
│ 2. TypeScript Types                                      │
│    shared/src/types/accordion-theme.ts                   │
│                                                           │
│ 3. Zod Validators                                        │
│    shared/src/validators/accordion-schema.ts             │
│                                                           │
│ 4. PHP CSS Defaults                                      │
│    php/css-defaults/accordion.php                        │
│                                                           │
│ 5. CSS Variables (Tier 1)                                │
│    assets/css/accordion-variables.css                    │
│                                                           │
│ 6. SCSS Defaults (_theme-generated.scss)                 │
│    blocks/accordion/src/_theme-generated.scss            │
│                                                           │
│ 7. Style Builders                                        │
│    shared/src/styles/accordion-styles-generated.js       │
│                                                           │
│ 8. Documentation                                         │
│    docs/accordion-attributes.md                          │
│                                                           │
└──────────────────────────────────────────────────────────┘

SHARED FILES (4 files for all blocks)
├── shared/src/config/control-config-generated.js
├── shared/src/config/css-var-mappings-generated.js
├── php/css-defaults/css-mappings-generated.php
└── (exclusions removed - now inline)
```

### Code Injection: AUTO-GENERATED Sections

The compiler **injects code** into manual files using markers:

**In edit.js:**
```javascript
/* ========== AUTO-GENERATED-STYLES-START ========== */
// DO NOT EDIT - This code is auto-generated from schema
const getInlineStyles = () => {
  // ... auto-generated code ...
};
/* ========== AUTO-GENERATED-STYLES-END ========== */
```

**In save.js:**
```javascript
/* ========== AUTO-GENERATED-CUSTOMIZATION-STYLES-START ========== */
// DO NOT EDIT - This code is auto-generated from schema
const getCustomizationStyles = () => {
  // ... auto-generated code ...
};
/* ========== AUTO-GENERATED-CUSTOMIZATION-STYLES-END ========== */
```

**Critical:** Everything between `START` and `END` markers is **regenerated** on every build. NEVER edit this code manually!

### Generated File: accordion-attributes.js

**Purpose:** WordPress block attribute definitions (for `registerBlockType`)

```javascript
export const accordionAttributes = {
  titleColor: {
    type: 'string',
    default: '#333333',
  },
  titleFontSize: {
    type: 'number',
    default: 18,
  },
  borderRadius: {
    type: 'object',
    default: {"topLeft":4,"topRight":4,"bottomRight":4,"bottomLeft":4},
  },
  // ... all attributes from schema
};
```

**Usage in edit.js:**
```javascript
import { accordionAttributes } from './accordion-attributes';

const schemaDefaults = useMemo(() => {
  const defaults = {};
  Object.keys(accordionAttributes).forEach((key) => {
    if (accordionAttributes[key].default !== undefined) {
      defaults[key] = accordionAttributes[key].default;
    }
  });
  return defaults;
}, []);
```

### Generated File: css-var-mappings-generated.js

**Purpose:** Maps attribute names → CSS variables for save.js

```javascript
export const CSS_VAR_MAPPINGS = {
  accordion: {
    titleColor: {
      cssVar: '--accordion-title-color',
      unit: null,
      type: 'string'
    },
    titleFontSize: {
      cssVar: '--accordion-title-font-size',
      unit: 'px',
      type: 'number'
    },
    borderRadius: {
      cssVar: '--accordion-border-radius',
      unit: 'px',
      type: 'object'
    },
  },
};

// Helper: Format value with units
export function formatCssValue(attrName, value, blockType) {
  const mapping = CSS_VAR_MAPPINGS[blockType]?.[attrName];
  if (!mapping) return null;

  // Object types (borderRadius)
  if (mapping.type === 'object' && typeof value === 'object') {
    if (attrName.toLowerCase().includes('radius')) {
      return `${value.topLeft}px ${value.topRight}px ${value.bottomRight}px ${value.bottomLeft}px`;
    }
  }

  // Numbers with units
  if (mapping.unit && typeof value === 'number') {
    return `${value}${mapping.unit}`;
  }

  // Strings
  return value;
}
```

### Generated File: _theme-generated.scss

**Purpose:** Tier 1 CSS defaults with CSS variables and state-specific selectors

**Generated by:** `build-tools/css-generator.js`

**State-Aware CSS Generation:**

The schema compiler now generates **state-specific selectors** based on the `state` field in each attribute:

```scss
/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated from: schemas/tabs.json + schemas/tabs-structure.json
 */

.tab-button {
  /* BASE STATE - no special selector */
  color: var(--tabs-button-color, #666666);
  background-color: var(--tabs-button-bg, #f5f5f5);
  font-size: var(--tabs-button-font-size, 16px);
  border-color: var(--tabs-button-border-color, #dddddd);
  border-width: var(--tabs-button-border-width, 1px);
  border-radius: var(--tabs-button-border-radius, 4px 4px 0px 0px);

  /* HOVER STATE - :hover pseudo-selector */
  &:hover {
    color: var(--tabs-button-hover-color, #333333);
    background-color: var(--tabs-button-hover-bg, #e8e8e8);
  }

  /* ACTIVE STATE - .active class selector */
  &.active {
    color: var(--tabs-button-active-color, #333333);
    background-color: var(--tabs-button-active-bg, #ffffff);
    border-color: var(--tabs-button-active-border-color, #dddddd);
    border-bottom-color: var(--tabs-button-active-border-bottom-color, #ffffff);
  }
}

.tab-panel {
  background-color: var(--tabs-panel-bg, #ffffff);
  color: var(--tabs-panel-color, #333333);
  border-color: var(--tabs-panel-border-color, #dddddd);
}
```

**How State-Aware Generation Works:**

1. **Schema defines state:**
   ```json
   "tabButtonHoverColor": {
     "state": "hover",
     "appliesTo": "tabButton",
     "cssProperty": "color",
     "cssVar": "tabs-button-hover-color"
   }
   ```

2. **Compiler groups by element and state:**
   - Groups all properties by `appliesTo` (e.g., "tabButton")
   - Within each element, separates base state from interactive states
   - Generates appropriate selectors (`:hover`, `.active`, `:focus`, etc.)

3. **CSS Output:**
   - Base state: `.tab-button { color: var(...) }`
   - Hover state: `.tab-button:hover { color: var(...) }`
   - Active state: `.tab-button.active { color: var(...) }`

**Imported in style.scss:**
```scss
@use 'theme-generated';  // Imports _theme-generated.scss

// Your manual styles here...
.accordion-item {
  min-width: 300px;
  margin: 1em 0;
  overflow: hidden;
  // Border styles come from _theme-generated.scss
}
```

---

## Editor Component (edit.js)

**Location:** `blocks/accordion/src/edit.js`

The editor component is where users interact with the block in Gutenberg. It shows a PREVIEW of how the block will look and provides the sidebar controls.

### Key Concepts

**effectiveValues = attributes**

In the accordion block, `effectiveValues` is simply a reference to `attributes`. This is the **current state** of the block, which includes:
- Schema defaults (for properties not yet set)
- Theme values (if a theme is applied)
- User customizations (any changes made in the sidebar)

```javascript
// SOURCE OF TRUTH: attributes = merged state (what you see in sidebar)
const effectiveValues = attributes;
```

### Data Flow in Editor

```
┌─────────────────────────────────────────────────────────────┐
│                   EDITOR DATA FLOW                           │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. INITIALIZATION                                           │
│     ├─ Load schema defaults from accordion-attributes.js    │
│     ├─ useThemeManager hook loads themes from database      │
│     ├─ Cascade resolver merges: defaults + theme + custom   │
│     └─ Result stored in `attributes` (WordPress state)      │
│                                                              │
│  2. USER CHANGES VALUE IN SIDEBAR                            │
│     ├─ SchemaPanels component detects change                │
│     ├─ Calls setAttributes({ titleColor: '#ff0000' })       │
│     ├─ WordPress updates block attributes                   │
│     ├─ effectiveValues updates (points to attributes)       │
│     └─ Re-render triggered                                  │
│                                                              │
│  3. RENDER PREVIEW                                           │
│     ├─ getInlineStyles() reads from effectiveValues         │
│     ├─ Generates inline style objects                       │
│     ├─ Applies to JSX elements                              │
│     └─ User sees LIVE preview of changes                    │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### AUTO-GENERATED: getInlineStyles()

**Injected between markers in edit.js**

This function converts base state attribute values into React inline style objects for the editor preview. Interactive states (hover, active, focus) are handled by CSS selectors on the frontend:

```javascript
/* ========== AUTO-GENERATED-STYLES-START ========== */
const getInlineStyles = () => {
  // Extract object-type attributes with fallbacks
  const tabButtonBorderRadius = effectiveValues.tabButtonBorderRadius || {
    "topLeft": 4,
    "topRight": 4,
    "bottomRight": 0,
    "bottomLeft": 0
  };

  return {
    container: {
      // BASE STATE ONLY - no hover/active styles here
      color: effectiveValues.tabButtonColor || '#666666',
      backgroundColor: effectiveValues.tabButtonBackgroundColor || '#f5f5f5',
      borderColor: effectiveValues.tabButtonBorderColor || '#dddddd',
      borderWidth: `${effectiveValues.tabButtonBorderWidth || 1}px`,
      borderStyle: effectiveValues.tabButtonBorderStyle || 'solid',
      borderRadius: `${tabButtonBorderRadius.topLeft}px ${tabButtonBorderRadius.topRight}px ${tabButtonBorderRadius.bottomRight}px ${tabButtonBorderRadius.bottomLeft}px`,
      fontSize: `${effectiveValues.tabButtonFontSize || 16}px`,
      fontWeight: effectiveValues.tabButtonFontWeight || '500',
    },
    content: {
      borderColor: effectiveValues.dividerBorderColor || '#dddddd',
      borderWidth: `${effectiveValues.dividerBorderWidth || 1}px`,
      borderStyle: effectiveValues.dividerBorderStyle || 'solid',
    },
    icon: {
      color: effectiveValues.iconColor || '#666666',
      fontSize: `${effectiveValues.iconSize || 16}px`,
    },
  };
};
/* ========== AUTO-GENERATED-STYLES-END ========== */
```

**Special Case: Manual State Handling for Tabs**

For blocks that need to show different states in the editor (like active tabs), this is handled **manually** outside the auto-generated code:

```javascript
// Manual code in edit.js (NOT auto-generated)
const styles = getInlineStyles();

// Add manual state handler for active tabs in editor
styles.tabButton = (isActive, isDisabled) => {
  const baseStyles = {
    color: effectiveValues.tabButtonColor,
    backgroundColor: effectiveValues.tabButtonBackgroundColor,
    borderColor: effectiveValues.tabButtonBorderColor,
    // ... other base styles
  };

  if (isActive) {
    // Show active state in editor for selected tab
    return {
      ...baseStyles,
      color: effectiveValues.tabButtonActiveColor,
      backgroundColor: effectiveValues.tabButtonActiveBackgroundColor,
      borderColor: effectiveValues.tabButtonActiveBorderColor,
    };
  }

  return baseStyles;
};
```

**Why manual state handling?**
- Tabs need to visually indicate which tab is selected in the editor
- This is a **functional requirement** for the editor, not a hover/focus interaction
- The active state attributes are still used, but applied conditionally via JavaScript

**How it's used:**

```javascript
const styles = getInlineStyles();

return (
  <div {...blockProps} style={rootStyles}>
    <div className="accordion-title" style={styles.title}>
      <span>{attributes.title}</span>
      <span style={styles.icon}>▾</span>
    </div>

    <div className="accordion-content" style={styles.content}>
      <InnerBlocks />
    </div>
  </div>
);
```

### Schema Defaults Extraction

**Critical for cascade resolution:**

```javascript
// Extract schema defaults from accordionAttributes (SINGLE SOURCE OF TRUTH!)
const schemaDefaults = useMemo(() => {
  const defaults = {};
  Object.keys(accordionAttributes).forEach((key) => {
    if (accordionAttributes[key].default !== undefined) {
      defaults[key] = accordionAttributes[key].default;
    }
  });
  return defaults;
}, []);

// Merge with system defaults
const allDefaults = useMemo(() => {
  return getAllDefaults(schemaDefaults);
}, [schemaDefaults]);
```

**Why this matters:**
- `schemaDefaults` comes from auto-generated `accordion-attributes.js`
- These are the **Tier 1 defaults** that match `_theme-generated.scss`
- Used by theme system to calculate deltas (what changed from default)

### Theme Manager Hook

**Provides all theme functionality:**

```javascript
const {
  themes,                     // All available themes
  themesLoaded,              // Loading state
  currentTheme,              // Active theme name
  expectedValues,            // defaults + theme (no customizations)
  isCustomized,              // Has user made changes?
  sessionCache,              // Temporary customization storage
  handlers: {
    handleSaveNewTheme,
    handleUpdateTheme,
    handleDeleteTheme,
    handleRenameTheme,
    handleResetCustomizations,
    handleThemeChange,
  },
} = useThemeManager({
  blockType: 'accordion',
  schema: accordionSchema,
  attributes,
  setAttributes,
  allDefaults,
});
```

**Key variables:**
- `expectedValues` = What the block SHOULD look like (defaults + current theme)
- `attributes` = What the block ACTUALLY looks like (includes customizations)
- `isCustomized` = `attributes !== expectedValues`

### Sidebar Panels (Auto-Generated)

**SchemaPanels component generates UI from schema:**

```javascript
<SchemaPanels
  schema={accordionSchema}
  attributes={attributes}
  setAttributes={setAttributes}
  effectiveValues={effectiveValues}
  theme={themes[attributes.currentTheme]?.values}
  cssDefaults={allDefaults}
/>
```

This reads the schema and generates:
- Color pickers for `control: "ColorPicker"`
- Range sliders for `control: "RangeControl"`
- Dropdowns for `control: "SelectControl"`
- Grouped into panels by `group: "headerColors"`, etc.

**Example: TitleColor ColorPicker**

Schema defines:
```json
{
  "titleColor": {
    "type": "string",
    "default": "#333333",
    "control": "ColorPicker",
    "label": "Title Color",
    "description": "Text color for the accordion title"
  }
}
```

SchemaPanels generates:
```javascript
<ColorPicker
  label="Title Color"
  help="Text color for the accordion title"
  value={effectiveValues.titleColor || '#333333'}
  onChange={(newColor) => setAttributes({ titleColor: newColor })}
/>
```

---

## Save Component (save.js)

**Location:** `blocks/accordion/src/save.js`

The save component outputs the **HTML that gets saved to the database**. This HTML is what WordPress serves to visitors on the frontend.

### Critical Difference: Editor vs. Save

| Component | Purpose | Styles Applied |
|-----------|---------|----------------|
| **edit.js** | Editor preview | Inline styles (ALL values for instant preview) |
| **save.js** | Database/Frontend HTML | Inline CSS variables (ONLY customizations) |

**Why the difference?**

- **Editor:** Needs instant feedback, no CSS files loaded, use inline styles
- **Frontend:** Has CSS files (Tier 1 + Tier 2), only output Tier 3 overrides

### Data Flow in Save

```
┌─────────────────────────────────────────────────────────────┐
│                    SAVE DATA FLOW                            │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. EXTRACT DEFAULTS                                         │
│     ├─ Read from accordion-attributes.js                    │
│     ├─ Build schemaDefaults object                          │
│     └─ Call getAllDefaults(schemaDefaults)                  │
│                                                              │
│  2. GET EFFECTIVE VALUES                                     │
│     ├─ getAllEffectiveValues(attributes, {}, allDefaults)   │
│     ├─ Used for rendering (icon display, etc.)              │
│     └─ NOT for styles (those come from customizations)      │
│                                                              │
│  3. BUILD CUSTOMIZATION STYLES (TIER 3)                      │
│     ├─ getCustomizationStyles() reads attributes.customizations │
│     ├─ Loops through each customization                     │
│     ├─ Maps attr name → CSS variable via getCssVarName()    │
│     ├─ Formats value with unit via formatCssValue()         │
│     └─ Returns object: { '--accordion-title-color': '#f00' }│
│                                                              │
│  4. OUTPUT HTML                                              │
│     ├─ Add theme class: .accordion-theme-{name}             │
│     ├─ Add inline styles ONLY if customizations exist       │
│     └─ Frontend receives clean HTML                         │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Schema Defaults in Save

**Must extract defaults from auto-generated attributes:**

```javascript
// Extract schema defaults (single source of truth)
const schemaDefaults = {};
Object.keys(accordionAttributes).forEach((key) => {
  if (accordionAttributes[key].default !== undefined) {
    schemaDefaults[key] = accordionAttributes[key].default;
  }
});
const allDefaults = getAllDefaults(schemaDefaults);
```

### Effective Values (for rendering)

```javascript
// Get effective values for display purposes (icon rendering, etc.)
const effectiveValues = getAllEffectiveValues(
  attributes,
  {}, // Themes are resolved server-side via CSS classes
  allDefaults,
  'accordion'
);
```

**Note:** `effectiveValues` in save.js is used for **content rendering** (like which icon to show), NOT for styles. Styles come from CSS classes and inline customizations.

### AUTO-GENERATED: getCustomizationStyles()

**The most important function in save.js:**

```javascript
/* ========== AUTO-GENERATED-CUSTOMIZATION-STYLES-START ========== */
const getCustomizationStyles = () => {
  const styles = {};

  // Get customizations (deltas from expected values, calculated in edit.js)
  const customizations = attributes.customizations || {};

  // Process each customization using schema-generated mappings
  Object.entries(customizations).forEach(([attrName, value]) => {
    if (value === null || value === undefined) {
      return;
    }

    // Get CSS variable name from generated mappings
    const cssVar = getCssVarName(attrName, 'accordion');
    if (!cssVar) {
      return; // Attribute not mapped to a CSS variable
    }

    // Format value with proper unit from generated mappings
    const formattedValue = formatCssValue(attrName, value, 'accordion');
    if (formattedValue !== null) {
      styles[cssVar] = formattedValue;
    }
  });

  return styles;
};
/* ========== AUTO-GENERATED-CUSTOMIZATION-STYLES-END ========== */
```

**How it works:**

1. **Read `attributes.customizations`** - This is calculated by the theme manager in edit.js
   - Only contains values that differ from (defaults + theme)
   - Example: `{ titleColor: '#ff0000', titleFontSize: 24 }`

2. **Map to CSS variables** - `getCssVarName('titleColor', 'accordion')`
   - Returns: `'--accordion-title-color'`

3. **Format with units** - `formatCssValue('titleFontSize', 24, 'accordion')`
   - Returns: `'24px'` (adds 'px' unit from schema)

4. **Build styles object**
   ```javascript
   {
     '--accordion-title-color': '#ff0000',
     '--accordion-title-font-size': '24px'
   }
   ```

### Output HTML Structure

```javascript
const customizationStyles = getCustomizationStyles();

// Build class names
const classNames = ['accordion-item', 'wp-block-accordion', 'sammu-blocks'];

// Add theme class if using a theme
if (attributes.currentTheme) {
  classNames.push(`accordion-theme-${attributes.currentTheme}`);
}

const blockProps = useBlockProps.save({
  className: classNames.join(' '),
  'data-accordion-id': accordionId,
  // Add customization styles ONLY if they exist
  ...(Object.keys(customizationStyles).length > 0 && {
    style: customizationStyles
  }),
});

return (
  <div {...blockProps}>
    <div className="accordion-title-wrapper">
      <button className="accordion-title" aria-expanded="false">
        <span>{ attributes.title }</span>
        <span className="accordion-icon">▾</span>
      </button>
    </div>

    <div className="accordion-content" hidden>
      <InnerBlocks.Content />
    </div>
  </div>
);
```

**Resulting HTML (without customizations):**

```html
<div class="accordion-item wp-block-accordion sammu-blocks accordion-theme-dark"
     data-accordion-id="acc-abc123">
  <div class="accordion-title-wrapper">
    <button class="accordion-title" aria-expanded="false">
      <span>My Accordion</span>
      <span class="accordion-icon">▾</span>
    </button>
  </div>
  <div class="accordion-content" hidden>
    <p>Content here...</p>
  </div>
</div>
```

**Resulting HTML (with customizations):**

```html
<div class="accordion-item wp-block-accordion sammu-blocks accordion-theme-dark"
     data-accordion-id="acc-abc123"
     style="--accordion-title-color: #ff0000; --accordion-title-font-size: 24px">
  <!-- Same structure as above -->
</div>
```

---

## Frontend Rendering

The frontend uses the **3-tier CSS cascade** combined with **state-specific selectors** to determine final styles.

### How CSS Variables Cascade with States

**The Complete State Cascade:**

Frontend rendering applies styles in this priority order:
1. **State selectors** (`:hover`, `.active`) override base state
2. **Tier 3** (inline customizations) override everything
3. **Tier 2** (theme CSS) overrides Tier 1
4. **Tier 1** (defaults from _theme-generated.scss) is the fallback

**Example: Tabs Button with All States**

```scss
// TIER 1: Defaults from _theme-generated.scss
.tab-button {
  // Base state
  color: var(--tabs-button-color, #666666);
  background-color: var(--tabs-button-bg, #f5f5f5);

  // Hover state
  &:hover {
    color: var(--tabs-button-hover-color, #333333);
    background-color: var(--tabs-button-hover-bg, #e8e8e8);
  }

  // Active state
  &.active {
    color: var(--tabs-button-active-color, #333333);
    background-color: var(--tabs-button-active-bg, #ffffff);
  }
}
```

If a theme is applied, PHP generates **Tier 2 CSS** at runtime:

```css
// Tier 2: Theme CSS (generated by theme-css-generator.php)
.tabs-theme-dark {
  --tabs-button-color: #999999;
  --tabs-button-bg: #2a2a2a;
  --tabs-button-hover-color: #ffffff;
  --tabs-button-hover-bg: #3a3a3a;
  --tabs-button-active-color: #ffffff;
  --tabs-button-active-bg: #1a1a1a;
}
```

If customizations exist, **Tier 3 inline styles** override:

```html
<div class="wp-block-tabs tabs-theme-dark"
     style="--tabs-button-hover-color: #ff0000; --tabs-button-active-bg: #00ff00">
```

**State Cascade Resolution Examples:**

**Example 1: Hover state with customizations**
```
User hovers over .tab-button

1. Browser applies :hover selector
2. Looks up var(--tabs-button-hover-color, #333333)
3. Check inline style: --tabs-button-hover-color: #ff0000 ✓ FOUND (TIER 3)
4. Result: #ff0000 (customization wins)
```

**Example 2: Active state with theme, no customizations**
```
Tab button has .active class

1. Browser applies .active selector
2. Looks up var(--tabs-button-active-bg, #ffffff)
3. Check inline style: (none for this variable)
4. Check .tabs-theme-dark: --tabs-button-active-bg: #1a1a1a ✓ FOUND (TIER 2)
5. Result: #1a1a1a (theme wins)
```

**Example 3: Base state with no theme, no customizations**
```
Default tab button state

1. Looks up var(--tabs-button-color, #666666)
2. Check inline style: (none)
3. Check parent classes: (none)
4. Use fallback: #666666 (TIER 1 default)
```

**Key Insight:** States (hover, active) and tiers (1, 2, 3) work **independently**:
- Each state has its own set of CSS variables
- Each variable can be overridden at any tier
- A customization (Tier 3) for hover state doesn't affect base or active states

### Frontend JavaScript

**Location:** `blocks/accordion/src/frontend.js`

Handles interactivity (open/close, animations, keyboard navigation).

**Key responsibilities:**
- Toggle `is-open` class
- Update ARIA attributes (`aria-expanded`)
- Animate height transitions
- Icon rotation/switching
- Keyboard navigation

**Does NOT handle styles** - all styling comes from CSS cascade!

```javascript
function openAccordionItem(item, button, panel, animate) {
  // Update classes
  item.classList.add('is-open');

  // Update ARIA
  button.setAttribute('aria-expanded', 'true');
  panel.removeAttribute('hidden');

  // Animate (height/opacity only - colors come from CSS)
  if (animate) {
    animateOpen(panel);
  }
}
```

---

## UI State Management (Base vs Interactive States)

Understanding the difference between editor preview and frontend rendering is critical for the state-aware system.

### Editor: Base State Only

**The editor shows a STATIC PREVIEW**, which means:

1. **No hover effects** - You can't hover over elements in the editor preview to see hover colors
2. **No focus states** - Keyboard focus states don't apply in the editor
3. **Limited active states** - Only shown when functionally necessary (e.g., selected tab in tabs block)

**Why?**
- The editor is built with React and inline styles
- Real CSS pseudo-selectors (`:hover`, `:focus`) don't work with inline styles
- Simulating these states would require complex JavaScript and decrease performance

**What the editor DOES show:**
- Base state styling (default appearance)
- Active states for functional purposes (e.g., which tab is selected)
- Immediate visual feedback when changing base state attributes

### Frontend: All States via CSS

**The frontend is FULLY INTERACTIVE**, which means:

1. **Hover works** - CSS `:hover` selector applies hover state variables
2. **Focus works** - CSS `:focus` selector applies focus state variables
3. **Active works** - CSS `.active` class applies active state variables
4. **All handled by CSS** - No JavaScript needed for state styling

**How it works:**
```scss
// State selectors work automatically on frontend
.tab-button {
  color: var(--tabs-button-color);        // Base state

  &:hover {
    color: var(--tabs-button-hover-color); // Hover state
  }

  &.active {
    color: var(--tabs-button-active-color); // Active state
  }
}
```

### State Detection in Attribute Names

The system uses **naming conventions** to detect state from attribute names:

**Pattern Detection Rules:**
- Contains "Hover" → `state: "hover"` → generates `:hover` selector
- Contains "Active" → `state: "active"` → generates `.active` selector
- Contains "Focus" → `state: "focus"` → generates `:focus` selector
- Contains "Disabled" → `state: "disabled"` → generates `.disabled` or `[disabled]` selector
- No state keyword → `state: "base"` or omitted → no special selector

**Examples:**

| Attribute Name | Detected State | Generated Selector |
|----------------|----------------|-------------------|
| `tabButtonColor` | `base` | `.tab-button { color: ... }` |
| `tabButtonHoverColor` | `hover` | `.tab-button:hover { color: ... }` |
| `tabButtonActiveColor` | `active` | `.tab-button.active { color: ... }` |
| `tabButtonFocusBorderColor` | `focus` | `.tab-button:focus { border-color: ... }` |

**Note:** While naming convention helps, the actual state is determined by the `state` field in the schema, not the attribute name.

### Complete State Flow: Tabs Example

**Schema Definition (3 states):**
```json
{
  "tabButtonColor": {
    "state": "base",
    "cssVar": "tabs-button-color",
    "default": "#666666"
  },
  "tabButtonHoverColor": {
    "state": "hover",
    "cssVar": "tabs-button-hover-color",
    "default": "#333333"
  },
  "tabButtonActiveColor": {
    "state": "active",
    "cssVar": "tabs-button-active-color",
    "default": "#333333"
  }
}
```

**Generated CSS (_theme-generated.scss):**
```scss
.tab-button {
  color: var(--tabs-button-color, #666666);

  &:hover {
    color: var(--tabs-button-hover-color, #333333);
  }

  &.active {
    color: var(--tabs-button-active-color, #333333);
  }
}
```

**Editor Behavior (edit.js):**
```javascript
// Auto-generated code uses ONLY base state
const styles = getInlineStyles();
// styles.container.color = effectiveValues.tabButtonColor

// Manual code handles active state for functional selection
styles.tabButton = (isActive) => {
  if (isActive) {
    return { color: effectiveValues.tabButtonActiveColor };
  }
  return { color: effectiveValues.tabButtonColor };
};
```

**Frontend Behavior:**
```html
<!-- Base state: gray text -->
<button class="tab-button">Tab 1</button>

<!-- Active state: dark text (via .active class) -->
<button class="tab-button active">Tab 2</button>

<!-- Hover: darker text (via :hover pseudo-selector) -->
<!-- User hovers → browser applies :hover styles automatically -->
```

**User Experience:**

| Action | Editor Preview | Frontend Result |
|--------|----------------|-----------------|
| Change base color | Updates immediately | Works on frontend |
| Change hover color | NO PREVIEW (can't hover in editor) | Works on frontend (hover to see) |
| Change active color | Shows if tab is selected in editor | Works on frontend (click to see) |
| Select a tab | Shows active state styling | Shows active state styling |

### Key Takeaways

1. **Editor = Base state + functional active states only**
2. **Frontend = All states via CSS selectors**
3. **Hover/focus states won't preview in editor** - this is expected and correct
4. **Test interactive states on the frontend**, not in the editor
5. **State cascade is independent from tier cascade** - each state has its own variables at each tier

---

## Complete User Interaction Flow

Let's trace what happens when a user changes values in the editor, including state-aware attributes.

### Scenario 1: User Changes Tab Button Base Color

**Step 1: Initial State**

```
Schema Default: #666666
Current Theme: "dark" (sets button color to #999999)
User customization: (none)
```

Editor shows: **#999999** (from theme, base state only)
Database has: `currentTheme: "dark"`, no customizations

**Step 2: User Opens Color Picker**

SchemaPanels renders ColorPicker:
```javascript
<ColorPicker
  label="Tab Button Color"
  value={effectiveValues.tabButtonColor}  // #999999 (from theme)
  onChange={(newColor) => setAttributes({ tabButtonColor: newColor })}
/>
```

**Step 3: User Selects #ff0000**

1. `setAttributes({ tabButtonColor: '#ff0000' })` called
2. WordPress updates block attributes
3. Theme manager detects change:
   ```javascript
   // Expected value (from theme): #999999
   // Actual value (from user): #ff0000
   // Customized? YES
   ```
4. Customization saved to session cache:
   ```javascript
   sessionCache = {
     tabs: {
       [clientId]: {
         tabButtonColor: '#ff0000'
       }
     }
   }
   ```
5. Re-render triggered

**Step 4: Editor Re-renders**

```javascript
const styles = getInlineStyles();
// styles.container.color = '#ff0000' (BASE STATE ONLY)

<button className="tab-button" style={styles.container}>
  Tab 1
</button>
```

User sees red button text in editor preview (base state).

**Step 5: User Saves Post**

1. Theme manager calculates final customizations:
   ```javascript
   customizations = {
     tabButtonColor: '#ff0000'  // Delta from theme
   }
   ```
2. `save.js` is called:
   ```javascript
   const customizationStyles = getCustomizationStyles();
   // Returns: { '--tabs-button-color': '#ff0000' }
   ```
3. HTML saved to database:
   ```html
   <div class="wp-block-tabs tabs-theme-dark"
        style="--tabs-button-color: #ff0000">
   ```

**Step 6: Frontend Display**

Browser loads:
1. **Tier 1 CSS** (from _theme-generated.scss):
   ```scss
   .tab-button {
     color: var(--tabs-button-color, #666666);
   }
   ```

2. **Tier 2 CSS** (from PHP-generated theme CSS):
   ```css
   .tabs-theme-dark {
     --tabs-button-color: #999999;
   }
   ```

3. **Tier 3 inline** (from HTML):
   ```html
   style="--tabs-button-color: #ff0000"
   ```

4. **Cascade resolution:**
   ```
   var(--tabs-button-color, #666666)
   → Check inline: #ff0000 ✓ (TIER 3)
   → Result: #ff0000
   ```

**Final result:** Tab buttons display red text (#ff0000)

---

### Scenario 2: User Changes Tab Button Hover Color

**Key Difference:** Hover state changes DON'T preview in the editor!

**Step 1: User Changes Hover Color to Orange**

```javascript
<ColorPicker
  label="Tab Button Hover Color"
  value={effectiveValues.tabButtonHoverColor}  // #ffffff (from theme)
  onChange={(newColor) => setAttributes({ tabButtonHoverColor: newColor })}
/>
```

User selects: **#ff8800**

**Step 2: Editor Behavior**

```javascript
// Auto-generated getInlineStyles() DOES NOT include hover state
const styles = getInlineStyles();
// styles.container ONLY has base state properties
```

**Result:** Editor preview shows NO CHANGE because hover states aren't rendered in editor.

**Step 3: Frontend Behavior**

HTML saved to database:
```html
<div class="wp-block-tabs tabs-theme-dark"
     style="--tabs-button-hover-color: #ff8800">
```

Frontend CSS applies hover state:
```scss
.tab-button:hover {
  color: var(--tabs-button-hover-color, #333333);
  // Resolves to: #ff8800 (from inline Tier 3)
}
```

**Final result:** When user hovers over tab on frontend, text turns orange (#ff8800)

**Note:** Hover states can be tested on the frontend after saving the post.

---

## Critical Implementation Details

### 1. Why effectiveValues Points to Attributes

In accordion block, this simplification works:
```javascript
const effectiveValues = attributes;
```

**Reason:** The theme manager ALREADY merges defaults + theme + customizations into `attributes` via the cascade resolver. So `attributes` IS the effective values.

**Alternative approach (used in older code):**
```javascript
const effectiveValues = getAllEffectiveValues(
  attributes,
  currentTheme?.values,
  allDefaults
);
```

Both work, but direct reference is simpler.

### 2. The customizations Attribute

**This is a SPECIAL attribute** added by the theme manager:

```javascript
attributes.customizations = {
  titleColor: '#ff0000',
  titleFontSize: 24
}
```

**How it's calculated:**

```javascript
// In theme manager:
const customizations = {};
const expectedValues = { ...allDefaults, ...currentTheme?.values };

Object.keys(attributes).forEach((key) => {
  if (attributes[key] !== expectedValues[key]) {
    customizations[key] = attributes[key];
  }
});

setAttributes({ customizations });
```

**Why it matters:**
- `save.js` ONLY outputs styles for keys in `customizations`
- Keeps HTML clean (no inline styles for theme/default values)
- Enables "Reset Customizations" feature

### 3. CSS Variable Naming Convention

**Schema:**
```json
{
  "cssVar": "accordion-title-color"
}
```

**Generated outputs:**

| File | Variable Format |
|------|----------------|
| _theme-generated.scss | `--accordion-title-color` |
| css-var-mappings-generated.js | `--accordion-title-color` |
| save.js output | `--accordion-title-color` |

**Consistency is critical!** The `--` prefix is added during generation, not in schema.

### 4. Object-Type Attributes (borderRadius)

**Schema:**
```json
{
  "borderRadius": {
    "type": "object",
    "default": {
      "topLeft": 4,
      "topRight": 4,
      "bottomRight": 4,
      "bottomLeft": 4
    },
    "unit": "px",
    "cssProperty": "border-radius"
  }
}
```

**Formatting in save.js:**

```javascript
if (attrName.toLowerCase().includes('radius')) {
  return `${value.topLeft}px ${value.topRight}px ${value.bottomRight}px ${value.bottomLeft}px`;
}
```

**Output:**
```html
style="--accordion-border-radius: 8px 8px 0px 0px"
```

### 5. Number vs String Defaults

**In schema, use the ACTUAL type:**

```json
{
  "titleFontSize": {
    "type": "number",
    "default": 18,      // NOT "18px"
    "unit": "px"
  }
}
```

**Unit is added during:**
- Code generation (in _theme-generated.scss: `18px`)
- Value formatting (in save.js: `formatCssValue` adds 'px')

**In accordion-attributes.js:**
```javascript
titleFontSize: {
  type: 'number',
  default: 18,  // Number without unit
}
```

**In editor (edit.js):**
```javascript
fontSize: `${effectiveValues.titleFontSize || 18}px`  // Add unit
```

### 6. Fallback Values in CSS

**Always provide fallbacks:**

```scss
// Good
color: var(--accordion-title-color, #333333);

// Bad - no fallback
color: var(--accordion-title-color);
```

**Why:** If variable isn't set (no theme, no customization), browser needs a default.

### 7. CSS Selector Grouping

**Schema uses `appliesTo` to group properties:**

```json
{
  "titleColor": {
    "appliesTo": "title",
    "cssProperty": "color"
  },
  "titleFontSize": {
    "appliesTo": "title",
    "cssProperty": "font-size"
  }
}
```

**Generated CSS groups by selector:**

```scss
.accordion-title {
  color: var(--accordion-title-color, #333333);
  font-size: var(--accordion-title-font-size, 18px);
}
```

### 8. The Role of structure Schema

**New dual-schema system:**
- `accordion.json` - Attributes and their properties
- `accordion-structure.json` - DOM structure and selectors

**Structure schema defines elements:**

```json
{
  "elements": {
    "title": {
      "className": "accordion-title",
      "tag": "button"
    },
    "content": {
      "className": "accordion-content",
      "tag": "div"
    }
  }
}
```

**How it's used:**
- CSS generator reads `appliesTo: "title"` from attribute schema
- Looks up `elements.title.className` in structure schema
- Generates `.accordion-title { }` CSS

---

## Summary: The Complete Loop

```
┌──────────────────────────────────────────────────────────────┐
│            COMPLETE DATA FLOW (State-Aware System)            │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  schemas/tabs.json                                            │
│         ↓                                                     │
│  npm run schema:build                                         │
│         ↓                                                     │
│  ┌─────────────────────────────────────┐                     │
│  │ GENERATES 24 FILES:                 │                     │
│  │ - tabs-attributes.js                │                     │
│  │ - _theme-generated.scss (w/ states) │                     │
│  │ - css-var-mappings-generated.js     │                     │
│  │ - control-config-generated.js       │                     │
│  │ - (and more...)                     │                     │
│  └─────────────────────────────────────┘                     │
│         ↓                                                     │
│  _theme-generated.scss separates states:                      │
│  .tab-button {                                                │
│    color: var(--tabs-button-color);           // base         │
│    &:hover { color: var(...-hover-color); }  // hover        │
│    &.active { color: var(...-active-color); } // active      │
│  }                                                            │
│         ↓                                                     │
│  blocks/tabs/src/edit.js                                      │
│         ├─ Reads tabs-attributes.js for defaults             │
│         ├─ useThemeManager loads themes                      │
│         ├─ SchemaPanels generates UI from schema             │
│         ├─ getInlineStyles() applies BASE STATE ONLY         │
│         └─ User sees live preview (base + functional active) │
│                ↓                                              │
│         User makes changes                                    │
│                ↓                                              │
│         setAttributes({ tabButtonHoverColor: '#ff8800' })    │
│                ↓                                              │
│         Theme manager calculates customizations              │
│                ↓                                              │
│  attributes.customizations = {                                │
│    tabButtonHoverColor: '#ff8800'                             │
│  }                                                            │
│                ↓                                              │
│  blocks/tabs/src/save.js                                      │
│         ├─ getCustomizationStyles() reads customizations     │
│         ├─ Maps to CSS variables (ALL states)                │
│         ├─ Outputs: style="--tabs-button-hover-color: ..."   │
│         └─ HTML saved to database                            │
│                ↓                                              │
│  FRONTEND RENDERING (All States Work!)                        │
│         ├─ Browser loads _theme-generated.scss (TIER 1)      │
│         │  └─ Contains base + :hover + .active selectors     │
│         ├─ PHP injects theme CSS (TIER 2)                    │
│         │  └─ Variables for all states                       │
│         ├─ HTML has inline customizations (TIER 3)           │
│         │  └─ Override variables for any state               │
│         └─ CSS cascade resolves each state:                  │
│            - Base: TIER 3 > TIER 2 > TIER 1                  │
│            - Hover: TIER 3 > TIER 2 > TIER 1                 │
│            - Active: TIER 3 > TIER 2 > TIER 1                │
│                ↓                                              │
│  User interacts with tabs on frontend:                        │
│         ├─ Default state: base styles                        │
│         ├─ Hover over tab: :hover styles apply               │
│         └─ Click tab: .active class applies                  │
│                                                               │
└──────────────────────────────────────────────────────────────┘
```

---

## Key Takeaways

1. **Schema is the single source of truth** - ALL code generation starts here

2. **3-tier cascade is fundamental** - Tier 1 (defaults) → Tier 2 (themes) → Tier 3 (custom)

3. **State-aware CSS generation** - `state` field in schema generates proper selectors (`:hover`, `.active`, etc.)

4. **Editor shows base state only** - Interactive states (hover, focus) don't preview in editor

5. **Frontend handles all states** - All interactive states work automatically via CSS selectors

6. **State cascade is independent** - Each state (base, hover, active) has its own 3-tier cascade

7. **Auto-generated code is sacred** - NEVER edit between `AUTO-GENERATED` markers

8. **edit.js uses inline styles** - For instant preview in editor (base state only)

9. **save.js uses CSS variables** - For proper cascade on frontend (all states)

10. **customizations attribute is special** - Contains ONLY deltas from expected values (any state)

11. **CSS variables enable the cascade** - Same variable name across all tiers

12. **formatCssValue handles units** - Schema defines unit, formatter applies it

13. **Theme manager orchestrates everything** - Loads themes, calculates deltas, manages cache

14. **Frontend is pure CSS** - No JavaScript needed for state styling (only interactions)

15. **Test interactive states on frontend** - Hover/focus states won't work in editor preview

---

**End of Documentation**

*Last Updated: 2025-12-11*
*For: Guttemberg Plus WordPress Plugin*
*Version: 1.0.0 (State-Aware CSS System)*

**Major Changes:**
- Added comprehensive state-aware CSS generation documentation
- Documented `state` field usage in schema attributes
- Clarified editor base-state-only rendering vs frontend full-state rendering
- Added detailed examples using tabs block with hover/active states
- Updated all diagrams and examples to reflect state cascade system
