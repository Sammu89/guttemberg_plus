# Unified Schema Architecture (Single Source of Truth)

## Purpose

Document the **single-source** schema pipeline. This repo is expected to run a
unified build where **one comprehensive schema** is generated from the minimal
schema + HTML structure, and **all outputs** are derived from that comprehensive
schema (edit.js, save.js, UI panels, CSS vars, SCSS, validators, types).

---

## üîß Recent Fix: Complete Pipeline (2026-01-19)

**Problem:** CSS variables were defined (`:root`) but never applied to DOM elements. Blocks had no styling.

**Root Cause:** Build pipeline was missing **Step 4** - the SCSS generator that applies CSS variables to selectors.

**Fix Applied:**
1. ‚úÖ Added Step 4 to `tools/build.js` - generates `styles/blocks/{block}/generated/styles-generated.scss`
2. ‚úÖ Created `tools/generators/css-vars-editor-js.js` - generates inline CSS vars for editor preview
3. ‚úÖ Updated all `frontend.scss` files to import generated selector rules
4. ‚úÖ Pipeline now generates **18 files** instead of 15

**Files Generated:**
- `styles/blocks/accordion/generated/styles-generated.scss` ‚≠ê **Applies CSS to selectors**
- `shared/styles/accordion-css-vars-generated.js` ‚≠ê **Converts atomic attrs ‚Üí inline CSS vars**
- Same for tabs and toc blocks

**Result:** Schema-driven styling now works end-to-end! Changes in sidebar instantly apply in editor.

---

## Unified Build Pipeline (Required)

- **Inputs (human edited):**
  - `schemas/{block}.json` (minimal schema + macros)
  - `schemas/{block}-structure.html` (DOM structure)
- **Single transform:**
  - `schemas/parser/main-orchestrator.js` expands macros, merges structure, and writes:
    - `schemas/{block}-comprehensive-autogenerated.json`
- **All generators consume the comprehensive schema:**
  - edit.js/save.js injection
  - UI panel rendering
  - CSS var mapping + SCSS vars
  - JS/TS/PHP config outputs
  - validators + docs

---

## Core Principles

### 1. **Single Source of Truth**
One comprehensive schema drives CSS, edit.js, save.js, UI panels, validators, and mappings.

### 2. **Kebab-Case Attributes**
Comprehensive schema attributes are kebab-case to align with CSS vars:
```javascript
"title-icon-size"  ‚Üí --accordion-title-icon-size
"border-top-color" ‚Üí --accordion-border-top-color
```
Note: source schemas can remain camelCase; expanders normalize to kebab-case.

### 3. **Auto-Generated CSS Variables**
CSS variable names follow a strict formula:
```
--{blockType}-{element}-{cssProperty}[-state][-device]
```

Examples:
- `--accordion-title-color` (base state, desktop)
- `--accordion-title-color-hover` (hover state, desktop)
- `--accordion-icon-font-size-is-open-tablet` (open state, tablet)

### 4. **No Redundancy**
- Element details stored once in the structure map
- CSS vars auto-generated from attribute metadata
- UI ordering driven by `panelId`/group metadata carried in the comprehensive schema

---

## Required Comprehensive Schema Contents

The comprehensive schema must carry **all** data needed to build everything:
- `attributes`: atomic, kebab-case attributes with cssProperty, element, state, responsive
- `panelId` / `group` / `subgroup` / `control` metadata for UI layout
- `defaults` or `defaultValues` map for atomic defaults
- `structure` or a linked structure map (elements + selectors)
- `cssVarMap`, `selectorVarMap`, `responsiveSelectors`
- `cssVarVariants` for responsive attrs (desktop/tablet/mobile)

## Unified Architecture Flow

```
schemas/blocks/{block}.json + schemas/{block}-structure.html
        ‚Üì
[Step 1] schemas/parser/orchestrator.js
        ‚Üì
schemas/generated/{block}.json (comprehensive schema)
        ‚Üì
[Step 2] Generate Block Attributes
        ‚Üì
blocks/{block}/attributes.js (106 atomic attributes)
        ‚Üì
[Step 3] Generate CSS Variables
        ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3A: styles/blocks/{block}/variables.scss           ‚îÇ  ‚Üê :root CSS variable definitions
‚îÇ 3B: shared/styles/{block}-css-vars-generated.js   ‚îÇ  ‚Üê Inline CSS vars (editor)
‚îÇ 3C: shared/styles/{block}-frontend-css-vars.js    ‚îÇ  ‚Üê Frontend CSS vars (save)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚Üì
[Step 4] Generate SCSS Selector Rules ‚≠ê CRITICAL
        ‚Üì
styles/blocks/{block}/generated/styles-generated.scss  ‚Üê Applies CSS vars to selectors
        ‚Üì
Frontend SCSS imports generated file ‚Üí Webpack compiles ‚Üí CSS applied to DOM
```

**Key Files Generated:**
- **Comprehensive Schema**: `schemas/generated/{block}.json` (125 CSS vars, 106 attributes)
- **Block Attributes**: `blocks/{block}/attributes.js` (Gutenberg block registration)
- **CSS Variable Definitions**: `styles/blocks/{block}/variables.scss` (`:root` variables)
- **Inline CSS Vars (JS)**: `shared/styles/{block}-css-vars-generated.js` (editor preview)
- **Frontend CSS Vars (JS)**: `shared/styles/{block}-frontend-css-vars-generated.js` (save logic)
- **SCSS Selector Rules**: `styles/blocks/{block}/generated/styles-generated.scss` ‚≠ê **NEW - applies variables**

---

## Complete Build Pipeline (4 Steps)

### Command
```bash
npm run schema:build
```

### Step 1: Generate Comprehensive Schemas
**Generator:** `schemas/parsers/orchestrator.js`
**Input:**
- `schemas/blocks/{block}.json` (minimal schema with macros)
- `schemas/{block}-structure.html` (HTML template with DSL)

**Output:**
- `schemas/generated/{block}.json` (comprehensive schema)
- `schemas/{block}-structure-mapping-autogenerated.json` (element map)

**What it does:**
1. Parses HTML structure file to extract elements and relationships
2. Merges structure into minimal schema
3. Expands macros (box-panel ‚Üí 25+ atomic attributes, icon-panel ‚Üí 20+ attributes, etc.)
4. Auto-generates CSS variable names following formula: `--{block}-{element}-{property}[-state][-device]`
5. Applies responsive variants (desktop/tablet/mobile)
6. Builds composite attributes (border, padding shortcuts)
7. Extracts default values map
8. Builds CSS variable map (cssVar ‚Üí metadata)
9. Builds selector-to-variables map (for SCSS generation)
10. Builds responsive selectors array

**Result:** Comprehensive schema with 106 atomic attributes, 125 CSS variables

---

### Step 2: Generate Block Attributes
**Generator:** `tools/generators/attributes.js`
**Input:** `schemas/generated/{block}.json`
**Output:** `blocks/{block}/attributes.js`

**What it does:**
1. Reads comprehensive schema
2. Extracts all attributes with their types and defaults
3. Generates WordPress Gutenberg block attributes
4. Adds special attributes (currentTheme, customizations, blockId)

**Result:** Atomic attribute definitions for block registration

---

### Step 3: Generate CSS Variables (3 Sub-steps)

#### 3A: SCSS Variable Definitions
**Generator:** `tools/generators/css-vars-editor.js`
**Input:** `schemas/generated/{block}.json`
**Output:** `styles/blocks/{block}/variables.scss`

**What it does:**
1. Reads comprehensive schema's cssVarMap
2. Extracts default values for each CSS variable
3. Generates `:root { --accordion-title-color: #333; }` declarations
4. Sorts variables alphabetically

**Result:** 124 CSS variable definitions in `:root`

#### 3B: Inline CSS Variables (JavaScript - Editor)
**Generator:** `tools/generators/css-vars-editor-js.js` ‚≠ê **NEW**
**Input:** `schemas/generated/{block}.json`
**Output:** `shared/styles/{block}-css-vars-generated.js`

**What it does:**
1. Reads comprehensive schema's cssVarMap
2. Generates `buildEditorCssVars(attributes)` function
3. Maps atomic attributes to CSS variables:
   ```javascript
   if (attrs['block-box-border-width-top'] !== undefined) {
     cssVars['--accordion-item-border-top-width'] = attrs['block-box-border-width-top'];
   }
   ```
4. Returns object of CSS variables for inline styles

**Result:** Function that converts atomic attributes ‚Üí inline CSS vars for editor preview

**Why it's needed:** Editor needs real-time preview when sidebar values change

#### 3C: Frontend CSS Variables (JavaScript - Save)
**Generator:** `tools/generators/css-vars-frontend.js`
**Input:** `schemas/generated/{block}.json`
**Output:** `shared/styles/{block}-frontend-css-vars-generated.js`

**What it does:**
1. Separates themeable from non-themeable attributes
2. Generates `buildFrontendCssVars()` for save.js
3. Only outputs deltas (customizations) for themeable attributes
4. Always outputs non-themeable attributes

**Result:** Function for generating inline CSS in saved post content

---

### Step 4: Generate SCSS Selector Rules ‚≠ê **CRITICAL - APPLIES CSS TO DOM**
**Generator:** `schemas/parsers/expansors/scss-generator.js`
**Input:** `schemas/generated/{block}.json`
**Output:** `styles/blocks/{block}/generated/styles-generated.scss`

**What it does:**
1. Reads comprehensive schema (attributes + structure)
2. Groups attributes by: element √ó state √ó device
3. Builds selectors using formula:
   - Base: `.accordion-title`
   - Hover: `.accordion-title:hover`
   - Open state: `.gutplus-accordion.is-open .accordion-icon`
   - Tablet: `[data-gutplus-device="tablet"] .accordion-title`
4. For each group, generates SCSS rules:
   ```scss
   .accordion-title {
     padding-top: var(--accordion-title-padding-top);
     padding-right: var(--accordion-title-padding-right);
     color: var(--accordion-title-color);
     background: var(--accordion-title-background);
   }
   ```
5. Generates fallback chains for responsive vars:
   ```scss
   [data-gutplus-device="tablet"] .accordion-title {
     padding-top: var(--accordion-title-padding-top-tablet,
                      var(--accordion-title-padding-top));
   }
   ```

**Result:** Complete SCSS file that applies ALL CSS variables to correct selectors

**Why it's critical:**
- Without this step, CSS variables are DEFINED (`:root`) but NEVER APPLIED to elements
- This is what actually makes the styling work on the page
- Frontend SCSS files import this: `@import './generated/styles-generated.scss';`

---

## How It All Works Together

### Editor Preview Flow
1. User changes value in sidebar ‚Üí `setAttributes({ 'block-box-border-width-top': '2px' })`
2. React re-renders with new atomic attribute value
3. `buildEditorCssVars(attributes)` converts atomic attr ‚Üí CSS var
4. CSS variable applied as inline style: `style={{ '--accordion-item-border-top-width': '2px' }}`
5. Generated SCSS selector rule applies it: `.gutplus-accordion { border-top-width: var(--accordion-item-border-top-width); }`
6. Browser renders updated styling instantly

### Frontend Rendering Flow
1. Block saves atomic attributes to database
2. `save.js` calls `buildFrontendCssVars(customizations, attributes)`
3. Only customizations (deltas from theme) are output as inline CSS
4. Rendered HTML includes: `<div style="--accordion-title-color: #ff0000;">`
5. Generated SCSS applies variables to selectors (same as editor)
6. Frontend displays styled block correctly

---

## Build Switch: Concrete Steps

1. **Make `schema:build` call the parser first**
   - Run `schemas/parser/main-orchestrator.js` for each block.
   - Emit `schemas/{block}-comprehensive-autogenerated.json` plus structure mapping.
2. **Point all generators to the comprehensive schema**
   - CSS var builders, style builders, validators, types, docs, and edit/save injectors
     must read `schemas/{block}-comprehensive-autogenerated.json`.
3. **Update the sidebar renderer to use panel metadata**
   - `SchemaPanels` should group atomic attributes by `panelId`/`group`/`subgroup`
     and render the same UI controls without macro objects.
4. **Generate Gutenberg attributes from atomic attrs**
   - `blocks/{block}/src/{block}-attributes.js` should be derived from the comprehensive schema.
5. **Keep storage compact with compression**
   - Use `attribute-decompression` on load and `attribute-compression` on save
     so the editor can work with atomic values while the database stays compact.
6. **Stop writing `schemas/{block}-schema-autogenerated.json`**
   - The macro schema is no longer a build output once the unified pipeline is live.

---

## Parser Goal (Minimal -> Comprehensive)

This section describes the **Comprehensive Parser** in `schemas/parser`. It is the
only supported pipeline.

The parser system transforms a minimal schema into a fully comprehensive
schema that outputs all variables possible. This includes:
- Decomposed values per side (top/right/bottom/left) and per corner.
- Per-device responsive variants.
- All properties defined by the control group.
- A complete mapping of variables to their associated elements.

Later, the control panels and save logic will mesh/compress these atomic
properties back into grouped controls (e.g., if all sides match, emit a
single border-color). That compression happens on save, not in the parser.

Composite entries are auto-generated by the parser. Compression rules are
hardcoded per property family (not per attribute). Current rules:
- `padding`, `margin`, `border-width`, `border-style`, `border-color`: 1/2/3/4-value shorthands.
- `border-radius`: 1‚Äì4-value shorthand (no ellipse support).
- `border-{side}`: composed from `{side}-width/style/color` when all present.
- `border`: only valid when all four side values match (uses `border-top/right/bottom/left`).

The comprehensive schema should also include composite metadata referencing
atomic entries, e.g.:
`border-color` = (border-color-top, border-color-right, border-color-bottom, border-color-left)

Composite entries are stored as `type: "composite"` with a `compositeOf` list
of attribute keys. They do not emit CSS directly.

---

## HTML Template DSL (Domain Specific Language)

The HTML structure files use a powerful DSL that makes them the **single source of truth** for DOM structure, variations, and element relationships.

### DSL Features Overview

| Feature | Syntax | Purpose |
|---------|--------|---------|
| **Element ID** | `data-el="elementId"` | Mark elements for tracking |
| **Selector** | `class="primary-class"` | First class = CSS selector |
| **Conditional** | `data-when` / `data-else` | If/else branches |
| **Switch** | `data-switch` / `data-case` / `data-default` | Multi-way branches |
| **Slots** | `<template data-slot="name">` | Reusable fragments |
| **Placeholders** | `{variableName}` | Dynamic substitution |
| **Content Slot** | `<slot>` | InnerBlocks placeholder |

### 1. Element Identification: `data-el`

Marks elements for schema tracking. Each `data-el` creates an entry in the elements map.

```html
<div class="accordion-title" data-el="title">
  <span class="accordion-icon" data-el="icon"></span>
</div>
```

**Generated:**
```javascript
elements: {
  title: {
    id: "title",
    selector: ".accordion-title",  // First class
    tag: "div",
    parent: "item",
    children: ["icon"]
  }
}
```

### 2. Conditional Rendering: `data-when` / `data-else`

Create optional elements:

```html
<template data-when="headingLevel !== 'none'">
  <h{headingLevel} class="accordion-heading" data-el="heading">
    Header content
  </h{headingLevel}>
</template>
<template data-else>
  No header content
</template>
```

**Use Case:** Show heading wrapper only when user selects a heading level.

### 3. Switch Statements: `data-switch` / `data-case`

Multi-way layout variations:

```html
<template data-switch="iconPosition">
  <template data-case="box-left">
    <span data-el="iconSlot">Icon</span>
    <div data-el="titleText">Title</div>
  </template>
  <template data-case="box-right">
    <div data-el="titleText">Title</div>
    <span data-el="iconSlot">Icon</span>
  </template>
  <template data-default>
    <div data-el="titleInline">
      <span data-el="titleText">Title</span>
      <span data-el="icon">Icon inline</span>
    </div>
  </template>
</template>
```

**Use Case:** Different DOM structure based on icon position setting.

### 4. Reusable Fragments: `data-slot`

Define once, inject multiple times:

```html
<!-- Definition (with content) -->
<template data-slot="iconMarkup">
  <template data-when="iconSource.kind === 'image'">
    <img class="accordion-icon" data-el="icon" alt="">
  </template>
  <template data-else>
    <span class="accordion-icon" data-el="icon"></span>
  </template>
</template>

<!-- Injection (empty) -->
<div class="icon-wrapper">
  <template data-slot="iconMarkup"></template>
</div>
```

**Use Case:** Icon markup reused in multiple branches (box-left, box-right, inline).

### 5. String Substitution: `{placeholder}`

Dynamic values injected at render:

```html
<h{headingLevel} class="accordion-heading">
```

When `headingLevel = 3`:
```html
<h3 class="accordion-heading">
```

**Use Case:** Dynamic tag names, class names, attributes.

### 6. Content Placeholder: `<slot>`

Where user content (InnerBlocks) goes:

```html
<div class="accordion-content-inner" data-el="contentInner">
  <slot data-el="contentSlot"></slot>
</div>
```

**Generated:** Creates element with `isSlot: true`, used by save.js to place `<InnerBlocks>`.

### Complete DSL Example

```html
<div class="gutplus-accordion" data-el="item">
  <!-- Conditional wrapper -->
  <template data-when="headingLevel !== 'none'">
    <h{headingLevel} data-el="heading">
      <template data-slot="titleButton"></template>
    </h{headingLevel}>
  </template>

  <!-- Reusable button fragment -->
  <template data-slot="titleButton">
    <button class="accordion-title" data-el="title">
      <!-- Switch for icon position -->
      <template data-switch="iconPosition">
        <template data-case="left">
          <span data-el="icon">üìç</span>
          <span data-el="titleText">Title</span>
        </template>
        <template data-default>
          <span data-el="titleText">Title</span>
          <span data-el="icon">üìç</span>
        </template>
      </template>
    </button>
  </template>

  <!-- Content slot -->
  <div class="accordion-content" data-el="content">
    <slot data-el="contentSlot"></slot>
  </div>
</div>
```

**This single HTML file drives:**
- ‚úÖ edit.js generation (knows all variations)
- ‚úÖ save.js generation (knows DOM structure)
- ‚úÖ SCSS generation (knows selectors and hierarchy)
- ‚úÖ Zero manual sync required!

**For complete DSL reference, see:** `parser/html-parser.js` (200+ lines of inline documentation)

---

## File Structure

### Source Files (Human Editable)

#### `accordion.json` - Minimal Schema
**Contains**: High-level attribute definitions using macros
```json
{
  "blockType": "accordion",
  "attributes": {
    "titleColor": {
      "type": "color-panel",
      "appliesTo": "title",
      "states": ["base", "hover"],
      "default": {
        "text": "#333333",
        "background": "#f5f5f5",
        "hover": { "text": "#000000", "background": "#e8e8e8" }
      }
    },
    "titleIcon": {
      "type": "icon-panel",
      "cssVar": "accordion-icon",
      "appliesTo": "icon"
    }
  }
}
```

#### `accordion-structure.html` - HTML Template
**Contains**: DOM structure with DSL annotations
```html
<div class="gutplus-accordion" data-el="item">
  <button class="accordion-title" data-el="title">
    <span class="accordion-icon" data-el="icon"></span>
  </button>
  <div class="accordion-content" data-el="content"></div>
</div>
```

#### `accordion-structure.json` - Legacy Structure Schema
**Contains**: Element hierarchy + `appliesStyles` metadata used by older CSS generation tools (`build-tools/css-generator.js`). Not consumed by `schema-compiler`.

### Generated Files (Auto-Generated - Never Edit)

#### Step 1 Output: Comprehensive Schema
- `schemas/generated/{block}.json` - Comprehensive schema (106 attributes, 125 CSS vars)
- `schemas/{block}-structure-mapping-autogenerated.json` - Element map (selectors, hierarchy)

#### Step 2 Output: Block Attributes
- `blocks/{block}/attributes.js` - Gutenberg block attributes (kebab-case, atomic)

#### Step 3 Output: CSS Variables (3 files)
- `styles/blocks/{block}/variables.scss` - `:root` CSS variable definitions (124 vars)
- `shared/styles/{block}-css-vars-generated.js` - Inline CSS vars for editor preview ‚≠ê **NEW FORMAT**
- `shared/styles/{block}-frontend-css-vars-generated.js` - Frontend CSS vars for save.js

#### Step 4 Output: SCSS Selector Rules ‚≠ê **CRITICAL**
- `styles/blocks/{block}/generated/styles-generated.scss` - Applies CSS variables to DOM selectors
  - Example: `.accordion-title { background: var(--accordion-title-background); }`
  - **This file is what makes CSS variables actually work on the page!**
  - Auto-imported by `styles/blocks/{block}/frontend.scss`

#### Current Pipeline (All Active)
All files listed above are generated by the current comprehensive pipeline in `tools/build.js`:
1. Step 1: `schemas/parsers/orchestrator.js`
2. Step 2: `tools/generators/attributes.js`
3. Step 3A: `tools/generators/css-vars-editor.js` (SCSS)
3. Step 3B: `tools/generators/css-vars-editor-js.js` (JavaScript inline)
3. Step 3C: `tools/generators/css-vars-frontend.js` (JavaScript save)
4. Step 4: `schemas/parsers/expansors/scss-generator.js` (selector rules)

#### Legacy Files (Deprecated - No Longer Generated)
- ‚ùå `schemas/{block}-schema-autogenerated.json` (replaced by comprehensive schema)
- ‚ùå `shared/config/css-var-mappings-generated.js` (replaced by new format)
- ‚ùå `shared/styles/{block}-styles-generated.js` (no longer needed)

---

## CSS Variable Mapping + Expansion (Current)

- `build-tools/schema-compiler.js` generates `shared/src/config/css-var-mappings-generated.js` and `php/css-defaults/css-mappings-generated.php`.
- `css-var-mappings-generated.js` exposes:
  - `getCssVarName(attrName, blockType)` (attribute ‚Üí CSS var)
  - `formatCssValue(attrName, value, blockType)` (unit + value normalization)
  - `decomposeObjectToSides(...)` (per-side vars for padding/margin/border/radius)
- Editor preview uses `shared/src/styles/{block}-css-vars-generated.js`:
  - `buildEditorCssVars(effectiveValues)` expands responsive values and panel types
    (`color-panel`, `box-panel`, `typography-panel`, `border-panel`) into CSS vars.
- Frontend save uses `shared/src/styles/{block}-frontend-css-vars-generated.js`:
  - `buildFrontendCssVars(customizations, attributes)` emits CSS vars for themeable deltas
    plus non-themeable attributes.
- SCSS (`css/*_hardcoded.scss` and `css/generated/*_variables.scss`) consumes these vars
  via `var(--*)` on the relevant selectors.

---

## Attribute Structure (Current vs Comprehensive)

### Legacy schema attribute example (schema-compiler, deprecated)
```json
"titleColor": {
  "type": "color-panel",
  "appliesTo": "title",
  "subgroup": "Header",
  "states": ["base", "hover"],
  "default": {
    "text": "#333333",
    "background": "#f5f5f5",
    "hover": { "text": "#000000", "background": "#e8e8e8" }
  }
}
```

```json
"accordionWidth": {
  "type": "string",
  "control": "SliderWithInput",
  "group": "blockOptions",
  "cssVar": "accordion-width",
  "cssProperty": "width",
  "appliesTo": "item",
  "default": "100%",
  "responsive": true,
  "themeable": false
}
```

### Comprehensive atomic attribute example
```json
"title-color": {
  // Type & Control
  "type": "string",
  "control": "ColorControl",

  // UI Organization
  "label": "Text Color",
  "description": "Text color for the accordion header",
  "group": "colors",
  "subgroup": "Header",
  "order": 1,          // Only if standalone (not in panel)

  // CSS Connection
  "cssProperty": "color",
  "element": "title",   // Element ID (lookup in elements map)
  "cssVar": "--accordion-title-color",  // Auto-generated
  "default": "#333333",
  "responsive": false,
  "themeable": true,
  "state": "base"      // base, hover, is-open
}
```

### Comprehensive panel-expanded attribute example
```json
"title-icon-size": {
  "type": "string",
  "control": "SliderWithInput",
  "label": "Icon Size",
  "group": "icon",
  "panelId": "titleIcon",  // Links to icon-panel
  // NO order - panel controls layout
  "cssProperty": "font-size",
  "element": "icon",
  "cssVar": "--accordion-icon-font-size",  // Auto-generated
  "default": "16px",
  "responsive": true,
  "state": "base"
}
```

---

## Elements Map

Element details are stored in `blockname-structure-mapping-autogenerated.json` and looked up as needed:

```json
"elements": {
  "title": {
    "id": "title",
    "selector": ".accordion-title",
    "tag": "button",
    "parent": "titleWrapper",
    "children": ["icon", "titleText"]
  },
  "icon": {
    "id": "icon",
    "selector": ".accordion-icon",
    "tag": "span",
    "parent": "title",
    "children": []
  }
}
```

---

## CSS Variable Auto-Generation

### Formula
```
--{blockType}-{element}-{cssProperty}[-state][-device]
```

### Examples

**Base attribute:**
```json
{
  "element": "title",
  "cssProperty": "color",
  "state": "base"
}
```
‚Üí `--accordion-title-color`

**Hover state:**
```json
{
  "element": "title",
  "cssProperty": "color",
  "state": "hover"
}
```
‚Üí `--accordion-title-color-hover`

**Responsive + State:**
```json
{
  "element": "icon",
  "cssProperty": "font-size",
  "state": "is-open",
  "responsive": true
}
```
‚Üí Generates:
- `--accordion-icon-font-size-is-open` (desktop)
- `--accordion-icon-font-size-is-open-tablet`
- `--accordion-icon-font-size-is-open-mobile`

---

## Handling Complex Scenarios

### Responsive + Per-State + Per-Side

**Example: Border width that's responsive, has hover state, and is per-side**

**After Expansion:**
```json
"header-border-width-top": {
  "cssProperty": "border-top-width",  // Side in CSS property
  "element": "title",
  "state": "base",
  "responsive": true
}
```

**Generated CSS Variables:**
- `--accordion-title-border-top-width` (desktop, base)
- `--accordion-title-border-top-width-tablet` (tablet, base)
- `--accordion-title-border-top-width-mobile` (mobile, base)

**With Hover State:**
```json
"header-border-width-top-hover": {
  "cssProperty": "border-top-width",
  "element": "title",
  "state": "hover",
  "responsive": true
}
```

**Generated CSS Variables:**
- `--accordion-title-border-top-width-hover` (desktop)
- `--accordion-title-border-top-width-hover-tablet`
- `--accordion-title-border-top-width-hover-mobile`

### Key Insight
**Per-side is encoded in `cssProperty`**, so each side is treated as an independent attribute!

---

## SCSS Generation Logic

### Grouping Algorithm
```javascript
// Group attributes by: element √ó state √ó device
For each attribute with cssProperty:
  For each device (desktop, tablet, mobile):
    key = `${element}:${state}:${device}`
    grouped[key].push(attribute)
```

### Selector Building
```javascript
function buildSelector(element, state, device) {
  let selector = elements[element].selector;

  // Add device wrapper
  if (device === 'tablet' || device === 'mobile') {
    selector = `[data-gutplus-device="${device}"] ${selector}`;
  }

  // Add state modifier
  if (state === 'hover') {
    selector += ':hover';
  } else if (state === 'is-open') {
    selector = `.accordion-item.is-open ${selector}`;
  }

  return selector;
}
```

### Generated SCSS Example
```scss
// Base state, desktop
.accordion-title {
  color: var(--accordion-title-color);
  border-top-width: var(--accordion-title-border-top-width);
}

// Hover state, desktop
.accordion-title:hover {
  color: var(--accordion-title-color-hover, var(--accordion-title-color));
}

// Base state, tablet
[data-gutplus-device="tablet"] .accordion-title {
  color: var(--accordion-title-color-tablet, var(--accordion-title-color));
  border-top-width: var(--accordion-title-border-top-width-tablet,
                        var(--accordion-title-border-top-width));
}

// Hover state, tablet
[data-gutplus-device="tablet"] .accordion-title:hover {
  color: var(--accordion-title-color-hover-tablet,
            var(--accordion-title-color-hover));
}
```

---

## Sidebar Panels (Current)

### How sidebar panels are built today
- Panels are driven by `schema.tabs` ‚Üí groups (id/title/order) and optional subgroups.
- Attributes render when `attr.group` matches the group id and `visibleOnSidebar !== false`.
- Ordering uses per-attribute `order` (lower first).
- Composite panel types are **object-valued attributes** that `ControlRenderer` expands into multiple sub-controls:
  - `type: "color-panel"` ‚Üí text/background + hover states
  - `type: "box-panel"` ‚Üí border/radius/shadow/padding/margin
  - `type: "typography-panel"` ‚Üí font family/size/line-height
  - `type: "border-panel"` ‚Üí width/color/style (single-side use cases)
- The icon group uses a dedicated `IconPanel` component (`shared/src/components/controls/IconPanel.js`).
- `controlId` can be used to group related attributes into a single composite control when needed (e.g. `BorderPanel`, `PanelColorSettings`).

### Note on `panelId`
`panelId` exists in the **comprehensive pipeline** (`schemas/parser/*`), but the current sidebar renderer (`shared/src/components/SchemaPanels.js`) does not consume it yet.

---

## Build Pipeline (Legacy: schema-compiler, deprecated)

### Command
```bash
npm run schema:build
```

### What It Did (schema-compiler.js, deprecated)
```javascript
// For each block type (accordion, tabs, toc)

// 1. Load schemas/{block}.json
const schema = loadSchema(blockType);

// 2. Expand icon-panel macros and auto-infer cssVar/group for panel types
schema.attributes = processAttributes(schema.attributes, blockType);

// 3. Write expanded schema for runtime use
//    schemas/{block}-schema-autogenerated.json
writeExpandedSchema(schema);

// 4. Generate outputs
//    - blocks/{block}/src/{block}-attributes.js
//    - shared/src/config/css-var-mappings-generated.js
//    - shared/src/styles/{block}-styles-generated.js
//    - shared/src/styles/{block}-css-vars-generated.js (editor)
//    - shared/src/styles/{block}-frontend-css-vars-generated.js (frontend)
//    - shared/src/config/control-config-generated.js
//    - shared/src/types/* + shared/src/validators/*
//    - docs/* (attribute docs)

// 5. Inject auto-generated code into edit.js/save.js:
//    - AUTO-GENERATED-STYLES (edit.js)
//    - AUTO-GENERATED-RENDER-TITLE + AUTO-GENERATED-BLOCK-CONTENT (edit.js/save.js)
//    - Structure JSX is generated from schemas/{block}-structure-mapping-autogenerated.json
```

### Comprehensive Parser CLI
```bash
node schemas/parser/main-orchestrator.js accordion --out schemas/accordion-comprehensive.json
```

- Parses `schemas/{block}-structure.html` via `html-parser.js`.
- Merges schema + structure, expands macros, and writes:
  - `schemas/{block}-structure-mapping-autogenerated.json`
  - `schemas/{block}-comprehensive.json` (structure stripped)
- `schemas/parser/expansors/scss-generator.js` ‚≠ê **NOW WIRED** to `schema:build` (Step 4)
  - Generates `styles/blocks/{block}/generated/styles-generated.scss`
  - This file APPLIES CSS variables to DOM selectors (critical for styling to work)

---

## edit.js / save.js Autogeneration (Current)

- `build-tools/schema-compiler.js` injects generated code into `blocks/{block}/src/edit.js` and `blocks/{block}/src/save.js` using marker comments.
- edit.js imports `schemas/{block}-schema-autogenerated.json` and `{block}-attributes.js`, both re-generated by `schema-compiler`.
- **AUTO-GENERATED-STYLES** (edit.js): `getInlineStyles(responsiveDevice)` is built from schema attributes (`appliesTo` + `cssProperty`), skipping non-base states and elements flagged via `needsMapping`.
- **AUTO-GENERATED-RENDER-TITLE** + **AUTO-GENERATED-BLOCK-CONTENT** (edit.js + save.js): generated by `build-tools/generators/structure-jsx-generator.js` from `schemas/{block}-structure-mapping-autogenerated.json`. RichText vs InnerBlocks is inferred by element naming conventions.
- **State + CSS var validation:** `schema-compiler` validates typography field mappings and the SCSS generator enforces that non-base states (e.g. `hover`) emit correct `:hover` selectors.

## Pipeline Pitfalls (and how to avoid them)
These issues are easy to miss because the schema, generated CSS vars, and editor inline styles are produced by different stages.

- **State metadata missing for non-base vars**: If an attribute's CSS var ends with `-hover` but the attribute lacks `state: "hover"`, SCSS generation will emit base selectors instead of `:hover`. Always ensure non-base states are explicitly set in expanders.
- **appliesTo ‚Üí cssVar mismatch**: If `appliesTo` is mapped to the wrong element name, generated vars won't match the selectors (e.g., `contentInner` must map to `--{block}-contentInner-*` so `.content-inner` gets padding).
- **Typography var suffix mismatch**: `text-decoration-line` requires a `-text-decoration-line` suffix, not `-text-decoration`. Keep typography field mappings in sync with CSS property names.
- **Hardcoded overrides masking schema vars**: Any static padding/margin in `*_hardcoded.scss` can override schema-driven variables. Reserve hardcoded CSS only for properties not represented in schema.
- Save components call `buildFrontendCssVars(attributes.customizations, attributes)` to output inline CSS vars for themeable deltas + non-themeable attributes.

## Sidebar + Preview Flow (Current)

1. `SchemaPanels` reads `schema.tabs` + groups and renders `GenericPanel`, `SubgroupPanel`, or `IconPanel`.
2. `ControlRenderer` maps `attr.control` or `attr.type` to actual UI controls. Composite `*-panel` types expand into object fields and write back via `setAttributes`.
3. `buildEditorCssVars(effectiveValues)` converts attributes to CSS vars using `shared/src/config/css-var-mappings-generated.js`, including `-tablet`/`-mobile` suffixes and per-side decompositions.
4. The block root sets `data-gutplus-device` (via `useResponsiveDevice`) so responsive SCSS selectors resolve the correct vars.
5. Theme changes are applied to attributes via `useThemeManager`, and `customizations` is kept as deltas for save.js.
6. Actual element targeting happens in SCSS (`css/*_hardcoded.scss` and/or `css/generated/*_variables.scss`) where selectors read `var(--*)`.

---

## Parser and Generator Files

### Legacy Build (schema-compiler, deprecated)

#### `build-tools/schema-compiler.js` (deprecated)
Reads `schemas/{block}.json`, expands icon-panel macros, generates JS/TS/PHP/config outputs, and injects auto-generated code into edit/save.

#### `build-tools/generators/structure-jsx-generator.js`
Converts `schemas/{block}-structure-mapping-autogenerated.json` into JSX for edit/save and injects it via markers.

#### `build-tools/generators/editor-css-vars-injector.js`
Generates `shared/src/styles/{block}-css-vars-generated.js` for editor preview CSS vars.

#### `build-tools/generators/frontend-css-vars-injector.js`
Generates `shared/src/styles/{block}-frontend-css-vars-generated.js` for frontend customizations.

### Comprehensive Parser

#### `html-parser.js`
Parses HTML template files into structured data.

**Features:**
- Extracts `data-el` ‚Üí element IDs
- Extracts `class` ‚Üí selectors
- Parses `data-when`/`data-else` ‚Üí conditionals
- Parses `data-switch`/`data-case` ‚Üí variations
- Parses `<template data-slot>` ‚Üí reusable fragments
- Builds parent/child relationships

#### `schema-merger.js`
Connects minimal schema to HTML structure.

**Does:**
- Normalizes `element` field (handles legacy `appliesTo`)
- Validates element exists in HTML structure
- Keeps schema clean (no bloat with _element* metadata)

#### `main-orchestrator.js` ‚≠ê COMPREHENSIVE ORCHESTRATOR
The brain of the comprehensive pipeline.

**Does:**
1. Expands macros ‚Üí atomic attributes
2. Auto-generates cssVar names using formula
3. Applies responsive variants (tablet/mobile)
4. Builds defaultValues map
5. Builds cssVarMap (CSS var ‚Üí attribute metadata)
6. Builds selectorVarMap (selector ‚Üí CSS vars array)
7. Builds responsiveSelectors array
8. Writes structure mapping to `blockname-structure-mapping-autogenerated.json`

### Macro Expanders (Comprehensive Pipeline)

#### `icon-expander.js`
Expands `icon-panel` into a complete, panel-driven icon system with base (closed) and open states.

**Minimal schema usage**
```json
"titleIcon": {
  "type": "icon-panel",
  "cssVar": "accordion-icon",
  "appliesTo": "icon",
  "default": {
    "position": "right",
    "animationRotation": "180deg",
    "inactive": {
      "source": { "icon-type": "char", "value": "‚ñæ" },
      "color": "#333333",
      "size": "16px",
      "maxSize": "24px",
      "offsetX": "0px",
      "offsetY": "0px",
      "initialRotation": "0deg"
    },
    "active": {
      "source": { "icon-type": "char", "value": "‚ñæ" },
      "initialRotation": "0deg"
    }
  }
}
```

**Macro inputs**
- `cssVar`: prefix for all icon vars. Accepts `accordion-icon` or `--accordion-icon` (normalized to `--`).
- `appliesTo` / `appliesToElement`: element id for the icon (defaults to `icon`).
- `positioningProfile`: `accordion`, `tabs`, or `toc` (controls allowed positions).
- `default`: nested defaults. Use `inactive` for closed, `active` for open. `base` is also accepted as `inactive`.

**Generated attributes (overview)**
- Panel toggles: `Show`, `UseDifferentIcons`, `Position`.
- Core: `AnimationRotation` (single value; applied on open).
- State-specific (for `inactive` and `is-open`):
  - `Source` (IconPicker, not CSS)
  - `Color` (text color for non-image icons)
  - `InitialRotation` (cosmetic rotation per icon)
  - `Transform` (computed, responsive)
  - `Size` (font-size for character/library icons, responsive)
  - `MaxSize` (max-width for image icons, responsive)
  - `OffsetX`, `OffsetY` (translate offsets, responsive)

**State handling**
- The expander always creates two states: `inactive` (no `state` field) and `is-open` (`state: "is-open"`).
- `UseDifferentIcons` toggles whether open-state fields are shown. If off, open values fall back to base.

**Rotation logic (human-readable)**
- Closed icon uses `initial-rotation` only.
- Open icon uses `(open-initial or initial) + animation-rotation`.
- `initial-rotation-is-open` is optional for the open icon's cosmetic orientation.

**Offset logic (human-readable)**
- Offsets are applied via `translate(x, y)` inside `transform`.
- Open offsets are absolute; if not set, they fall back to base offsets.

**Responsive logic**
- `Size`, `MaxSize`, `OffsetX`, `OffsetY` are responsive (desktop/tablet/mobile).
- `Transform` is generated per device using responsive offset values.

**Panel-side UI logic**
- Show/hide rules (e.g., image vs. non-image icon fields) are handled by the icon panel,
  not stored on expanded attributes.

#### `typography-expander.js`
Expands `typography-panel` ‚Üí per-field √ó per-state attributes
- Font size, weight, family
- Line height, letter spacing
- Text transform, decoration
- Supports multiple states (base, hover, etc.)

#### `border-expander.js`
Expands `border-panel` ‚Üí 12 attributes (4 sides √ó 3 properties)
- Width, color, style
- Per side: top, right, bottom, left

#### `box-expander.js`
Expands `box-panel` ‚Üí 25+ attributes
- All border attributes (via border-expander)
- Padding (4 sides)
- Margin (4 sides)
- Border radius (4 corners)
- Box shadow

#### `color-expander.js`
Expands `color-panel` into text/background color attributes with optional states.

**Minimal schema usage**
```json
"titleColor": {
  "type": "color-panel",
  "group": "headerColors",
  "subgroup": "Header",
  "appliesTo": "title",
  "states": ["base", "hover"],
  "fields": ["text", "background"],
  "cssVar": "accordion-title",
  "default": {
    "text": "#333333",
    "background": "#f5f5f5",
    "hover": {
      "text": "#000000",
      "background": "#e8e8e8"
    }
  }
}
```

**Macro inputs**
- `appliesTo` / `appliesToElement`: element id(s). Can be a single string or an array of element ids.
- `group` / `subgroup`: panel grouping (subgroup is optional).
- `states`: list of state keys (defaults to `["base"]`).
- `fields`: `["text", "background"]` (defaults to both).
- `properties`: override cssProperty per field (default: `text=color`, `background=background`).
- `cssVar`: base var name used by the expander (recommended when `appliesTo` is an array).
- `stateSubgroups`: map `{ hover: "Header - Hover" }` to override subgroup names per state.
- `default`: base defaults and optional per-state overrides.
- `needsMapping`: marks the base/first field for panel mapping (optional).
- `themeable`: defaults to `true`.
- Controls are defined by the color panel itself (text uses `ColorPicker`, background uses `ColorGradientControl`).

**Generated attributes (overview)**
- Attribute names use `buildKebabName(baseName, FieldSuffix, State)`:
  - `title-color-text`
  - `title-color-background`
  - `title-color-text-hover`
  - `title-color-background-hover`
- Each attribute is `outputsCSS: true`, uses the element(s) from `appliesTo`,
  and gets `state` for non-base states.

**Default structure**
```json
{
  "text": "#333333",
  "background": "transparent",
  "hover": {
    "text": "#000000",
    "background": "#e8e8e8"
  }
}
```

**Multi-element behavior**
- If `appliesTo` is an array, the same CSS vars are applied to each element selector.
- The expander still uses `cssVar` (or its inferred base) to build variable names.

### `responsive-expander.js`
Adds responsive variants to marked attributes.

**For each responsive attribute, adds:**
```json
"cssVarVariants": [
  "--accordion-title-color",         // desktop
  "--accordion-title-color-tablet",  // tablet
  "--accordion-title-color-mobile"   // mobile
]
```

---

## Success Criteria (Target)

‚úÖ **Zero synchronization issues** - One source drives everything
‚úÖ **Zero manual edits** - Add attribute ‚Üí all files auto-update
‚úÖ **Auto-generated CSS vars** - No manual naming, always consistent
‚úÖ **Trivial debugging** - Follow comprehensive schema to understand everything
‚úÖ **Trivial new features** - Define macro ‚Üí run build ‚Üí done
‚úÖ **Clean structure** - No redundancy, each section has clear purpose
‚úÖ **Panel/standalone distinction** - Clear organization in sidebar
‚úÖ **Edge cases handled** - Responsive + state + per-side all work

---

## Adding a New Feature

**Legacy build note (deprecated):** For `schema-compiler`, add the attribute to `schemas/{block}.json` (with `cssVar`, `cssProperty`, and `appliesTo`), then run `npm run schema:build`. New control types require updates in `ControlRenderer` and the generator(s) if they need special CSS-var expansion.

### Example: Add background gradient

**Step 1:** Edit minimal schema
```json
"title-background-gradient": {
  "type": "gradient-panel",
  "element": "title",
  "default": "linear-gradient(90deg, #fff 0%, #f5f5f5 100%)"
}
```

**Step 2:** Create expander (if needed)
```javascript
function expandGradientPanelMacro(name, attr, blockType) {
  return {
    [`${name}-type`]: { cssProperty: 'background-image', ... },
    [`${name}-angle`]: { cssProperty: 'background-angle', ... },
    [`${name}-stops`]: { cssProperty: 'background-stops', ... }
  };
}
```

**Step 3:** Register expander
```javascript
const EXPANDERS = {
  'gradient-panel': expandGradientPanelMacro
};
```

**Step 4:** Run build
```bash
npm run schema:build
```

**Done!** Zero manual edits to edit.js, save.js, or CSS.

---

## Debugging Guide

### Problem: Attribute not showing in sidebar

**Check:**
1. Is `group` set and does it match a group in `schema.tabs`?
2. Is `visibleOnSidebar !== false`?
3. For ordering: is `order` set (or expected to float to the end)?
4. If it's a composite control, does `type` map to a supported panel (`color-panel`, `box-panel`, `typography-panel`, `border-panel`)?

### Problem: CSS not applying

**MOST COMMON ISSUE:** Missing Step 4 (SCSS Selector Rules)

**Check these in order:**

1. **Did Step 4 generate selector rules?**
   - Check if file exists: `styles/blocks/{block}/generated/styles-generated.scss`
   - If missing, run `npm run schema:build`
   - This step applies CSS variables to DOM selectors

2. **Does frontend.scss import the generated file?**
   ```scss
   @import './generated/styles-generated.scss';
   ```
   - Check `styles/blocks/{block}/frontend.scss`
   - If missing, add the import line

3. **Are CSS variables being set as inline styles in editor?**
   - Inspect element in browser DevTools
   - Look for `style="--accordion-title-color: #333; ..."`
   - If missing, check `buildEditorCssVars()` in `shared/styles/{block}-css-vars-generated.js`

4. **Comprehensive schema checks:**
   - Does attribute have `cssVar` + `cssProperty` and `outputsCSS !== false`?
   - Does it have `element` field pointing to valid element ID?
   - Check `structure.elements` in comprehensive schema
   - Check `cssVarMap` and `selectorVarMap`

5. **Hard refresh browser:**
   - Ctrl+Shift+R (Windows) or Cmd+Shift+R (Mac)
   - Webpack may have cached old JavaScript

**Debug steps:**
```bash
# 1. Rebuild everything
npm run schema:build && npm run build

# 2. Check generated files exist
ls styles/blocks/accordion/generated/styles-generated.scss
ls shared/styles/accordion-css-vars-generated.js

# 3. Check if SCSS has selector rules
cat styles/blocks/accordion/generated/styles-generated.scss | grep ".accordion-title {"

# 4. Hard refresh browser
```

### Problem: Responsive not working

**Check:**
1. Is `responsive: true` on the attribute?
2. Do you see `-tablet` / `-mobile` CSS vars in the inline styles (editor) or save output?
3. Is `data-gutplus-device` set on the block root?
4. Do SCSS selectors include `[data-gutplus-device="tablet"]` / `"mobile"`?

---

## Questions & Answers

**Q: Why kebab-case for attributes?**
A: This is for the comprehensive pipeline. The current source schemas are camelCase.

**Q: Why auto-generate cssVar names?**
A: In the legacy pipeline, `schema-compiler` auto-infers `cssVar` for panel types if missing; the comprehensive pipeline uses a formula for all attrs.

**Q: Can I customize CSS var names?**
A: Current pipeline: yes (set `cssVar` in the schema). Comprehensive pipeline: no (formula-driven).

**Q: How do I know if an attribute needs `order`?**
A: Current pipeline: `order` controls sidebar ordering for attributes in a group. Composite panel types are object-valued attrs (ordering handled by `ControlRenderer`).

**Q: What if I need to override a generated file?**
A: Don't. Edit the minimal schema or HTML template. If generator is wrong, fix the generator.

---

## Unified Controls Implementation

### Overview

Unified controls allow users to edit multiple related attributes (like 4 border sides or 4 padding sides) through a single control panel with link/unlink functionality. This prevents sidebar clutter and provides better UX.

### How Unified Controls Work

**Pattern:**
1. Schema expander generates multiple atomic attributes (e.g., `border-top-width`, `border-right-width`, etc.)
2. All related attributes share the same `controlId` (e.g., `"blockBox"`)
3. Only the FIRST attribute has `renderControl: true`, others have `renderControl: false`
4. ControlRenderer finds all attributes by `controlId` and renders them as one unified panel

### Implemented Unified Controls

#### 1. BorderPanel (Border Width, Color, Style)
**Generated by:** `border-panel` macro or `box-panel` with `border` field
**Expander:** `schemas/parsers/expansors/border.js`
**ControlRenderer case:** `BorderPanel` (lines ~1273-1420)

**Attributes generated:**
- `{base}-border-width-{side}` (top/right/bottom/left)
- `{base}-border-color-{side}` (top/right/bottom/left)
- `{base}-border-style-{side}` (top/right/bottom/left)

**controlId:** `{baseName}` (e.g., `"blockBox"`, `"dividerBorder"`)

**Key implementation details:**
- Finds all 12 attributes (4 sides √ó 3 properties) by `controlId`
- Parses string values with units: `"4px"` ‚Üí `{ value: 4, unit: "px" }`
- Handles both unified (all sides same) and per-side (unlinked) color/style
- Updates all 4 side attributes when user changes values

#### 2. RadiusControl (Border Radius - 4 Corners)
**Generated by:** `box-panel` with `radius` field
**Expander:** `schemas/parsers/expansors/box.js` (lines ~188-217)
**ControlRenderer case:** `RadiusControl` (lines ~1422-1485)

**Attributes generated:**
- `{base}-border-radius-top-left`
- `{base}-border-radius-top-right`
- `{base}-border-radius-bottom-right`
- `{base}-border-radius-bottom-left`

**controlId:** `{baseName}Radius` (e.g., `"blockBoxRadius"`)

**Key implementation details:**
- Finds all 4 corner attributes by `controlId`
- Extracts unit from first corner value
- Parses numeric values: `"4px"` ‚Üí `4`
- Passes both numeric values and unit to `BorderRadiusControl`
- Re-adds unit when saving: `{ topLeft: 4, unit: "px" }` ‚Üí `"4px"`

#### 3. SpacingControl (Padding & Margin)
**Generated by:** `box-panel` with `padding` or `margin` field
**Expander:** `schemas/parsers/expansors/box.js` (lines ~132-186)
**ControlRenderer case:** `SpacingControl` (lines ~1488-1562)

**Attributes generated:**
- `{base}-padding-{side}` (top/right/bottom/left) - all 4 sides
- `{base}-margin-{side}` (top/right/bottom/left) - all 4 sides

**controlId:** `{baseName}Padding` or `{baseName}Margin`

**Key implementation details:**
- Auto-detects if padding or margin from `cssProperty`
- For padding: shows all 4 sides
- For margin: restricts to top/bottom only via `sides` prop
- Parses string values with units
- Updates all side attributes simultaneously

### Adding New Unified Controls

**Step 1: Update Schema Expander**

Modify the expander (e.g., `box.js`, `border.js`) to generate attributes with:
```javascript
{
  control: "YourControlName",
  controlId: "uniqueId",  // Same for all related attrs
  renderControl: true,     // Only on FIRST attribute
  // ... other fields
}
```

**Step 2: Add ControlRenderer Case**

Add a new case in `shared/components/ControlRenderer.js`:
```javascript
case 'YourControlName': {
  // Only render if renderControl: true
  if ( attrConfig.renderControl !== true ) {
    return null;
  }

  // Find all related attributes by controlId
  const controlId = attrConfig.controlId;
  const allAttrs = Object.entries( schema?.attributes || {} );
  const relatedAttrs = allAttrs.filter(
    ( [ , attr ] ) => attr.control === 'YourControlName' && attr.controlId === controlId
  );

  // Build unified value object from all related attributes
  const unifiedValue = {};
  relatedAttrs.forEach( ( [ attrName, attrDef ] ) => {
    const rawValue = effectiveValues?.[ attrName ] ?? attrDef.default;
    // Parse value as needed
    unifiedValue.someKey = parseValue( rawValue );
  } );

  // Handle change - update all related attributes
  const handleChange = ( newValue ) => {
    const updates = {};
    relatedAttrs.forEach( ( [ attrName ] ) => {
      updates[ attrName ] = formatValue( newValue.someKey );
    } );
    setAttributes( updates );
  };

  return (
    <YourControl
      key={ attrName }
      value={ unifiedValue }
      onChange={ handleChange }
    />
  );
}
```

**Step 3: Rebuild**
```bash
npm run schema:build
npm run build
```

### Common Pitfalls

**‚ùå DON'T use `.find()` - it only gets the first attribute**
```javascript
// WRONG - only finds first side
const widthAttr = relatedAttrs.find( attr =>
  attr.cssProperty?.endsWith('width')
);
```

**‚úÖ DO iterate all sides explicitly**
```javascript
// CORRECT - finds all 4 sides
const sides = ['top', 'right', 'bottom', 'left'];
sides.forEach( side => {
  widthAttrs[side] = relatedAttrs.find(
    attr => attr.cssProperty === `border-${side}-width`
  );
});
```

**‚ùå DON'T forget to parse string values with units**
```javascript
// WRONG - passes "4px" to numeric control
<RangeControl value={effectiveValue} />
```

**‚úÖ DO extract numeric values and preserve units**
```javascript
// CORRECT - parses to 4, stores unit separately
const numMatch = String(value).match(/^([0-9.]+)/);
const num = numMatch ? parseFloat(numMatch[1]) : 0;
const unitMatch = String(value).match(/[a-z%]+$/i);
const unit = unitMatch ? unitMatch[0] : 'px';
```

**‚ùå DON'T check for `order` field - comprehensive schema doesn't use it**
```javascript
// WRONG - old pattern
if ( attrConfig.order === undefined ) {
  return null;
}
```

**‚úÖ DO check for `renderControl: true`**
```javascript
// CORRECT - new pattern
if ( attrConfig.renderControl !== true ) {
  return null;
}
```

**‚ùå DON'T use camelCase when building related attribute names**
```javascript
// WRONG - comprehensive schema uses kebab-case
const formattingBase = attrName.replace(/Formatting$/, '');
const fontWeightKey = `${formattingBase}FontWeight`; // titleTypographyFontWeight ‚ùå
```

**‚úÖ DO use kebab-case for attribute names**
```javascript
// CORRECT - matches comprehensive schema naming
const formattingBase = attrName.replace(/-formatting$/i, '');
const fontWeightKey = `${formattingBase}-font-weight`; // title-typography-font-weight ‚úÖ
```

**‚ùå DON'T assume array values are always arrays**
```javascript
// WRONG - will crash with .some() or .filter() if value isn't array
const decorationLines = newValue.formatting.filter(...);
```

**‚úÖ DO validate array values before iteration**
```javascript
// CORRECT - ensures value is array first
const formatting = Array.isArray(newValue.formatting) ? newValue.formatting : [];
const decorationLines = formatting.filter(...);
```

### Debugging Unified Controls

**Problem: Control not showing**
1. Check if first attribute has `renderControl: true` in comprehensive schema
2. Verify all related attributes have same `controlId`
3. Check ControlRenderer case name matches `control` field
4. Console.log the `relatedAttrs` array to see what was found

**Problem: Values not saving**
1. Ensure `handleChange` updates ALL related attributes
2. Check that value formatting includes units (e.g., `"4px"` not `4`)
3. Verify attribute names are correct in `setAttributes()`

**Problem: Control showing 4 separate inputs instead of unified panel**
1. Verify expander set `control: "SpacingControl"` not `"SliderWithInput"`
2. Check that ALL 4 attributes have the same `controlId`
3. Ensure only first attribute has `renderControl: true`

---

## Version

**Schema Version**: 2.0.0
**Generated**: Auto-updated on each build
**Last Updated**: 2026-01-07




