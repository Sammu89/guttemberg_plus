# Unified Schema Architecture (Single Source of Truth)

## Purpose

Document the **single-source** schema pipeline. This repo is expected to run a
unified build where **one comprehensive schema** is generated from the minimal
schema + HTML structure, and **all outputs** are derived from that comprehensive
schema (edit.js, save.js, UI panels, CSS vars, SCSS, validators, types).

---

## Unified Build Pipeline (Required)

- **Inputs (human edited):**
  - `schemas/{block}.json` (minimal schema + macros)
  - `schemas/{block}-structure.html` (DOM structure)
- **Single transform:**
  - `schemas/parser/main-orchestrator.js` expands macros, merges structure, and writes:
    - `schemas/{block}-comprehensive-autogenerated.json`
- **All generators consume the comprehensive schema:**
  - edit.js/save.js injection
  - UI panel rendering
  - CSS var mapping + SCSS vars
  - JS/TS/PHP config outputs
  - validators + docs

---

## Core Principles

### 1. **Single Source of Truth**
One comprehensive schema drives CSS, edit.js, save.js, UI panels, validators, and mappings.

### 2. **Kebab-Case Attributes**
Comprehensive schema attributes are kebab-case to align with CSS vars:
```javascript
"title-icon-size"  ‚Üí --accordion-title-icon-size
"border-top-color" ‚Üí --accordion-border-top-color
```
Note: source schemas can remain camelCase; expanders normalize to kebab-case.

### 3. **Auto-Generated CSS Variables**
CSS variable names follow a strict formula:
```
--{blockType}-{element}-{cssProperty}[-state][-device]
```

Examples:
- `--accordion-title-color` (base state, desktop)
- `--accordion-title-color-hover` (hover state, desktop)
- `--accordion-icon-font-size-is-open-tablet` (open state, tablet)

### 4. **No Redundancy**
- Element details stored once in the structure map
- CSS vars auto-generated from attribute metadata
- UI ordering driven by `panelId`/group metadata carried in the comprehensive schema

---

## Required Comprehensive Schema Contents

The comprehensive schema must carry **all** data needed to build everything:
- `attributes`: atomic, kebab-case attributes with cssProperty, element, state, responsive
- `panelId` / `group` / `subgroup` / `control` metadata for UI layout
- `defaults` or `defaultValues` map for atomic defaults
- `structure` or a linked structure map (elements + selectors)
- `cssVarMap`, `selectorVarMap`, `responsiveSelectors`
- `cssVarVariants` for responsive attrs (desktop/tablet/mobile)

## Unified Architecture Flow

```
schemas/{block}.json + schemas/{block}-structure.html
        -> schemas/parser/main-orchestrator.js
        -> schemas/{block}-comprehensive-autogenerated.json
               -> edit.js/save.js injection
               -> UI panels (SchemaPanels/ControlRenderer)
               -> CSS vars + SCSS generation
               -> JS/TS/PHP configs + validators + docs
```

## Build Switch: Concrete Steps

1. **Make `schema:build` call the parser first**
   - Run `schemas/parser/main-orchestrator.js` for each block.
   - Emit `schemas/{block}-comprehensive-autogenerated.json` plus structure mapping.
2. **Point all generators to the comprehensive schema**
   - CSS var builders, style builders, validators, types, docs, and edit/save injectors
     must read `schemas/{block}-comprehensive-autogenerated.json`.
3. **Update the sidebar renderer to use panel metadata**
   - `SchemaPanels` should group atomic attributes by `panelId`/`group`/`subgroup`
     and render the same UI controls without macro objects.
4. **Generate Gutenberg attributes from atomic attrs**
   - `blocks/{block}/src/{block}-attributes.js` should be derived from the comprehensive schema.
5. **Keep storage compact with compression**
   - Use `attribute-decompression` on load and `attribute-compression` on save
     so the editor can work with atomic values while the database stays compact.
6. **Stop writing `schemas/{block}-schema-autogenerated.json`**
   - The macro schema is no longer a build output once the unified pipeline is live.

---

## Parser Goal (Minimal -> Comprehensive)

This section describes the **Comprehensive Parser** in `schemas/parser`. It is the
only supported pipeline.

The parser system transforms a minimal schema into a fully comprehensive
schema that outputs all variables possible. This includes:
- Decomposed values per side (top/right/bottom/left) and per corner.
- Per-device responsive variants.
- All properties defined by the control group.
- A complete mapping of variables to their associated elements.

Later, the control panels and save logic will mesh/compress these atomic
properties back into grouped controls (e.g., if all sides match, emit a
single border-color). That compression happens on save, not in the parser.

Composite entries are auto-generated by the parser. Compression rules are
hardcoded per property family (not per attribute). Current rules:
- `padding`, `margin`, `border-width`, `border-style`, `border-color`: 1/2/3/4-value shorthands.
- `border-radius`: 1‚Äì4-value shorthand (no ellipse support).
- `border-{side}`: composed from `{side}-width/style/color` when all present.
- `border`: only valid when all four side values match (uses `border-top/right/bottom/left`).

The comprehensive schema should also include composite metadata referencing
atomic entries, e.g.:
`border-color` = (border-color-top, border-color-right, border-color-bottom, border-color-left)

Composite entries are stored as `type: "composite"` with a `compositeOf` list
of attribute keys. They do not emit CSS directly.

---

## HTML Template DSL (Domain Specific Language)

The HTML structure files use a powerful DSL that makes them the **single source of truth** for DOM structure, variations, and element relationships.

### DSL Features Overview

| Feature | Syntax | Purpose |
|---------|--------|---------|
| **Element ID** | `data-el="elementId"` | Mark elements for tracking |
| **Selector** | `class="primary-class"` | First class = CSS selector |
| **Conditional** | `data-when` / `data-else` | If/else branches |
| **Switch** | `data-switch` / `data-case` / `data-default` | Multi-way branches |
| **Slots** | `<template data-slot="name">` | Reusable fragments |
| **Placeholders** | `{variableName}` | Dynamic substitution |
| **Content Slot** | `<slot>` | InnerBlocks placeholder |

### 1. Element Identification: `data-el`

Marks elements for schema tracking. Each `data-el` creates an entry in the elements map.

```html
<div class="accordion-title" data-el="title">
  <span class="accordion-icon" data-el="icon"></span>
</div>
```

**Generated:**
```javascript
elements: {
  title: {
    id: "title",
    selector: ".accordion-title",  // First class
    tag: "div",
    parent: "item",
    children: ["icon"]
  }
}
```

### 2. Conditional Rendering: `data-when` / `data-else`

Create optional elements:

```html
<template data-when="headingLevel !== 'none'">
  <h{headingLevel} class="accordion-heading" data-el="heading">
    Header content
  </h{headingLevel}>
</template>
<template data-else>
  No header content
</template>
```

**Use Case:** Show heading wrapper only when user selects a heading level.

### 3. Switch Statements: `data-switch` / `data-case`

Multi-way layout variations:

```html
<template data-switch="iconPosition">
  <template data-case="box-left">
    <span data-el="iconSlot">Icon</span>
    <div data-el="titleText">Title</div>
  </template>
  <template data-case="box-right">
    <div data-el="titleText">Title</div>
    <span data-el="iconSlot">Icon</span>
  </template>
  <template data-default>
    <div data-el="titleInline">
      <span data-el="titleText">Title</span>
      <span data-el="icon">Icon inline</span>
    </div>
  </template>
</template>
```

**Use Case:** Different DOM structure based on icon position setting.

### 4. Reusable Fragments: `data-slot`

Define once, inject multiple times:

```html
<!-- Definition (with content) -->
<template data-slot="iconMarkup">
  <template data-when="iconSource.kind === 'image'">
    <img class="accordion-icon" data-el="icon" alt="">
  </template>
  <template data-else>
    <span class="accordion-icon" data-el="icon"></span>
  </template>
</template>

<!-- Injection (empty) -->
<div class="icon-wrapper">
  <template data-slot="iconMarkup"></template>
</div>
```

**Use Case:** Icon markup reused in multiple branches (box-left, box-right, inline).

### 5. String Substitution: `{placeholder}`

Dynamic values injected at render:

```html
<h{headingLevel} class="accordion-heading">
```

When `headingLevel = 3`:
```html
<h3 class="accordion-heading">
```

**Use Case:** Dynamic tag names, class names, attributes.

### 6. Content Placeholder: `<slot>`

Where user content (InnerBlocks) goes:

```html
<div class="accordion-content-inner" data-el="contentInner">
  <slot data-el="contentSlot"></slot>
</div>
```

**Generated:** Creates element with `isSlot: true`, used by save.js to place `<InnerBlocks>`.

### Complete DSL Example

```html
<div class="gutplus-accordion" data-el="item">
  <!-- Conditional wrapper -->
  <template data-when="headingLevel !== 'none'">
    <h{headingLevel} data-el="heading">
      <template data-slot="titleButton"></template>
    </h{headingLevel}>
  </template>

  <!-- Reusable button fragment -->
  <template data-slot="titleButton">
    <button class="accordion-title" data-el="title">
      <!-- Switch for icon position -->
      <template data-switch="iconPosition">
        <template data-case="left">
          <span data-el="icon">üìç</span>
          <span data-el="titleText">Title</span>
        </template>
        <template data-default>
          <span data-el="titleText">Title</span>
          <span data-el="icon">üìç</span>
        </template>
      </template>
    </button>
  </template>

  <!-- Content slot -->
  <div class="accordion-content" data-el="content">
    <slot data-el="contentSlot"></slot>
  </div>
</div>
```

**This single HTML file drives:**
- ‚úÖ edit.js generation (knows all variations)
- ‚úÖ save.js generation (knows DOM structure)
- ‚úÖ SCSS generation (knows selectors and hierarchy)
- ‚úÖ Zero manual sync required!

**For complete DSL reference, see:** `parser/html-parser.js` (200+ lines of inline documentation)

---

## File Structure

### Source Files (Human Editable)

#### `accordion.json` - Minimal Schema
**Contains**: High-level attribute definitions using macros
```json
{
  "blockType": "accordion",
  "attributes": {
    "titleColor": {
      "type": "color-panel",
      "appliesTo": "title",
      "states": ["base", "hover"],
      "default": {
        "text": "#333333",
        "background": "#f5f5f5",
        "hover": { "text": "#000000", "background": "#e8e8e8" }
      }
    },
    "titleIcon": {
      "type": "icon-panel",
      "cssVar": "accordion-icon",
      "appliesTo": "icon"
    }
  }
}
```

#### `accordion-structure.html` - HTML Template
**Contains**: DOM structure with DSL annotations
```html
<div class="gutplus-accordion" data-el="item">
  <button class="accordion-title" data-el="title">
    <span class="accordion-icon" data-el="icon"></span>
  </button>
  <div class="accordion-content" data-el="content"></div>
</div>
```

#### `accordion-structure.json` - Legacy Structure Schema
**Contains**: Element hierarchy + `appliesStyles` metadata used by older CSS generation tools (`build-tools/css-generator.js`). Not consumed by `schema-compiler`.

### Generated Files (Auto-Generated - Never Edit)

#### Legacy build outputs (schema-compiler, deprecated)
- `schemas/{block}-schema-autogenerated.json`: expanded schema (icon-panel macros expanded, cssVar/group inferred).
- `blocks/{block}/src/{block}-attributes.js`: block attributes for Gutenberg.
- `shared/src/config/css-var-mappings-generated.js`: attribute ‚Üí CSS var map (JS).
- `php/css-defaults/css-mappings-generated.php`: attribute ‚Üí CSS var map (PHP).
- `shared/src/styles/{block}-styles-generated.js`: style builders (editor + frontend helpers).
- `shared/src/styles/{block}-css-vars-generated.js`: editor CSS var builder.
- `shared/src/styles/{block}-frontend-css-vars-generated.js`: frontend CSS var builder.
- `shared/src/config/control-config-generated.js`: control config (min/max/options).
- `shared/src/types/*` + `shared/src/validators/*`: TS types + Zod validators.
- `docs/{block}-attributes.md`: auto-generated attribute docs.

#### `accordion-structure-mapping-autogenerated.json` - Element Map
Contains the HTML structure mapping (elements, selectors, parent/child) used by generators.

#### Comprehensive pipeline outputs
- `schemas/{block}-comprehensive.json`: atomic, macro-expanded schema (kebab-case).
- `css/generated/{block}_variables.scss`: SCSS variable + selector rules from comprehensive schema.

#### `css/` - CSS Sources
- `{block}_hardcoded.scss`: frontend layout and hardcoded CSS
- `{block}_editor.scss`: editor overrides (imports `{block}_hardcoded.scss`)
- `generated/{block}_variables.scss`: schema-driven variable/selector rules
- `{block}-structure-mapping-autogenerated.json`: structure mapping output

---

## CSS Variable Mapping + Expansion (Current)

- `build-tools/schema-compiler.js` generates `shared/src/config/css-var-mappings-generated.js` and `php/css-defaults/css-mappings-generated.php`.
- `css-var-mappings-generated.js` exposes:
  - `getCssVarName(attrName, blockType)` (attribute ‚Üí CSS var)
  - `formatCssValue(attrName, value, blockType)` (unit + value normalization)
  - `decomposeObjectToSides(...)` (per-side vars for padding/margin/border/radius)
- Editor preview uses `shared/src/styles/{block}-css-vars-generated.js`:
  - `buildEditorCssVars(effectiveValues)` expands responsive values and panel types
    (`color-panel`, `box-panel`, `typography-panel`, `border-panel`) into CSS vars.
- Frontend save uses `shared/src/styles/{block}-frontend-css-vars-generated.js`:
  - `buildFrontendCssVars(customizations, attributes)` emits CSS vars for themeable deltas
    plus non-themeable attributes.
- SCSS (`css/*_hardcoded.scss` and `css/generated/*_variables.scss`) consumes these vars
  via `var(--*)` on the relevant selectors.

---

## Attribute Structure (Current vs Comprehensive)

### Legacy schema attribute example (schema-compiler, deprecated)
```json
"titleColor": {
  "type": "color-panel",
  "appliesTo": "title",
  "subgroup": "Header",
  "states": ["base", "hover"],
  "default": {
    "text": "#333333",
    "background": "#f5f5f5",
    "hover": { "text": "#000000", "background": "#e8e8e8" }
  }
}
```

```json
"accordionWidth": {
  "type": "string",
  "control": "SliderWithInput",
  "group": "blockOptions",
  "cssVar": "accordion-width",
  "cssProperty": "width",
  "appliesTo": "item",
  "default": "100%",
  "responsive": true,
  "themeable": false
}
```

### Comprehensive atomic attribute example
```json
"title-color": {
  // Type & Control
  "type": "string",
  "control": "ColorControl",

  // UI Organization
  "label": "Text Color",
  "description": "Text color for the accordion header",
  "group": "colors",
  "subgroup": "Header",
  "order": 1,          // Only if standalone (not in panel)

  // CSS Connection
  "cssProperty": "color",
  "element": "title",   // Element ID (lookup in elements map)
  "cssVar": "--accordion-title-color",  // Auto-generated
  "default": "#333333",
  "responsive": false,
  "themeable": true,
  "state": "base"      // base, hover, is-open
}
```

### Comprehensive panel-expanded attribute example
```json
"title-icon-size": {
  "type": "string",
  "control": "SliderWithInput",
  "label": "Icon Size",
  "group": "icon",
  "panelId": "titleIcon",  // Links to icon-panel
  // NO order - panel controls layout
  "cssProperty": "font-size",
  "element": "icon",
  "cssVar": "--accordion-icon-font-size",  // Auto-generated
  "default": "16px",
  "responsive": true,
  "state": "base"
}
```

---

## Elements Map

Element details are stored in `blockname-structure-mapping-autogenerated.json` and looked up as needed:

```json
"elements": {
  "title": {
    "id": "title",
    "selector": ".accordion-title",
    "tag": "button",
    "parent": "titleWrapper",
    "children": ["icon", "titleText"]
  },
  "icon": {
    "id": "icon",
    "selector": ".accordion-icon",
    "tag": "span",
    "parent": "title",
    "children": []
  }
}
```

---

## CSS Variable Auto-Generation

### Formula
```
--{blockType}-{element}-{cssProperty}[-state][-device]
```

### Examples

**Base attribute:**
```json
{
  "element": "title",
  "cssProperty": "color",
  "state": "base"
}
```
‚Üí `--accordion-title-color`

**Hover state:**
```json
{
  "element": "title",
  "cssProperty": "color",
  "state": "hover"
}
```
‚Üí `--accordion-title-color-hover`

**Responsive + State:**
```json
{
  "element": "icon",
  "cssProperty": "font-size",
  "state": "is-open",
  "responsive": true
}
```
‚Üí Generates:
- `--accordion-icon-font-size-is-open` (desktop)
- `--accordion-icon-font-size-is-open-tablet`
- `--accordion-icon-font-size-is-open-mobile`

---

## Handling Complex Scenarios

### Responsive + Per-State + Per-Side

**Example: Border width that's responsive, has hover state, and is per-side**

**After Expansion:**
```json
"header-border-width-top": {
  "cssProperty": "border-top-width",  // Side in CSS property
  "element": "title",
  "state": "base",
  "responsive": true
}
```

**Generated CSS Variables:**
- `--accordion-title-border-top-width` (desktop, base)
- `--accordion-title-border-top-width-tablet` (tablet, base)
- `--accordion-title-border-top-width-mobile` (mobile, base)

**With Hover State:**
```json
"header-border-width-top-hover": {
  "cssProperty": "border-top-width",
  "element": "title",
  "state": "hover",
  "responsive": true
}
```

**Generated CSS Variables:**
- `--accordion-title-border-top-width-hover` (desktop)
- `--accordion-title-border-top-width-hover-tablet`
- `--accordion-title-border-top-width-hover-mobile`

### Key Insight
**Per-side is encoded in `cssProperty`**, so each side is treated as an independent attribute!

---

## SCSS Generation Logic

### Grouping Algorithm
```javascript
// Group attributes by: element √ó state √ó device
For each attribute with cssProperty:
  For each device (desktop, tablet, mobile):
    key = `${element}:${state}:${device}`
    grouped[key].push(attribute)
```

### Selector Building
```javascript
function buildSelector(element, state, device) {
  let selector = elements[element].selector;

  // Add device wrapper
  if (device === 'tablet' || device === 'mobile') {
    selector = `[data-gutplus-device="${device}"] ${selector}`;
  }

  // Add state modifier
  if (state === 'hover') {
    selector += ':hover';
  } else if (state === 'is-open') {
    selector = `.accordion-item.is-open ${selector}`;
  }

  return selector;
}
```

### Generated SCSS Example
```scss
// Base state, desktop
.accordion-title {
  color: var(--accordion-title-color);
  border-top-width: var(--accordion-title-border-top-width);
}

// Hover state, desktop
.accordion-title:hover {
  color: var(--accordion-title-color-hover, var(--accordion-title-color));
}

// Base state, tablet
[data-gutplus-device="tablet"] .accordion-title {
  color: var(--accordion-title-color-tablet, var(--accordion-title-color));
  border-top-width: var(--accordion-title-border-top-width-tablet,
                        var(--accordion-title-border-top-width));
}

// Hover state, tablet
[data-gutplus-device="tablet"] .accordion-title:hover {
  color: var(--accordion-title-color-hover-tablet,
            var(--accordion-title-color-hover));
}
```

---

## Sidebar Panels (Current)

### How sidebar panels are built today
- Panels are driven by `schema.tabs` ‚Üí groups (id/title/order) and optional subgroups.
- Attributes render when `attr.group` matches the group id and `visibleOnSidebar !== false`.
- Ordering uses per-attribute `order` (lower first).
- Composite panel types are **object-valued attributes** that `ControlRenderer` expands into multiple sub-controls:
  - `type: "color-panel"` ‚Üí text/background + hover states
  - `type: "box-panel"` ‚Üí border/radius/shadow/padding/margin
  - `type: "typography-panel"` ‚Üí font family/size/line-height
  - `type: "border-panel"` ‚Üí width/color/style (single-side use cases)
- The icon group uses a dedicated `IconPanel` component (`shared/src/components/controls/IconPanel.js`).
- `controlId` can be used to group related attributes into a single composite control when needed (e.g. `BorderPanel`, `PanelColorSettings`).

### Note on `panelId`
`panelId` exists in the **comprehensive pipeline** (`schemas/parser/*`), but the current sidebar renderer (`shared/src/components/SchemaPanels.js`) does not consume it yet.

---

## Build Pipeline (Legacy: schema-compiler, deprecated)

### Command
```bash
npm run schema:build
```

### What It Did (schema-compiler.js, deprecated)
```javascript
// For each block type (accordion, tabs, toc)

// 1. Load schemas/{block}.json
const schema = loadSchema(blockType);

// 2. Expand icon-panel macros and auto-infer cssVar/group for panel types
schema.attributes = processAttributes(schema.attributes, blockType);

// 3. Write expanded schema for runtime use
//    schemas/{block}-schema-autogenerated.json
writeExpandedSchema(schema);

// 4. Generate outputs
//    - blocks/{block}/src/{block}-attributes.js
//    - shared/src/config/css-var-mappings-generated.js
//    - shared/src/styles/{block}-styles-generated.js
//    - shared/src/styles/{block}-css-vars-generated.js (editor)
//    - shared/src/styles/{block}-frontend-css-vars-generated.js (frontend)
//    - shared/src/config/control-config-generated.js
//    - shared/src/types/* + shared/src/validators/*
//    - docs/* (attribute docs)

// 5. Inject auto-generated code into edit.js/save.js:
//    - AUTO-GENERATED-STYLES (edit.js)
//    - AUTO-GENERATED-RENDER-TITLE + AUTO-GENERATED-BLOCK-CONTENT (edit.js/save.js)
//    - Structure JSX is generated from schemas/{block}-structure-mapping-autogenerated.json
```

### Comprehensive Parser CLI
```bash
node schemas/parser/main-orchestrator.js accordion --out schemas/accordion-comprehensive.json
```

- Parses `schemas/{block}-structure.html` via `html-parser.js`.
- Merges schema + structure, expands macros, and writes:
  - `schemas/{block}-structure-mapping-autogenerated.json`
  - `schemas/{block}-comprehensive.json` (structure stripped)
- Use `schemas/parser/scss-generator.js` to turn the comprehensive schema into
  `css/generated/{block}_variables.scss` (not wired to `schema:build` yet).

---

## edit.js / save.js Autogeneration (Current)

- `build-tools/schema-compiler.js` injects generated code into `blocks/{block}/src/edit.js` and `blocks/{block}/src/save.js` using marker comments.
- edit.js imports `schemas/{block}-schema-autogenerated.json` and `{block}-attributes.js`, both re-generated by `schema-compiler`.
- **AUTO-GENERATED-STYLES** (edit.js): `getInlineStyles(responsiveDevice)` is built from schema attributes (`appliesTo` + `cssProperty`), skipping non-base states and elements flagged via `needsMapping`.
- **AUTO-GENERATED-RENDER-TITLE** + **AUTO-GENERATED-BLOCK-CONTENT** (edit.js + save.js): generated by `build-tools/generators/structure-jsx-generator.js` from `schemas/{block}-structure-mapping-autogenerated.json`. RichText vs InnerBlocks is inferred by element naming conventions.
- **State + CSS var validation:** `schema-compiler` validates typography field mappings and the SCSS generator enforces that non-base states (e.g. `hover`) emit correct `:hover` selectors.

## Pipeline Pitfalls (and how to avoid them)
These issues are easy to miss because the schema, generated CSS vars, and editor inline styles are produced by different stages.

- **State metadata missing for non-base vars**: If an attribute's CSS var ends with `-hover` but the attribute lacks `state: "hover"`, SCSS generation will emit base selectors instead of `:hover`. Always ensure non-base states are explicitly set in expanders.
- **appliesTo ‚Üí cssVar mismatch**: If `appliesTo` is mapped to the wrong element name, generated vars won't match the selectors (e.g., `contentInner` must map to `--{block}-contentInner-*` so `.content-inner` gets padding).
- **Typography var suffix mismatch**: `text-decoration-line` requires a `-text-decoration-line` suffix, not `-text-decoration`. Keep typography field mappings in sync with CSS property names.
- **Hardcoded overrides masking schema vars**: Any static padding/margin in `*_hardcoded.scss` can override schema-driven variables. Reserve hardcoded CSS only for properties not represented in schema.
- Save components call `buildFrontendCssVars(attributes.customizations, attributes)` to output inline CSS vars for themeable deltas + non-themeable attributes.

## Sidebar + Preview Flow (Current)

1. `SchemaPanels` reads `schema.tabs` + groups and renders `GenericPanel`, `SubgroupPanel`, or `IconPanel`.
2. `ControlRenderer` maps `attr.control` or `attr.type` to actual UI controls. Composite `*-panel` types expand into object fields and write back via `setAttributes`.
3. `buildEditorCssVars(effectiveValues)` converts attributes to CSS vars using `shared/src/config/css-var-mappings-generated.js`, including `-tablet`/`-mobile` suffixes and per-side decompositions.
4. The block root sets `data-gutplus-device` (via `useResponsiveDevice`) so responsive SCSS selectors resolve the correct vars.
5. Theme changes are applied to attributes via `useThemeManager`, and `customizations` is kept as deltas for save.js.
6. Actual element targeting happens in SCSS (`css/*_hardcoded.scss` and/or `css/generated/*_variables.scss`) where selectors read `var(--*)`.

---

## Parser and Generator Files

### Legacy Build (schema-compiler, deprecated)

#### `build-tools/schema-compiler.js` (deprecated)
Reads `schemas/{block}.json`, expands icon-panel macros, generates JS/TS/PHP/config outputs, and injects auto-generated code into edit/save.

#### `build-tools/generators/structure-jsx-generator.js`
Converts `schemas/{block}-structure-mapping-autogenerated.json` into JSX for edit/save and injects it via markers.

#### `build-tools/generators/editor-css-vars-injector.js`
Generates `shared/src/styles/{block}-css-vars-generated.js` for editor preview CSS vars.

#### `build-tools/generators/frontend-css-vars-injector.js`
Generates `shared/src/styles/{block}-frontend-css-vars-generated.js` for frontend customizations.

### Comprehensive Parser

#### `html-parser.js`
Parses HTML template files into structured data.

**Features:**
- Extracts `data-el` ‚Üí element IDs
- Extracts `class` ‚Üí selectors
- Parses `data-when`/`data-else` ‚Üí conditionals
- Parses `data-switch`/`data-case` ‚Üí variations
- Parses `<template data-slot>` ‚Üí reusable fragments
- Builds parent/child relationships

#### `schema-merger.js`
Connects minimal schema to HTML structure.

**Does:**
- Normalizes `element` field (handles legacy `appliesTo`)
- Validates element exists in HTML structure
- Keeps schema clean (no bloat with _element* metadata)

#### `main-orchestrator.js` ‚≠ê COMPREHENSIVE ORCHESTRATOR
The brain of the comprehensive pipeline.

**Does:**
1. Expands macros ‚Üí atomic attributes
2. Auto-generates cssVar names using formula
3. Applies responsive variants (tablet/mobile)
4. Builds defaultValues map
5. Builds cssVarMap (CSS var ‚Üí attribute metadata)
6. Builds selectorVarMap (selector ‚Üí CSS vars array)
7. Builds responsiveSelectors array
8. Writes structure mapping to `blockname-structure-mapping-autogenerated.json`

### Macro Expanders (Comprehensive Pipeline)

#### `icon-expander.js`
Expands `icon-panel` into a complete, panel-driven icon system with base (closed) and open states.

**Minimal schema usage**
```json
"titleIcon": {
  "type": "icon-panel",
  "cssVar": "accordion-icon",
  "appliesTo": "icon",
  "default": {
    "position": "right",
    "animationRotation": "180deg",
    "inactive": {
      "source": { "icon-type": "char", "value": "‚ñæ" },
      "color": "#333333",
      "size": "16px",
      "maxSize": "24px",
      "offsetX": "0px",
      "offsetY": "0px",
      "initialRotation": "0deg"
    },
    "active": {
      "source": { "icon-type": "char", "value": "‚ñæ" },
      "initialRotation": "0deg"
    }
  }
}
```

**Macro inputs**
- `cssVar`: prefix for all icon vars. Accepts `accordion-icon` or `--accordion-icon` (normalized to `--`).
- `appliesTo` / `appliesToElement`: element id for the icon (defaults to `icon`).
- `positioningProfile`: `accordion`, `tabs`, or `toc` (controls allowed positions).
- `default`: nested defaults. Use `inactive` for closed, `active` for open. `base` is also accepted as `inactive`.

**Generated attributes (overview)**
- Panel toggles: `Show`, `UseDifferentIcons`, `Position`.
- Core: `AnimationRotation` (single value; applied on open).
- State-specific (for `inactive` and `is-open`):
  - `Source` (IconPicker, not CSS)
  - `Color` (text color for non-image icons)
  - `InitialRotation` (cosmetic rotation per icon)
  - `Transform` (computed, responsive)
  - `Size` (font-size for character/library icons, responsive)
  - `MaxSize` (max-width for image icons, responsive)
  - `OffsetX`, `OffsetY` (translate offsets, responsive)

**State handling**
- The expander always creates two states: `inactive` (no `state` field) and `is-open` (`state: "is-open"`).
- `UseDifferentIcons` toggles whether open-state fields are shown. If off, open values fall back to base.

**Rotation logic (human-readable)**
- Closed icon uses `initial-rotation` only.
- Open icon uses `(open-initial or initial) + animation-rotation`.
- `initial-rotation-is-open` is optional for the open icon's cosmetic orientation.

**Offset logic (human-readable)**
- Offsets are applied via `translate(x, y)` inside `transform`.
- Open offsets are absolute; if not set, they fall back to base offsets.

**Responsive logic**
- `Size`, `MaxSize`, `OffsetX`, `OffsetY` are responsive (desktop/tablet/mobile).
- `Transform` is generated per device using responsive offset values.

**Panel-side UI logic**
- Show/hide rules (e.g., image vs. non-image icon fields) are handled by the icon panel,
  not stored on expanded attributes.

#### `typography-expander.js`
Expands `typography-panel` ‚Üí per-field √ó per-state attributes
- Font size, weight, family
- Line height, letter spacing
- Text transform, decoration
- Supports multiple states (base, hover, etc.)

#### `border-expander.js`
Expands `border-panel` ‚Üí 12 attributes (4 sides √ó 3 properties)
- Width, color, style
- Per side: top, right, bottom, left

#### `box-expander.js`
Expands `box-panel` ‚Üí 25+ attributes
- All border attributes (via border-expander)
- Padding (4 sides)
- Margin (4 sides)
- Border radius (4 corners)
- Box shadow

#### `color-expander.js`
Expands `color-panel` into text/background color attributes with optional states.

**Minimal schema usage**
```json
"titleColor": {
  "type": "color-panel",
  "group": "headerColors",
  "subgroup": "Header",
  "appliesTo": "title",
  "states": ["base", "hover"],
  "fields": ["text", "background"],
  "cssVar": "accordion-title",
  "default": {
    "text": "#333333",
    "background": "#f5f5f5",
    "hover": {
      "text": "#000000",
      "background": "#e8e8e8"
    }
  }
}
```

**Macro inputs**
- `appliesTo` / `appliesToElement`: element id(s). Can be a single string or an array of element ids.
- `group` / `subgroup`: panel grouping (subgroup is optional).
- `states`: list of state keys (defaults to `["base"]`).
- `fields`: `["text", "background"]` (defaults to both).
- `properties`: override cssProperty per field (default: `text=color`, `background=background`).
- `cssVar`: base var name used by the expander (recommended when `appliesTo` is an array).
- `stateSubgroups`: map `{ hover: "Header - Hover" }` to override subgroup names per state.
- `default`: base defaults and optional per-state overrides.
- `needsMapping`: marks the base/first field for panel mapping (optional).
- `themeable`: defaults to `true`.
- Controls are defined by the color panel itself (text uses `ColorPicker`, background uses `ColorGradientControl`).

**Generated attributes (overview)**
- Attribute names use `buildKebabName(baseName, FieldSuffix, State)`:
  - `title-color-text`
  - `title-color-background`
  - `title-color-text-hover`
  - `title-color-background-hover`
- Each attribute is `outputsCSS: true`, uses the element(s) from `appliesTo`,
  and gets `state` for non-base states.

**Default structure**
```json
{
  "text": "#333333",
  "background": "transparent",
  "hover": {
    "text": "#000000",
    "background": "#e8e8e8"
  }
}
```

**Multi-element behavior**
- If `appliesTo` is an array, the same CSS vars are applied to each element selector.
- The expander still uses `cssVar` (or its inferred base) to build variable names.

### `responsive-expander.js`
Adds responsive variants to marked attributes.

**For each responsive attribute, adds:**
```json
"cssVarVariants": [
  "--accordion-title-color",         // desktop
  "--accordion-title-color-tablet",  // tablet
  "--accordion-title-color-mobile"   // mobile
]
```

---

## Success Criteria (Target)

‚úÖ **Zero synchronization issues** - One source drives everything
‚úÖ **Zero manual edits** - Add attribute ‚Üí all files auto-update
‚úÖ **Auto-generated CSS vars** - No manual naming, always consistent
‚úÖ **Trivial debugging** - Follow comprehensive schema to understand everything
‚úÖ **Trivial new features** - Define macro ‚Üí run build ‚Üí done
‚úÖ **Clean structure** - No redundancy, each section has clear purpose
‚úÖ **Panel/standalone distinction** - Clear organization in sidebar
‚úÖ **Edge cases handled** - Responsive + state + per-side all work

---

## Adding a New Feature

**Legacy build note (deprecated):** For `schema-compiler`, add the attribute to `schemas/{block}.json` (with `cssVar`, `cssProperty`, and `appliesTo`), then run `npm run schema:build`. New control types require updates in `ControlRenderer` and the generator(s) if they need special CSS-var expansion.

### Example: Add background gradient

**Step 1:** Edit minimal schema
```json
"title-background-gradient": {
  "type": "gradient-panel",
  "element": "title",
  "default": "linear-gradient(90deg, #fff 0%, #f5f5f5 100%)"
}
```

**Step 2:** Create expander (if needed)
```javascript
function expandGradientPanelMacro(name, attr, blockType) {
  return {
    [`${name}-type`]: { cssProperty: 'background-image', ... },
    [`${name}-angle`]: { cssProperty: 'background-angle', ... },
    [`${name}-stops`]: { cssProperty: 'background-stops', ... }
  };
}
```

**Step 3:** Register expander
```javascript
const EXPANDERS = {
  'gradient-panel': expandGradientPanelMacro
};
```

**Step 4:** Run build
```bash
npm run schema:build
```

**Done!** Zero manual edits to edit.js, save.js, or CSS.

---

## Debugging Guide

### Problem: Attribute not showing in sidebar

**Check:**
1. Is `group` set and does it match a group in `schema.tabs`?
2. Is `visibleOnSidebar !== false`?
3. For ordering: is `order` set (or expected to float to the end)?
4. If it's a composite control, does `type` map to a supported panel (`color-panel`, `box-panel`, `typography-panel`, `border-panel`)?

### Problem: CSS not applying

**Check:**
1. Does attribute have `cssVar` + `cssProperty` and `outputsCSS !== false`?
2. Does it have `appliesTo` (current) or `element` (comprehensive)?
3. Is the CSS var referenced in SCSS (`css/*_hardcoded.scss` or `css/generated/*_variables.scss`)?
4. If using comprehensive schema: check `structure.elements`, `cssVarMap`, and `selectorVarMap`.

### Problem: Responsive not working

**Check:**
1. Is `responsive: true` on the attribute?
2. Do you see `-tablet` / `-mobile` CSS vars in the inline styles (editor) or save output?
3. Is `data-gutplus-device` set on the block root?
4. Do SCSS selectors include `[data-gutplus-device="tablet"]` / `"mobile"`?

---

## Questions & Answers

**Q: Why kebab-case for attributes?**
A: This is for the comprehensive pipeline. The current source schemas are camelCase.

**Q: Why auto-generate cssVar names?**
A: In the legacy pipeline, `schema-compiler` auto-infers `cssVar` for panel types if missing; the comprehensive pipeline uses a formula for all attrs.

**Q: Can I customize CSS var names?**
A: Current pipeline: yes (set `cssVar` in the schema). Comprehensive pipeline: no (formula-driven).

**Q: How do I know if an attribute needs `order`?**
A: Current pipeline: `order` controls sidebar ordering for attributes in a group. Composite panel types are object-valued attrs (ordering handled by `ControlRenderer`).

**Q: What if I need to override a generated file?**
A: Don't. Edit the minimal schema or HTML template. If generator is wrong, fix the generator.

---

## Version

**Schema Version**: 2.0.0
**Generated**: Auto-updated on each build
**Last Updated**: 2026-01-07




