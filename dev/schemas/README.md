# Unified Schema Architecture (Single Source of Truth)

## Purpose

Eliminate all synchronization issues by creating a **single comprehensive schema** that drives every downstream artifact. No more mismatches between CSS, edit.js, save.js, and attribute definitions.

---

## Core Principles

### 1. **Single Source of Truth**
All outputs (CSS, React components, PHP) are generated from one comprehensive schema file.

### 2. **Kebab-Case Attributes**
All attribute names use CSS kebab-case matching CSS variable names exactly:
```javascript
"title-icon-size"  ‚Üí --accordion-title-icon-size
"border-top-color" ‚Üí --accordion-border-top-color
```

### 3. **Auto-Generated CSS Variables**
CSS variable names follow a strict formula:
```
--{blockType}-{element}-{cssProperty}[-state][-device]
```

Examples:
- `--accordion-title-color` (base state, desktop)
- `--accordion-title-color-hover` (hover state, desktop)
- `--accordion-icon-font-size-is-open-tablet` (open state, tablet)

### 4. **No Redundancy**
- Element details stored once in `elements` map
- CSS vars auto-generated from formula
- `order` only for standalone attributes (panels manage their own layout)

## Status + Next Phase

- CSS variable generation is complete (outputs in `css/generated/{block}_variables.scss`).
- HTML ‚Üí element mapping is complete and exported to `schemas/{block}-structure-mapping-autogenerated.json`.
- Next phase: reprogram panel generation and sidebar generation per block to use the new outputs.
  This starts by reading the existing sidebar/panel logic and planning how to feed it from the
  comprehensive schema + structure mapping.

---

## Architecture Flow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              SOURCE OF TRUTH (Human Editable)          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ  ‚îÇ Minimal Schema   ‚îÇ  ‚îÇ  HTML Structure      ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ accordion.json   ‚îÇ  ‚îÇ  accordion.html      ‚îÇ       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ                  ‚îÇ
             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚Üì
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ   UNIFIED PARSER PIPELINE   ‚îÇ
        ‚îÇ  (ONE transformation step)  ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         COMPREHENSIVE SCHEMA (Generated)                ‚îÇ
‚îÇ  ‚Ä¢ ALL attributes (macro-expanded, kebab-case)          ‚îÇ
‚îÇ  ‚Ä¢ ALL CSS variables (auto-generated)                   ‚îÇ
‚îÇ  ‚Ä¢ ALL responsive variants (tablet/mobile)              ‚îÇ
‚îÇ  ‚Ä¢ ALL defaults                                         ‚îÇ
‚îÇ  ‚Ä¢ Structure mapping exported separately (elements map) ‚îÇ
‚îÇ  ‚Ä¢ cssVarMap (CSS var ‚Üí attribute metadata)             ‚îÇ
‚îÇ  ‚Ä¢ selectorVarMap (selector ‚Üí CSS vars array)           ‚îÇ
‚îÇ  ‚Ä¢ responsiveSelectors (device-specific selectors)      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ           ‚îÇ          ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚Üì                 ‚Üì                 ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇedit.js ‚îÇ      ‚îÇ save.js ‚îÇ      ‚îÇ   SCSS   ‚îÇ
‚îÇ (auto) ‚îÇ      ‚îÇ (auto)  ‚îÇ      ‚îÇ  (auto)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Parser Goal (Minimal -> Comprehensive)

The parser system transforms a minimal schema into a fully comprehensive
schema that outputs all variables possible. This includes:
- Decomposed values per side (top/right/bottom/left) and per corner.
- Per-device responsive variants.
- All properties defined by the control group.
- A complete mapping of variables to their associated elements.

Later, the control panels and save logic will mesh/compress these atomic
properties back into grouped controls (e.g., if all sides match, emit a
single border-color). That compression happens on save, not in the parser.

Composite entries are auto-generated by the parser. Compression rules are
hardcoded per property family (not per attribute). Current rules:
- `padding`, `margin`, `border-width`, `border-style`, `border-color`: 1/2/3/4-value shorthands.
- `border-radius`: 1‚Äì4-value shorthand (no ellipse support).
- `border-{side}`: composed from `{side}-width/style/color` when all present.
- `border`: only valid when all four side values match (uses `border-top/right/bottom/left`).

The comprehensive schema should also include composite metadata referencing
atomic entries, e.g.:
`border-color` = (border-color-top, border-color-right, border-color-bottom, border-color-left)

Composite entries are stored as `type: "composite"` with a `compositeOf` list
of attribute keys. They do not emit CSS directly.

---

## HTML Template DSL (Domain Specific Language)

The HTML structure files use a powerful DSL that makes them the **single source of truth** for DOM structure, variations, and element relationships.

### DSL Features Overview

| Feature | Syntax | Purpose |
|---------|--------|---------|
| **Element ID** | `data-el="elementId"` | Mark elements for tracking |
| **Selector** | `class="primary-class"` | First class = CSS selector |
| **Conditional** | `data-when` / `data-else` | If/else branches |
| **Switch** | `data-switch` / `data-case` / `data-default` | Multi-way branches |
| **Slots** | `<template data-slot="name">` | Reusable fragments |
| **Placeholders** | `{variableName}` | Dynamic substitution |
| **Content Slot** | `<slot>` | InnerBlocks placeholder |

### 1. Element Identification: `data-el`

Marks elements for schema tracking. Each `data-el` creates an entry in the elements map.

```html
<div class="accordion-title" data-el="title">
  <span class="accordion-icon" data-el="icon"></span>
</div>
```

**Generated:**
```javascript
elements: {
  title: {
    id: "title",
    selector: ".accordion-title",  // First class
    tag: "div",
    parent: "item",
    children: ["icon"]
  }
}
```

### 2. Conditional Rendering: `data-when` / `data-else`

Create optional elements:

```html
<template data-when="headingLevel !== 'none'">
  <h{headingLevel} class="accordion-heading" data-el="heading">
    Header content
  </h{headingLevel}>
</template>
<template data-else>
  No header content
</template>
```

**Use Case:** Show heading wrapper only when user selects a heading level.

### 3. Switch Statements: `data-switch` / `data-case`

Multi-way layout variations:

```html
<template data-switch="iconPosition">
  <template data-case="box-left">
    <span data-el="iconSlot">Icon</span>
    <div data-el="titleText">Title</div>
  </template>
  <template data-case="box-right">
    <div data-el="titleText">Title</div>
    <span data-el="iconSlot">Icon</span>
  </template>
  <template data-default>
    <div data-el="titleInline">
      <span data-el="titleText">Title</span>
      <span data-el="icon">Icon inline</span>
    </div>
  </template>
</template>
```

**Use Case:** Different DOM structure based on icon position setting.

### 4. Reusable Fragments: `data-slot`

Define once, inject multiple times:

```html
<!-- Definition (with content) -->
<template data-slot="iconMarkup">
  <template data-when="iconSource.kind === 'image'">
    <img class="accordion-icon" data-el="icon" alt="">
  </template>
  <template data-else>
    <span class="accordion-icon" data-el="icon"></span>
  </template>
</template>

<!-- Injection (empty) -->
<div class="icon-wrapper">
  <template data-slot="iconMarkup"></template>
</div>
```

**Use Case:** Icon markup reused in multiple branches (box-left, box-right, inline).

### 5. String Substitution: `{placeholder}`

Dynamic values injected at render:

```html
<h{headingLevel} class="accordion-heading">
```

When `headingLevel = 3`:
```html
<h3 class="accordion-heading">
```

**Use Case:** Dynamic tag names, class names, attributes.

### 6. Content Placeholder: `<slot>`

Where user content (InnerBlocks) goes:

```html
<div class="accordion-content-inner" data-el="contentInner">
  <slot data-el="contentSlot"></slot>
</div>
```

**Generated:** Creates element with `isSlot: true`, used by save.js to place `<InnerBlocks>`.

### Complete DSL Example

```html
<div class="gutplus-accordion" data-el="item">
  <!-- Conditional wrapper -->
  <template data-when="headingLevel !== 'none'">
    <h{headingLevel} data-el="heading">
      <template data-slot="titleButton"></template>
    </h{headingLevel}>
  </template>

  <!-- Reusable button fragment -->
  <template data-slot="titleButton">
    <button class="accordion-title" data-el="title">
      <!-- Switch for icon position -->
      <template data-switch="iconPosition">
        <template data-case="left">
          <span data-el="icon">üìç</span>
          <span data-el="titleText">Title</span>
        </template>
        <template data-default>
          <span data-el="titleText">Title</span>
          <span data-el="icon">üìç</span>
        </template>
      </template>
    </button>
  </template>

  <!-- Content slot -->
  <div class="accordion-content" data-el="content">
    <slot data-el="contentSlot"></slot>
  </div>
</div>
```

**This single HTML file drives:**
- ‚úÖ edit.js generation (knows all variations)
- ‚úÖ save.js generation (knows DOM structure)
- ‚úÖ SCSS generation (knows selectors and hierarchy)
- ‚úÖ Zero manual sync required!

**For complete DSL reference, see:** `parser/html-parser.js` (200+ lines of inline documentation)

---

## File Structure

### Source Files (Human Editable)

#### `accordion.json` - Minimal Schema
**Contains**: High-level attribute definitions using macros
```json
{
  "blockType": "accordion",
  "attributes": {
    "titleColor": {
      "type": "string",
      "control": "ColorControl",
      "default": "#333333",
      "cssProperty": "color",
      "element": "title"
    },
    "titleIcon": {
      "type": "icon-panel",
      "element": "icon"
    }
  }
}
```

#### `accordion-structure.html` - HTML Template
**Contains**: DOM structure with DSL annotations
```html
<div class="gutplus-accordion" data-el="item">
  <button class="accordion-title" data-el="title">
    <span class="accordion-icon" data-el="icon"></span>
  </button>
  <div class="accordion-content" data-el="content"></div>
</div>
```

### Generated Files (Auto-Generated - Never Edit)

#### `accordion-comprehensive.json` - The Golden Source
Complete schema with all attribute metadata. This is THE source for all generators.
The element/selector map is exported separately.

#### `accordion-structure-mapping-autogenerated.json` - Element Map
Contains the HTML structure mapping (elements, selectors, parent/child) used by generators.

#### `css/` - CSS Sources
- `{block}_hardcoded.scss`: frontend layout and hardcoded CSS
- `{block}_editor.scss`: editor overrides (imports `{block}_hardcoded.scss`)
- `generated/{block}_variables.scss`: schema-driven variable/selector rules
- `{block}-structure-mapping-autogenerated.json`: structure mapping output

---

## Attribute Structure (Clean & Minimal)

### Atomic Attribute Example
```json
"title-color": {
  // Type & Control
  "type": "string",
  "control": "ColorControl",

  // UI Organization
  "label": "Text Color",
  "description": "Text color for the accordion header",
  "group": "colors",
  "subgroup": "Header",
  "order": 1,          // Only if standalone (not in panel)

  // CSS Connection
  "cssProperty": "color",
  "element": "title",   // Element ID (lookup in elements map)
  "cssVar": "--accordion-title-color",  // Auto-generated
  "default": "#333333",
  "responsive": false,
  "themeable": true,
  "state": "base"      // base, hover, is-open
}
```

### Panel-Controlled Attribute
```json
"title-icon-size": {
  "type": "string",
  "control": "SliderWithInput",
  "label": "Icon Size",
  "group": "icon",
  "panelId": "titleIcon",  // Links to icon-panel
  // NO order - panel controls layout
  "cssProperty": "font-size",
  "element": "icon",
  "cssVar": "--accordion-icon-font-size",  // Auto-generated
  "default": "16px",
  "responsive": true,
  "state": "base"
}
```

---

## Elements Map

Element details are stored in `blockname-structure-mapping-autogenerated.json` and looked up as needed:

```json
"elements": {
  "title": {
    "id": "title",
    "selector": ".accordion-title",
    "tag": "button",
    "parent": "titleWrapper",
    "children": ["icon", "titleText"]
  },
  "icon": {
    "id": "icon",
    "selector": ".accordion-icon",
    "tag": "span",
    "parent": "title",
    "children": []
  }
}
```

---

## CSS Variable Auto-Generation

### Formula
```
--{blockType}-{element}-{cssProperty}[-state][-device]
```

### Examples

**Base attribute:**
```json
{
  "element": "title",
  "cssProperty": "color",
  "state": "base"
}
```
‚Üí `--accordion-title-color`

**Hover state:**
```json
{
  "element": "title",
  "cssProperty": "color",
  "state": "hover"
}
```
‚Üí `--accordion-title-color-hover`

**Responsive + State:**
```json
{
  "element": "icon",
  "cssProperty": "font-size",
  "state": "is-open",
  "responsive": true
}
```
‚Üí Generates:
- `--accordion-icon-font-size-is-open` (desktop)
- `--accordion-icon-font-size-is-open-tablet`
- `--accordion-icon-font-size-is-open-mobile`

---

## Handling Complex Scenarios

### Responsive + Per-State + Per-Side

**Example: Border width that's responsive, has hover state, and is per-side**

**After Expansion:**
```json
"header-border-width-top": {
  "cssProperty": "border-top-width",  // Side in CSS property
  "element": "title",
  "state": "base",
  "responsive": true
}
```

**Generated CSS Variables:**
- `--accordion-title-border-top-width` (desktop, base)
- `--accordion-title-border-top-width-tablet` (tablet, base)
- `--accordion-title-border-top-width-mobile` (mobile, base)

**With Hover State:**
```json
"header-border-width-top-hover": {
  "cssProperty": "border-top-width",
  "element": "title",
  "state": "hover",
  "responsive": true
}
```

**Generated CSS Variables:**
- `--accordion-title-border-top-width-hover` (desktop)
- `--accordion-title-border-top-width-hover-tablet`
- `--accordion-title-border-top-width-hover-mobile`

### Key Insight
**Per-side is encoded in `cssProperty`**, so each side is treated as an independent attribute!

---

## SCSS Generation Logic

### Grouping Algorithm
```javascript
// Group attributes by: element √ó state √ó device
For each attribute with cssProperty:
  For each device (desktop, tablet, mobile):
    key = `${element}:${state}:${device}`
    grouped[key].push(attribute)
```

### Selector Building
```javascript
function buildSelector(element, state, device) {
  let selector = elements[element].selector;

  // Add device wrapper
  if (device === 'tablet' || device === 'mobile') {
    selector = `[data-gutplus-device="${device}"] ${selector}`;
  }

  // Add state modifier
  if (state === 'hover') {
    selector += ':hover';
  } else if (state === 'is-open') {
    selector = `.accordion-item.is-open ${selector}`;
  }

  return selector;
}
```

### Generated SCSS Example
```scss
// Base state, desktop
.accordion-title {
  color: var(--accordion-title-color);
  border-top-width: var(--accordion-title-border-top-width);
}

// Hover state, desktop
.accordion-title:hover {
  color: var(--accordion-title-color-hover, var(--accordion-title-color));
}

// Base state, tablet
[data-gutplus-device="tablet"] .accordion-title {
  color: var(--accordion-title-color-tablet, var(--accordion-title-color));
  border-top-width: var(--accordion-title-border-top-width-tablet,
                        var(--accordion-title-border-top-width));
}

// Hover state, tablet
[data-gutplus-device="tablet"] .accordion-title:hover {
  color: var(--accordion-title-color-hover-tablet,
            var(--accordion-title-color-hover));
}
```

---

## Panel vs Standalone Attributes

### Panel-Controlled Attributes
- Have `panelId` field
- **NO `order`** field (panel controls internal layout)
- Panel (IconPanel, TypographyPanel, etc.) organizes its own controls
- Generated by macro expanders (icon-panel, typography-panel, etc.)

**Example:**
```json
"title-icon-size": {
  "panelId": "titleIcon",
  "group": "icon"
  // Panel will organize size, color, offset controls internally
}
```

### Standalone Attributes
- **NO `panelId`**
- **HAS `order`** field for sidebar placement
- Rendered directly in group

**Example:**
```json
"animation-duration": {
  "group": "animation",
  "order": 5  // Position within "animation" group
}
```

### Sidebar Generator Logic
```javascript
function renderGroup(attributes, groupName) {
  const panelAttributes = attributes.filter(a => a.panelId);
  const standaloneAttributes = attributes.filter(a => !a.panelId);

  // Render panels (each controls its own layout)
  groupBy(panelAttributes, 'panelId').forEach(renderPanel);

  // Render standalone (sorted by order)
  standaloneAttributes
    .sort((a, b) => a.order - b.order)
    .forEach(renderControl);
}
```

---

## Build Pipeline

### Command
```bash
npm run schema:build
```

### What It Does
```javascript
// For each block type (accordion, tabs, toc)

// 1. Parse HTML structure
const structure = parseHTMLTemplate('accordion-structure.html');

// 2. Load minimal schema
const minimalSchema = require('accordion.json');

// 3. Merge schema + structure
const merged = mergeStructureIntoSchema(minimalSchema, structure);

// 4. Create comprehensive schema
const comprehensive = createComprehensiveSchema(merged);
//   ‚Üí Expands macros
//   ‚Üí Auto-generates cssVar names
//   ‚Üí Applies responsive variants
//   ‚Üí Builds all lookup maps

// 5. Write comprehensive schema + structure mapping
writeComprehensive('accordion-comprehensive.json', comprehensive);
// ‚Üí writes accordion-comprehensive.json (without structure)
// ‚Üí writes accordion-structure-mapping-autogenerated.json (element/selector map)

// 6. Generate SCSS
const scss = generateUniversalSCSS(comprehensive);
fs.writeFileSync('_comprehensive-variables.scss', scss);

// 7. Generate edit.js
const editJS = generateEditJS(comprehensive);
fs.writeFileSync('edit-generated.js', editJS);

// 8. Generate save.js
const saveJS = generateSaveJS(comprehensive);
fs.writeFileSync('save-generated.js', saveJS);
```

---

## Parser Files

### `html-parser.js`
Parses HTML template files into structured data.

**Features:**
- Extracts `data-el` ‚Üí element IDs
- Extracts `class` ‚Üí selectors
- Parses `data-when`/`data-else` ‚Üí conditionals
- Parses `data-switch`/`data-case` ‚Üí variations
- Parses `<template data-slot>` ‚Üí reusable fragments
- Builds parent/child relationships

### `schema-merger.js`
Connects minimal schema to HTML structure.

**Does:**
- Normalizes `element` field (handles legacy `appliesTo`)
- Validates element exists in HTML structure
- Keeps schema clean (no bloat with _element* metadata)

### `main-orchestrator.js` ‚≠ê THE ORCHESTRATOR
The brain of the pipeline.

**Does:**
1. Expands all macros ‚Üí atomic attributes
2. Auto-generates cssVar names using formula
3. Applies responsive variants (tablet/mobile)
4. Builds defaultValues map
5. Builds cssVarMap (CSS var ‚Üí attribute metadata)
6. Builds selectorVarMap (selector ‚Üí CSS vars array)
7. Builds responsiveSelectors array
8. Writes structure mapping to `blockname-structure-mapping-autogenerated.json`

### Macro Expanders

#### `icon-expander.js`
Expands `icon-panel` into a complete, panel-driven icon system with base (closed) and open states.

**Minimal schema usage**
```json
"titleIcon": {
  "type": "icon-panel",
  "cssVar": "accordion-icon",
  "appliesTo": "icon",
  "default": {
    "position": "right",
    "animationRotation": "180deg",
    "inactive": {
      "source": { "icon-type": "char", "value": "‚ñæ" },
      "color": "#333333",
      "size": "16px",
      "maxSize": "24px",
      "offsetX": "0px",
      "offsetY": "0px",
      "initialRotation": "0deg"
    },
    "active": {
      "source": { "icon-type": "char", "value": "‚ñæ" },
      "initialRotation": "0deg"
    }
  }
}
```

**Macro inputs**
- `cssVar`: prefix for all icon vars. Accepts `accordion-icon` or `--accordion-icon` (normalized to `--`).
- `appliesTo` / `appliesToElement`: element id for the icon (defaults to `icon`).
- `positioningProfile`: `accordion`, `tabs`, or `toc` (controls allowed positions).
- `default`: nested defaults. Use `inactive` for closed, `active` for open. `base` is also accepted as `inactive`.

**Generated attributes (overview)**
- Panel toggles: `Show`, `UseDifferentIcons`, `Position`.
- Core: `AnimationRotation` (single value; applied on open).
- State-specific (for `inactive` and `is-open`):
  - `Source` (IconPicker, not CSS)
  - `Color` (text color for non-image icons)
  - `InitialRotation` (cosmetic rotation per icon)
  - `Transform` (computed, responsive)
  - `Size` (font-size for character/library icons, responsive)
  - `MaxSize` (max-width for image icons, responsive)
  - `OffsetX`, `OffsetY` (translate offsets, responsive)

**State handling**
- The expander always creates two states: `inactive` (no `state` field) and `is-open` (`state: "is-open"`).
- `UseDifferentIcons` toggles whether open-state fields are shown. If off, open values fall back to base.

**Rotation logic (human-readable)**
- Closed icon uses `initial-rotation` only.
- Open icon uses `(open-initial or initial) + animation-rotation`.
- `initial-rotation-is-open` is optional for the open icon's cosmetic orientation.

**Offset logic (human-readable)**
- Offsets are applied via `translate(x, y)` inside `transform`.
- Open offsets are absolute; if not set, they fall back to base offsets.

**Responsive logic**
- `Size`, `MaxSize`, `OffsetX`, `OffsetY` are responsive (desktop/tablet/mobile).
- `Transform` is generated per device using responsive offset values.

**Panel-side UI logic**
- Show/hide rules (e.g., image vs. non-image icon fields) are handled by the icon panel,
  not stored on expanded attributes.

#### `typography-expander.js`
Expands `typography-panel` ‚Üí per-field √ó per-state attributes
- Font size, weight, family
- Line height, letter spacing
- Text transform, decoration
- Supports multiple states (base, hover, etc.)

#### `border-expander.js`
Expands `border-panel` ‚Üí 12 attributes (4 sides √ó 3 properties)
- Width, color, style
- Per side: top, right, bottom, left

#### `box-expander.js`
Expands `box-panel` ‚Üí 25+ attributes
- All border attributes (via border-expander)
- Padding (4 sides)
- Margin (4 sides)
- Border radius (4 corners)
- Box shadow

#### `color-expander.js`
Expands `color-panel` into text/background color attributes with optional states.

**Minimal schema usage**
```json
"titleColor": {
  "type": "color-panel",
  "group": "headerColors",
  "subgroup": "Header",
  "appliesTo": "title",
  "states": ["base", "hover"],
  "fields": ["text", "background"],
  "cssVar": "accordion-title",
  "default": {
    "text": "#333333",
    "background": "#f5f5f5",
    "hover": {
      "text": "#000000",
      "background": "#e8e8e8"
    }
  }
}
```

**Macro inputs**
- `appliesTo` / `appliesToElement`: element id(s). Can be a single string or an array of element ids.
- `group` / `subgroup`: panel grouping (subgroup is optional).
- `states`: list of state keys (defaults to `["base"]`).
- `fields`: `["text", "background"]` (defaults to both).
- `properties`: override cssProperty per field (default: `text=color`, `background=background`).
- `cssVar`: base var name used by the expander (recommended when `appliesTo` is an array).
- `stateSubgroups`: map `{ hover: "Header - Hover" }` to override subgroup names per state.
- `default`: base defaults and optional per-state overrides.
- `needsMapping`: marks the base/first field for panel mapping (optional).
- `themeable`: defaults to `true`.
- Controls are defined by the color panel itself (text uses `ColorPicker`, background uses `ColorGradientControl`).

**Generated attributes (overview)**
- Attribute names use `buildKebabName(baseName, FieldSuffix, State)`:
  - `title-color-text`
  - `title-color-background`
  - `title-color-text-hover`
  - `title-color-background-hover`
- Each attribute is `outputsCSS: true`, uses the element(s) from `appliesTo`,
  and gets `state` for non-base states.

**Default structure**
```json
{
  "text": "#333333",
  "background": "transparent",
  "hover": {
    "text": "#000000",
    "background": "#e8e8e8"
  }
}
```

**Multi-element behavior**
- If `appliesTo` is an array, the same CSS vars are applied to each element selector.
- The expander still uses `cssVar` (or its inferred base) to build variable names.

### `responsive-expander.js`
Adds responsive variants to marked attributes.

**For each responsive attribute, adds:**
```json
"cssVarVariants": [
  "--accordion-title-color",         // desktop
  "--accordion-title-color-tablet",  // tablet
  "--accordion-title-color-mobile"   // mobile
]
```

---

## Success Criteria

‚úÖ **Zero synchronization issues** - One source drives everything
‚úÖ **Zero manual edits** - Add attribute ‚Üí all files auto-update
‚úÖ **Auto-generated CSS vars** - No manual naming, always consistent
‚úÖ **Trivial debugging** - Follow comprehensive schema to understand everything
‚úÖ **Trivial new features** - Define macro ‚Üí run build ‚Üí done
‚úÖ **Clean structure** - No redundancy, each section has clear purpose
‚úÖ **Panel/standalone distinction** - Clear organization in sidebar
‚úÖ **Edge cases handled** - Responsive + state + per-side all work

---

## Adding a New Feature

### Example: Add background gradient

**Step 1:** Edit minimal schema
```json
"title-background-gradient": {
  "type": "gradient-panel",
  "element": "title",
  "default": "linear-gradient(90deg, #fff 0%, #f5f5f5 100%)"
}
```

**Step 2:** Create expander (if needed)
```javascript
function expandGradientPanelMacro(name, attr, blockType) {
  return {
    [`${name}-type`]: { cssProperty: 'background-image', ... },
    [`${name}-angle`]: { cssProperty: 'background-angle', ... },
    [`${name}-stops`]: { cssProperty: 'background-stops', ... }
  };
}
```

**Step 3:** Register expander
```javascript
const EXPANDERS = {
  'gradient-panel': expandGradientPanelMacro
};
```

**Step 4:** Run build
```bash
npm run schema:build
```

**Done!** Zero manual edits to edit.js, save.js, or CSS.

---

## Debugging Guide

### Problem: Attribute not showing in sidebar

**Check:**
1. Is `panelId` correct? (links to parent panel)
2. Is `group` set?
3. For standalone: Is `order` set?

### Problem: CSS not applying

**Check:**
1. Does attribute have `cssProperty`?
2. Does attribute have `element`?
3. Does element exist in `structure.elements`?
4. Check cssVarMap for the CSS variable
5. Check selectorVarMap for the selector

### Problem: Responsive not working

**Check:**
1. Is `responsive: true` on attribute?
2. Check `cssVarVariants` array has 3 entries
3. Check `responsiveSelectors` has entries for tablet/mobile
4. Check SCSS has `[data-gutplus-device="tablet"]` selectors

---

## Questions & Answers

**Q: Why kebab-case for attributes?**
A: Matches CSS variable names exactly. One naming convention, easier debugging.

**Q: Why auto-generate cssVar names?**
A: Eliminates inconsistency, enforces naming convention, reduces redundancy.

**Q: Can I customize CSS var names?**
A: No - consistency is more valuable than flexibility. The formula covers all cases.

**Q: How do I know if an attribute needs `order`?**
A: If it has `panelId`, NO order needed. If standalone, YES order needed.

**Q: What if I need to override a generated file?**
A: Don't. Edit the minimal schema or HTML template. If generator is wrong, fix the generator.

---

## Version

**Schema Version**: 2.0.0
**Generated**: Auto-updated on each build
**Last Updated**: 2026-01-04
